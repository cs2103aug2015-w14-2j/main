# A0124828B
###### src\logic\action\AbstractAction.java
``` java
public abstract class AbstractAction {
	
	protected TaskList taskList;
	protected TaskList latestDisplayedList;
	protected DisplayCommand latestDisplayCmd;
	
	public abstract Output execute();
	
	public void setTaskList(TaskList taskList) {
		this.taskList = taskList;
	};
	
	public void setLatestDisplayed (TaskList latestDisplayed) {
		this.latestDisplayedList = latestDisplayed;
	}
	public void setLatestDisplayCmd(DisplayCommand latestDisplayCmd) {
		this.latestDisplayCmd = latestDisplayCmd;
	}
}
```
###### src\logic\action\CreateAction.java
``` java
public class CreateAction extends AbstractAction {
	private Logger logger = SharedLogger.getInstance().getLogger();
	private static final String MESSAGE_CREATION = "\"%1$s\" has been created!";

	private CreateCommand createCommand;

	public CreateAction(CreateCommand createCommand, TaskList taskList,
			TaskList latestDisplayed) {
		this.createCommand = createCommand;
		this.taskList = taskList;
		this.latestDisplayedList = latestDisplayed;
	}

	public Output execute() {
		switch (this.createCommand.getTaskType()) {
		case FLOATING:
			return createFloatingTask(this.createCommand);
		case DEADLINE:
			return createDeadlineTask(this.createCommand);
		case BOUNDED:
			return createBoundedTask(this.createCommand);
		default:
			return new Output(Constants.MESSAGE_INVALID_COMMAND);
		}
	}

	private Output createFloatingTask(CreateCommand parsedCmd) {
		assert parsedCmd.getTaskName() != null;
		FloatingTask newFloatingTask = new FloatingTask(parsedCmd.getTaskName());
		this.taskList.addTask(newFloatingTask);
		logger.log(Level.INFO, "Creating floating task in CreateAction");
		return new Output(MESSAGE_CREATION, parsedCmd.getTaskName());
	}

	private Output createDeadlineTask(CreateCommand parsedCmd) {
		assert parsedCmd.getTaskName() != null;
		assert parsedCmd.getEndDateTime() != null;
		DeadlineTask newDeadlineTask = new DeadlineTask(
				parsedCmd.getTaskName(), parsedCmd.getEndDateTime());
		this.taskList.addTask(newDeadlineTask);
		logger.log(Level.INFO, "Creating deadline task in CreateAction");
		return new Output(MESSAGE_CREATION, parsedCmd.getTaskName());
	}

	private Output createBoundedTask(CreateCommand parsedCmd) {
		assert parsedCmd.getTaskName() != null;
		assert parsedCmd.getStartDateTime() != null;
		assert parsedCmd.getEndDateTime() != null;
		try {
			BoundedTask newBoundedTask = new BoundedTask(
					parsedCmd.getTaskName(), parsedCmd.getStartDateTime(),
					parsedCmd.getEndDateTime());
			this.taskList.addTask(newBoundedTask);
			logger.log(Level.INFO, "Creating bounded task in CreateAction");
		} catch (IllegalArgumentException e) {
			// Handles exception where supplied start datetime is later than end datetime
			return new Output(e);
		}
		return new Output(MESSAGE_CREATION, parsedCmd.getTaskName());
	}

}
```
###### src\logic\action\DeleteAction.java
``` java
public class DeleteAction extends AbstractAction{
	private Logger logger = SharedLogger.getInstance().getLogger();
	private static final String MESSAGE_SINGLE_DELETION = "\"%1$s\" has been deleted!";
	private static final String MESSAGE_ALL_DELETION = "All tasks have been deleted!";
	
	private DeleteCommand deleteCommand;
	
	public DeleteAction(DeleteCommand deleteCommand, TaskList taskList,
			TaskList latestDisplayed, DisplayCommand latestDisplayCmd) {
		this.deleteCommand = deleteCommand;
		this.taskList = taskList;
		this.latestDisplayedList = latestDisplayed;
		this.latestDisplayCmd = latestDisplayCmd;
	}
	
	public Output execute() {
		switch (this.deleteCommand.getType()) {
		case INDEX:
			return deleteByIndex(this.deleteCommand);
		case SEARCHKEYWORD:
			return deleteByKeyword(this.deleteCommand);
		case SCOPE:
			return deleteByScope(this.deleteCommand);
		default:
			// should not reach this code
			Output feedback = new Output(Constants.MESSAGE_INVALID_COMMAND);
			feedback.setPriority(Priority.HIGH);
			return feedback;
		}
	}
	
	private Output deleteByIndex(DeleteCommand parsedCmd) {
		assert (parsedCmd.getIndex() > 0);
		
		// Supplied index is out of bounds
		if (parsedCmd.getIndex() > latestDisplayedList.size()) {
			logger.log(Level.INFO, "Supplied index for delete is out of bounds!");
			Output feedback = new Output(Constants.MESSAGE_INVALID_INDEX);
			feedback.setPriority(Priority.HIGH);
			return feedback;
		}
		int indexToDelete = parsedCmd.getIndex() - 1;
		AbstractTask taskToDelete = latestDisplayedList.getTask(indexToDelete);
		String taskName = taskToDelete.getName();
		taskList.removeTask(taskToDelete);
		logger.log(Level.INFO, "Deleted task by index!");
		Output feedback = new Output(MESSAGE_SINGLE_DELETION, taskName);
		feedback.setPriority(Priority.HIGH);
		return feedback;
	}
	
	/**
	 * case 1: no tasks with keyword found
	 * case 2: one task with keyword found
	 * case 3: multiple tasks with keyword found
	 */
	
	private Output deleteByKeyword(DeleteCommand parsedCmd) {
		String keyword = parsedCmd.getSearchKeyword();
		TaskList filteredList = this.taskList.filterByName(keyword);
		
		if (filteredList.size() == 0) {
			logger.log(Level.INFO, "No tasks with keyword to delete.");
			return new Output(Constants.MESSAGE_INVALID_KEYWORD, keyword);
		} else if (filteredList.size() == 1
				&& filteredList.getTask(0).getName().equals(keyword)) {
			AbstractTask uniqueTask = filteredList.getTask(0);
			taskList.removeTask(uniqueTask);
			logger.log(Level.INFO, "Deleted task with keyword:" + keyword);
			Output feedback = new Output(MESSAGE_SINGLE_DELETION, keyword);
			feedback.setPriority(Priority.HIGH);
			return feedback;
		} else {
			ArrayList<String> keywords = new ArrayList<String>();
			keywords.add(keyword);
			DisplayCommand searchCmd = new DisplayCommand(keywords);
			DisplayAction searchAction = new DisplayAction(searchCmd, taskList,
					latestDisplayedList, latestDisplayCmd);
			logger.log(Level.INFO, "More than one task with keyword to delete, executing search.");
			return searchAction.execute();
		}
	}

	// Can add more batch delete scopes in the future
	private Output deleteByScope(DeleteCommand parsedCmd) {
			return deleteAllTasks(parsedCmd);
		
	}

	private Output deleteAllTasks(DeleteCommand parsedCmd) {
		taskList.clear();
		logger.log(Level.INFO, "Deleted all tasks!");
		Output feedback = new Output(MESSAGE_ALL_DELETION);
		feedback.setPriority(Priority.HIGH);
		return feedback;
	}

}
```
###### src\logic\action\DisplayAction.java
``` java
public class DisplayAction extends AbstractAction {
	private Logger logger = SharedLogger.getInstance().getLogger();
	private static final String MESSAGE_DISPLAY_ALL = "All tasks are now displayed!";
	private static final String MESSAGE_DISPLAY_EMPTY = "There are no tasks to display :'(";
	private static final String MESSAGE_DISPLAY_FLOATING = "All floating tasks are now displayed!";
	private static final String MESSAGE_DISPLAY_DEFAULT = "Welcome to Flexi-List!";
	private static final String MESSAGE_DISPLAY_STATUS = "All %1$s tasks are now displayed!";
	private static final String MESSAGE_DISPLAY_KEYWORD = "All tasks with keyword \"%1$s\" are now displayed!";
	private static final String MESSAGE_DISPLAY_DATE = "All tasks with date \"%1$s\" are now displayed!";
	private static final String MESSAGE_DISPLAY_DATE_EMPTY = "There are no tasks with date \"%1$s\" :)";
	private static final int OVERDUE_COUNT = 1;
	private static final int DATED_COUNT = 10;
	private static final int FLOATING_COUNT = 3;

	private DisplayCommand displayCommand;

	public DisplayAction(DisplayCommand displayCommand, TaskList taskList,
			TaskList latestDisplayed, DisplayCommand latestDisplayCmd) {
		this.displayCommand = displayCommand;
		this.taskList = taskList;
		this.latestDisplayedList = latestDisplayed;
		this.latestDisplayCmd = latestDisplayCmd;
	}

	public Output execute() {
		switch (this.displayCommand.getType()) {
		case SCOPE:
			return displayByScope(this.displayCommand);
		case SEARCHKEY:
			return displayByName(this.displayCommand.getSearchKeyword());
		case SEARCHDATE:
			return displayOnDate(this.displayCommand);
		default:
			// should not reach this code
			Output feedback = new Output(Constants.MESSAGE_INVALID_COMMAND);
			feedback.setPriority(Priority.HIGH);
			return feedback;
		}
	}

	private Output displayByScope(DisplayCommand parsedCmd) {
		assert (parsedCmd.getScope() != null);

		switch (parsedCmd.getScope()) {
		case ALL:
			return displayAllTasks();
		case FLOATING:
			return displayFloating();
		case DEFAULT:
			return displayDefault();
		case DONE:
			return displayStatus(Status.DONE);
		case UNDONE:
			return displayStatus(Status.UNDONE);
		default:
			// should not reach this code
			Output feedback = new Output(Constants.MESSAGE_INVALID_COMMAND);
			feedback.setPriority(Priority.HIGH);
			return feedback;
		}
	}

	private Output displayAllTasks() {
		latestDisplayCmd
				.replaceCmd(new DisplayCommand(DisplayCommand.Scope.ALL));
		TaskList sortedTaskList = this.taskList.getDateSortedClone();
		latestDisplayedList.replaceContents(sortedTaskList);
		logger.log(Level.INFO, "Executed display all in DisplayAction");
		Output output = new Output(sortedTaskList);
		if (sortedTaskList.size() < 1) {
			output.setReturnMessage(MESSAGE_DISPLAY_EMPTY);
		} else {
			output.setReturnMessage(MESSAGE_DISPLAY_ALL);
		}
		return output;
	}

	private Output displayFloating() {
		latestDisplayCmd.replaceCmd(new DisplayCommand(
				DisplayCommand.Scope.FLOATING));
		TaskList filteredList = this.taskList.filterForFloating();
		latestDisplayedList.replaceContents(filteredList);
		logger.log(Level.INFO, "Executed display floating in DisplayAction");
		Output output = new Output(filteredList);
		if (filteredList.size() < 1) {
			output.setReturnMessage(MESSAGE_DISPLAY_EMPTY);
		} else {
			output.setReturnMessage(MESSAGE_DISPLAY_FLOATING);
		}

		return output;
	}

	/**
	 * Creates default view of combination of overdue, dated and floating tasks
	 * Number of each task can be changed in the final static integers declared
	 * above
	 */
	
	private Output displayDefault() {
		latestDisplayCmd.replaceCmd(new DisplayCommand(
				DisplayCommand.Scope.DEFAULT));
		TaskList filteredList = new TaskList();
		TaskList undoneTaskList = this.taskList.filterByStatus(Status.UNDONE);

		// Filtering OVERDUE_COUNT number of overdue task that is closest to
		// current date
		TaskList overdueList = undoneTaskList.filterByOverdue(true);
		if (overdueList.size() > OVERDUE_COUNT) {
			overdueList = overdueList.getDateSortedClone();
			overdueList = overdueList.subList(overdueList.size()
					- OVERDUE_COUNT + 1, overdueList.size());
		}

		// Filtering DATED_COUNT number of dated task that is closest to and
		// after current date
		TaskList datedTaskList = undoneTaskList
				.filterInclusiveAfterDate(LocalDate.now());
		datedTaskList = datedTaskList.filterByOverdue(false);
		if (datedTaskList.size() > DATED_COUNT) {
			datedTaskList = datedTaskList.subList(0, DATED_COUNT);
		}
		datedTaskList = datedTaskList.getDateSortedClone();

		// Filtering FLOATING_COUNT number of floating task
		TaskList floatingTaskList = undoneTaskList.filterForFloating();
		if (floatingTaskList.size() > FLOATING_COUNT) {
			floatingTaskList = floatingTaskList.subList(floatingTaskList.size()
					- FLOATING_COUNT, floatingTaskList.size());
		}
		filteredList.addAll(overdueList);
		filteredList.addAll(datedTaskList);
		filteredList.addAll(floatingTaskList);

		assert (filteredList.size() <= OVERDUE_COUNT + FLOATING_COUNT
				+ DATED_COUNT);

		latestDisplayedList.replaceContents(filteredList);
		logger.log(Level.INFO, "Executed display default in DisplayAction");
		Output output = new Output(filteredList);
		if (filteredList.size() < 1) {
			output.setReturnMessage(MESSAGE_DISPLAY_EMPTY);
		} else {
			output.setReturnMessage(MESSAGE_DISPLAY_DEFAULT);
		}
		return output;
	}

	private Output displayStatus(Status status) {
		assert status != null;
		if (status == Status.DONE) {
			latestDisplayCmd.replaceCmd(new DisplayCommand(
					DisplayCommand.Scope.DONE));
		} else {
			latestDisplayCmd.replaceCmd(new DisplayCommand(
					DisplayCommand.Scope.UNDONE));
		}
		TaskList sortedTaskList = this.taskList.getDateSortedClone();
		TaskList filteredList = sortedTaskList.filterByStatus(status);

		latestDisplayedList.replaceContents(filteredList);
		logger.log(Level.INFO, "Executed display by status in DisplayAction");
		Output output = new Output(filteredList);
		if (filteredList.size() < 1) {
			output.setReturnMessage(MESSAGE_DISPLAY_EMPTY);
		} else {
			output.setReturnMessage(String.format(MESSAGE_DISPLAY_STATUS,
					status.toString()));
		}
		return output;
	}

	private Output displayByName(ArrayList<String> keywords) {
		latestDisplayCmd.replaceCmd(new DisplayCommand(keywords));
		TaskList undoneTaskList = this.taskList.filterByStatus(Status.UNDONE);
		TaskList sortedTaskList = undoneTaskList.getDateSortedClone();
		latestDisplayedList.replaceContents(sortedTaskList
				.filterByNames(keywords));
		
		logger.log(Level.INFO, "Executed display by name in DisplayAction");
		Output output = new Output(latestDisplayedList);
		String searchTerms = stringify(keywords);
		if (latestDisplayedList.size() < 1) {
			output = new Output(Constants.MESSAGE_INVALID_KEYWORD, searchTerms);
			output.setPriority(Priority.HIGH);
		} else {
			output.setReturnMessage(String.format(MESSAGE_DISPLAY_KEYWORD,
					searchTerms));
		}

		return output;
	}

	private Output displayOnDate(DisplayCommand parsedCmd) {
		latestDisplayCmd.replaceCmd(new DisplayCommand(parsedCmd
				.getSearchDate()));
		LocalDate queryDate = parsedCmd.getSearchDate().toLocalDate();
		TaskList undoneTaskList = this.taskList.filterByStatus(Status.UNDONE);
		TaskList sortedTaskList = undoneTaskList.getDateSortedClone();
		latestDisplayedList.replaceContents(sortedTaskList
				.filterByDate(queryDate));

		logger.log(Level.INFO, "Executed display by date in DisplayAction");
		Output output = new Output(latestDisplayedList);
		DateTimeFormatter DTFormatter = DateTimeFormatter
				.ofPattern("dd MM yyyy");
		String returnDate = queryDate.format(DTFormatter);
		if (latestDisplayedList.size() < 1) {
			output.setReturnMessage(String.format(MESSAGE_DISPLAY_DATE_EMPTY,
					returnDate));
		} else {
			output.setReturnMessage(String.format(MESSAGE_DISPLAY_DATE,
					returnDate));
		}
		return output;
	}

	private String stringify(ArrayList<String> stringArray) {
		String returnString = "";
		for (String string : stringArray) {
			returnString = returnString + string + " ";
		}
		// Trim away space left by last element
		returnString = returnString.trim();
		return returnString;
	}
}
```
###### src\logic\action\EditAction.java
``` java
public class EditAction extends AbstractAction {
	private Logger logger = SharedLogger.getInstance().getLogger();
	private static final String MESSAGE_UPDATE = "\"%1$s\" has been edited!";
	private static final String MESSAGE_UPDATE_WRONG_TYPE = "Invalid: Task specified does not have this operation.";

	private EditCommand editCommand;
	private EditCommand latestComplexEdit;
	private ExtendedBoolean shouldKeepComplexEdit;

	public EditAction(EditCommand editCommand, TaskList taskList,
			TaskList latestDisplayed, DisplayCommand latestDisplayCmd) {
		this.editCommand = editCommand;
		this.taskList = taskList;
		this.latestDisplayedList = latestDisplayed;
		this.latestDisplayCmd = latestDisplayCmd;
	}

	/**
	 * A complex edit is when the user types in >> edit meeting to [new name]
	 * with multiple instances of meeting in the user view Flexi-list will then
	 * remember the supplied [new name] and edit it accordingly after the user
	 * indicates meeting to edit by declaring its index
	 */

	public void setComplexEdit(EditCommand cmd) {
		this.latestComplexEdit = cmd;
	}

	public void setShouldComplexEdit(ExtendedBoolean shouldKeepComplexEdit) {
		this.shouldKeepComplexEdit = shouldKeepComplexEdit;
	}

	public Output execute() {
		switch (this.editCommand.getType()) {
		case INDEX:
			return editByIndex(this.editCommand);
		case SEARCHKEYWORD:
			return editByKeyword(this.editCommand);
		default:
			// should not reach this code
			Output feedback = new Output(Constants.MESSAGE_INVALID_COMMAND);
			feedback.setPriority(Priority.HIGH);
			return feedback;
		}
	}

	private Output editByIndex(EditCommand parsedCmd) {
		assert (parsedCmd.getIndex() > 0);

		if (parsedCmd.getIndex() > latestDisplayedList.size()) {
			logger.log(Level.INFO, "Supplied index for edit is out of bounds!");
			Output feedback = new Output(Constants.MESSAGE_INVALID_INDEX);
			feedback.setPriority(Priority.HIGH);
			return feedback;
		}
		int inputTaskIndex = parsedCmd.getIndex() - 1;
		AbstractTask taskToEdit = latestDisplayedList.getTask(inputTaskIndex);
		String originalName = taskToEdit.getName();
		int taskIndexInTaskList = taskList.indexOf(taskToEdit);
		AbstractTask actualTaskToEdit = taskList.getTask(taskIndexInTaskList);
		try {
			if (latestComplexEdit.getNature() == Nature.COMPLEX) {
				performEdit(latestComplexEdit, actualTaskToEdit);
				performEdit(parsedCmd, actualTaskToEdit);
			} else if (parsedCmd.getEditFields().isEmpty()) {
				Output feedback = new Output(Constants.MESSAGE_INVALID_COMMAND);
				feedback.setPriority(Priority.HIGH);
				return feedback;
			} else {
				performEdit(parsedCmd, actualTaskToEdit);
			}

		} catch (IllegalArgumentException e) {
			// Happens when user tries to set start or end date that violates
			// chronological order
			logger.log(Level.WARNING, "Supplied start or end datetime violates chronological order!");
			return new Output(e);
		} catch (ClassCastException e) {
			// Happens when user tries to edit a non-existent field in task
			// e.g. edit start time of floating task
			logger.log(Level.WARNING, "Supplied edit fields is invalid for specified task!");
			Output feedback = new Output(MESSAGE_UPDATE_WRONG_TYPE);
			feedback.setPriority(Priority.HIGH);
			return feedback;
		}
		logger.log(Level.INFO, "Edited task with index:" + inputTaskIndex);
		return new Output(MESSAGE_UPDATE, originalName);
	}

	/**
	 * case 1: no tasks with keyword found case 2: one task with keyword found
	 * case 3: multiple tasks with keyword found
	 */
	private Output editByKeyword(EditCommand parsedCmd) {
		String keyword = parsedCmd.getSearchKeyword();
		TaskList filteredList = this.taskList.filterByName(keyword);
		if (filteredList.size() == 0) {
			Output feedback = new Output(Constants.MESSAGE_INVALID_KEYWORD,
					keyword);
			feedback.setPriority(Priority.HIGH);
			logger.log(Level.INFO, "No task with given keyword to edit.");
			return feedback;
		} else if (filteredList.size() == 1
				&& filteredList.getTask(0).getName().equals(keyword)) {
			AbstractTask uniqueTask = filteredList.getTask(0);
			String originalName = uniqueTask.getName();
			try {
				performEdit(parsedCmd, uniqueTask);
			} catch (IllegalArgumentException e) {
				// Happens when user tries to set start or end date that
				// violates chronological order
				logger.log(Level.WARNING, "Supplied start or end datetime violates chronological order!");
				return new Output(e);
			} catch (ClassCastException e) {
				// Happens when user tries to edit a non-existent field in task
				// e.g. edit start time of floating task
				logger.log(Level.WARNING, "Supplied edit fields is invalid for specified task!");
				Output feedback = new Output(MESSAGE_UPDATE_WRONG_TYPE);
				feedback.setPriority(Priority.HIGH);
				return feedback;
			}
			logger.log(Level.INFO, "Edited task with originalName:" + originalName);
			return new Output(MESSAGE_UPDATE, originalName);
		} else {
			// record down additional content given by user
			parsedCmd.setNature(Nature.COMPLEX);
			latestComplexEdit.replaceCmd(parsedCmd);
			shouldKeepComplexEdit.setTrue();
			ArrayList<String> keywords = new ArrayList<String>();
			keywords.add(keyword);
			DisplayCommand searchCmd = new DisplayCommand(keywords);
			DisplayAction searchAction = new DisplayAction(searchCmd, taskList,
					latestDisplayedList, latestDisplayCmd);
			logger.log(Level.INFO, "More than one task with keyword to edit, executing search.");
			return searchAction.execute();
		}
	}

	/*
	 * Helper methods for editing task fields
	 */

	private void performEdit(EditCommand parsedCmd, AbstractTask taskToEdit)
			throws ClassCastException, IllegalArgumentException {
		ArrayList<editField> editFields = parsedCmd.getEditFields();
		if (taskToEdit instanceof BoundedTask) {
			performBoundedEdit(parsedCmd, (BoundedTask) taskToEdit);
			return;
		}
		if (editFields == null) {
			// only happens with two part edit
			return;
		}
		for (int i = 0; i < editFields.size(); i++) {
			try {
				if (editFields.get(i) == editField.NAME) {
					editTaskName(taskToEdit, parsedCmd.getNewName());
				} else if (editFields.get(i) == editField.START_DATE) {
					editStartDate(taskToEdit, parsedCmd.getNewStartDate());
				} else if (editFields.get(i) == editField.START_TIME) {
					editStartTime(taskToEdit, parsedCmd.getNewStartTime());
				} else if (editFields.get(i) == editField.END_DATE) {
					editEndDate(taskToEdit, parsedCmd.getNewEndDate());
				} else if (editFields.get(i) == editField.END_TIME) {
					editEndTime(taskToEdit, parsedCmd.getNewEndTime());
				}
			} catch (Exception e) {
				throw e;
			}
		}
	}

	/*
	 * Perform bounded edit has additional checks for the correctness of start
	 * and end datetime supplied in edit command
	 */
	private void performBoundedEdit(EditCommand parsedCmd,
			BoundedTask taskToEdit) throws ClassCastException,
			IllegalArgumentException {
		ArrayList<editField> editFields = parsedCmd.getEditFields();
		if (editFields == null) {
			// only happens with two part edit
			return;
		}
		LocalDateTime newStart;
		LocalDateTime newEnd;
		DateTimeFormatter DFormatter = DateTimeFormatter
				.ofPattern("dd MM yyyy");
		DateTimeFormatter TFormatter = DateTimeFormatter.ofPattern("HH mm");
		newStart = taskToEdit.getStartDateTime();
		newEnd = taskToEdit.getEndDateTime();
		for (int i = 0; i < editFields.size(); i++) {
			try {

				if (editFields.get(i) == editField.NAME) {
					editTaskName(taskToEdit, parsedCmd.getNewName());
				} else if (editFields.get(i) == editField.START_DATE) {
					LocalDate newDate = LocalDate.parse(
							parsedCmd.getNewStartDate(), DFormatter);
					newStart = newStart.withDayOfMonth(newDate.getDayOfMonth());
					newStart = newStart.withMonth(newDate.getMonthValue());
					newStart = newStart.withYear(newDate.getYear());
				} else if (editFields.get(i) == editField.START_TIME) {
					LocalTime newTime = LocalTime.parse(
							parsedCmd.getNewStartTime(), TFormatter);
					newStart = newStart.withHour(newTime.getHour());
					newStart = newStart.withMinute(newTime.getMinute());
				} else if (editFields.get(i) == editField.END_DATE) {
					LocalDate newDate = LocalDate.parse(
							parsedCmd.getNewEndDate(), DFormatter);
					newEnd = newEnd.withDayOfMonth(newDate.getDayOfMonth());
					newEnd = newEnd.withMonth(newDate.getMonthValue());
					newEnd = newEnd.withYear(newDate.getYear());
				} else if (editFields.get(i) == editField.END_TIME) {
					LocalTime newTime = LocalTime.parse(
							parsedCmd.getNewEndTime(), TFormatter);
					newEnd = newEnd.withHour(newTime.getHour());
					newEnd = newEnd.withMinute(newTime.getMinute());
				}
			} catch (Exception e) {
				throw e;
			}
		}
		if (newStart.isAfter(taskToEdit.getEndDateTime())) {
			taskToEdit.setEndDate(newEnd.format(DFormatter));
			taskToEdit.setEndTime(newEnd.format(TFormatter));
			taskToEdit.setStartDate(newStart.format(DFormatter));
			taskToEdit.setStartTime(newStart.format(TFormatter));
		} else {
			taskToEdit.setStartDate(newStart.format(DFormatter));
			taskToEdit.setStartTime(newStart.format(TFormatter));
			taskToEdit.setEndDate(newEnd.format(DFormatter));
			taskToEdit.setEndTime(newEnd.format(TFormatter));
		}

	}

	private void editTaskName(AbstractTask task, String name) {
		task.setName(name);
	}

	private void editStartDate(AbstractTask task, String startDate)
			throws ClassCastException, IllegalArgumentException {
		((BoundedTask) task).setStartDate(startDate);
	}

	private void editStartTime(AbstractTask task, String startTime)
			throws ClassCastException, IllegalArgumentException {
		((BoundedTask) task).setStartTime(startTime);
	}

	private void editEndDate(AbstractTask task, String endDate)
			throws ClassCastException, IllegalArgumentException {
		if (task instanceof FloatingTask) {
			throw new ClassCastException();
		} else if (task instanceof DeadlineTask) {
			((DeadlineTask) task).setEndDate(endDate);
		} else if (task instanceof BoundedTask) {
			((BoundedTask) task).setEndDate(endDate);
		}
	}

	private void editEndTime(AbstractTask task, String endTime)
			throws ClassCastException, IllegalArgumentException {
		if (task instanceof FloatingTask) {
			throw new ClassCastException();
		} else if (task instanceof DeadlineTask) {
			((DeadlineTask) task).setEndTime(endTime);
		} else if (task instanceof BoundedTask) {
			((BoundedTask) task).setEndTime(endTime);
		}
	}

}
```
###### src\logic\action\MarkAction.java
``` java
public class MarkAction extends AbstractAction {
	private Logger logger = SharedLogger.getInstance().getLogger();
	private static final String MESSAGE_MARK_DONE = "\"%1$s\" has been marked done.";
	private static final String MESSAGE_MARK_UNDONE = "\"%1$s\" has been marked undone.";
	private static final String MESSAGE_MARK_INVALID = "Invalid: Mark/Unmark operation has already been done.";

	private MarkCommand markCommand;

	public MarkAction(MarkCommand markCommand, TaskList taskList,
			TaskList latestDisplayed, DisplayCommand latestDisplayCmd) {
		this.markCommand = markCommand;
		this.taskList = taskList;
		this.latestDisplayedList = latestDisplayed;
		this.latestDisplayCmd = latestDisplayCmd;
	}

	public Output execute() {
		switch (this.markCommand.getType()) {
		case INDEX:
			return markByIndex(this.markCommand);
		case SEARCHKEYWORD:
			return markByKeyword(this.markCommand);
		default:
			// should not reach this code
			Output feedback = new Output(Constants.MESSAGE_INVALID_COMMAND);
			feedback.setPriority(Priority.HIGH);
			return feedback;
		}
	}

	private Output markByIndex(MarkCommand parsedCmd) {
		assert (parsedCmd.getIndex() > 0);

		if (parsedCmd.getIndex() > latestDisplayedList.size()) {
			logger.log(Level.INFO, "Supplied index for mark is out of bounds!");
			Output feedback = new Output(Constants.MESSAGE_INVALID_INDEX);
			feedback.setPriority(Priority.HIGH);
			return feedback;
		}

		int inputTaskIndex = parsedCmd.getIndex() - 1;
		AbstractTask displayTaskToMark = latestDisplayedList
				.getTask(inputTaskIndex);
		int taskIndexInTaskList = this.taskList.indexOf(displayTaskToMark);
		AbstractTask actualTaskToMark = this.taskList
				.getTask(taskIndexInTaskList);
		// Initialized as invalid in case parsedCmd behaves unexpectedly
		Output feedback = new Output(Constants.MESSAGE_INVALID_COMMAND);
		executeMark(parsedCmd, actualTaskToMark, feedback);
		return feedback;
	}

	/**
	 * case 1: no tasks with keyword found 
	 * case 2: one task with keyword found
	 * case 3: multiple tasks with keyword found
	 */

	private Output markByKeyword(MarkCommand parsedCmd) {
		String keyword = parsedCmd.getSearchKeyword();

		// Initialized as invalid in case parsedCmd behaves unexpectedly
		Output feedback = new Output(Constants.MESSAGE_INVALID_COMMAND);

		TaskList filteredList = this.taskList.filterByName(keyword);
		if (filteredList.size() == 0) {
			feedback = new Output(Constants.MESSAGE_INVALID_KEYWORD, keyword);
			feedback.setPriority(Priority.HIGH);
			logger.log(Level.INFO, "No task with given keyword to mark.");
			return feedback;
		} else if (filteredList.size() == 1
				&& filteredList.getTask(0).getName().equals(keyword)) {
			AbstractTask uniqueTask = filteredList.getTask(0);
			executeMark(parsedCmd, uniqueTask, feedback);
			return feedback;
		} else {
			ArrayList<String> keywords = new ArrayList<String>();
			keywords.add(keyword);
			DisplayCommand searchCmd = new DisplayCommand(keywords);
			DisplayAction searchAction = new DisplayAction(searchCmd, taskList,
					latestDisplayedList, latestDisplayCmd);
			logger.log(Level.INFO,
					"More than one task with keyword to mark, executing search.");
			return searchAction.execute();
		}
	}
	
	/**
	 * case 1: MarkCommand is invalid and will be marked so that it is not undo-able
	 * case 2: MarkCommand marks task as done
	 * case 3: MarkCommand marks task as undone
	 */
	
	private void executeMark(MarkCommand cmd, AbstractTask task, Output feedback) {
		String taskName = task.getName();
		if (isInvalidMark(cmd, task)) {
			logger.log(Level.INFO, "Invalid: MarkCommand does not change state");
			cmd.setInvalidMark(true);
			feedback.replaceWith(new Output(MESSAGE_MARK_INVALID));
		} else if (cmd.getMarkField().equals(markField.MARK)) {
			logger.log(Level.INFO, "Marked task with name:" + taskName);
			task.setStatus(Status.DONE);
			feedback.replaceWith(new Output(MESSAGE_MARK_DONE, taskName));
			removeOverdue(task);
		} else if (cmd.getMarkField().equals(markField.UNMARK)) {
			logger.log(Level.INFO, "Unmarked task with name:" + taskName);
			feedback.replaceWith(new Output(MESSAGE_MARK_UNDONE, taskName));
			task.setStatus(Status.UNDONE);
		}
	}

	// A mark command is deemed as invalid if its targeted task will not have
	// its status changed.
	private boolean isInvalidMark(MarkCommand cmd, AbstractTask task) {
		if (cmd.getMarkField().equals(markField.MARK)
				&& task.getStatus().equals(Status.DONE)) {
			return true;
		} else if (cmd.getMarkField().equals(markField.UNMARK)
				&& task.getStatus().equals(Status.UNDONE)) {
			return true;
		} else {
			return false;
		}
	}

	private void removeOverdue(AbstractTask task) {
		if (task instanceof DeadlineTask) {
			DeadlineTask deadlineTask = (DeadlineTask) task;
			deadlineTask.setOverdue(false);
		}
	}

}
```
###### src\logic\action\SaveAction.java
``` java
public class SaveAction extends AbstractAction {
	private Logger logger = SharedLogger.getInstance().getLogger();
	private static final String MESSAGE_SAVEPATH = "\"%1$s\" has been set as new save path!";
	private static final String MESSAGE_SAVEPATH_FAIL = "\"%1$s\" is an invalid save path!";

	private SaveCommand saveCommand;
	private Storage storage;

	public SaveAction(SaveCommand saveCmd, Storage storage) {
		this.saveCommand = saveCmd;
		this.storage = storage;
	}

	public Output execute() {
		boolean isValidPath = storage.changePath(this.saveCommand.getPath());
		if (isValidPath) {
			logger.log(Level.INFO, "Storage path changed successfully");
			return new Output(MESSAGE_SAVEPATH, this.saveCommand.getPath());
		} else {
			Output feedback = new Output(MESSAGE_SAVEPATH_FAIL,
					this.saveCommand.getPath());
			feedback.setPriority(Priority.HIGH);
			logger.log(Level.INFO, "Error in changing storage path!");
			return feedback;
		}
	}

}
```
###### src\logic\action\UIAction.java
``` java
public class UIAction extends AbstractAction {
	private Logger logger = SharedLogger.getInstance().getLogger();
	
	//UIAction has no return message
	public Output execute() {
		logger.log(Level.INFO, "Executing UIAction");
		return new Output(" ");
	}

}
```
###### src\logic\action\UndoAction.java
``` java

/**
 * Undo is implemented by keeping a stack of states of taskList as well as a stack of user 
 * entered commands. 
 * Display, Undo, Save and UI commands cannot be undone
 */

public class UndoAction extends AbstractAction {
	private Logger logger = SharedLogger.getInstance().getLogger();
	private TaskList taskList;
	private Stack<TaskList> taskListStack;
	private Stack<AbstractCommand> cmdHistoryStack;

	public UndoAction(TaskList taskList, Stack<TaskList> taskListStack,
			Stack<AbstractCommand> cmdStack) {
		this.taskList = taskList;
		this.taskListStack = taskListStack;
		this.cmdHistoryStack = cmdStack;
	}

	public Output execute() {
		if (taskListStack.size() == 1) {
			// Bottom of the stack, earliest recorded version for current run of
			// program
			Output feedback = new Output(Constants.MESSAGE_INVALID_COMMAND);
			feedback.setPriority(Priority.HIGH);
			logger.log(Level.INFO, "Reached end of stack, invalid undo!");
			return feedback;
		} else {
			taskListStack.pop();
			this.taskList.replaceContents((taskListStack.peek()).clone());
			AbstractCommand undoneCommand = cmdHistoryStack.pop();
			String undoMessage = undoneCommand.getUndoMessage();
			logger.log(Level.INFO, "Undo successful!");
			return new Output(undoMessage);
		}
	}

}
```
###### src\logic\ExtendedBoolean.java
``` java

public class ExtendedBoolean {
	private boolean state;
	
	public ExtendedBoolean(boolean state) {
		this.state = state;
	}
	
	public void setTrue() {
		this.state = true;
	}
	
	public void setFalse() {
		this.state = false;
	}
	
	public boolean getState() {
		return this.state;
	}
}
```
###### src\logic\Logic.java
``` java

public class Logic implements LogicInterface {

	private TaskList taskList;

	// TaskList storing the tasks last shown in UI
	private TaskList latestDisplayedList = new TaskList();

	// Data structure for Undo Functionality
	private Stack<TaskList> taskListStack = new Stack<TaskList>();
	private Stack<AbstractCommand> cmdHistoryStack = new Stack<AbstractCommand>();
	private DisplayCommand latestDisplayCmd = new DisplayCommand(
			DisplayCommand.Scope.DEFAULT);

	// Variables for complex edit
	private EditCommand latestComplexEdit = new EditCommand(Nature.SIMPLE);
	private ExtendedBoolean shouldKeepComplexEdit = new ExtendedBoolean(false);

	private static Parser parser = new Parser();
	private Storage storage;

	public Logic(Storage storage) {
		this.storage = storage;
		loadFromStorage();
		loadStateForUndo();
	}

	private void loadFromStorage() {
		taskList = new TaskList(this.storage.read());
	}

	private void loadStateForUndo() {
		TaskList clonedList = this.taskList.clone();
		this.taskListStack.push(clonedList);
	}

	/**
	 * MAIN LOGIC The method processInput takes in the user command as a string
	 * from UI and sends it to Parser, which returns an AbstractCommand object.
	 * After checking the type of the command object, a corresponding
	 * AbstractAction object is created and executed using a simplified version
	 * of the command pattern.
	 */

	public Output processInput(String userCmd) {
		AbstractCommand parsedCmd = parser.parseInput(userCmd);
		return executeCommand(parsedCmd);
	}

	public Output executeCommand(AbstractCommand parsedCmd) {
		assert (parsedCmd != null);

		Output feedbackToUI = null;
		AbstractAction action = null;
		prepareForExecution();

		switch (parsedCmd.getCmdType()) {
		case CREATE:
			CreateCommand createCmd = (CreateCommand) parsedCmd;
			action = new CreateAction(createCmd, taskList, latestDisplayedList);
			break;
		case EDIT:
			EditCommand editCmd = (EditCommand) parsedCmd;
			action = new EditAction(editCmd, taskList, latestDisplayedList,
					latestDisplayCmd);
			((EditAction) action).setComplexEdit(latestComplexEdit);
			((EditAction) action).setShouldComplexEdit(shouldKeepComplexEdit);
			break;
		case DELETE:
			DeleteCommand deleteCmd = (DeleteCommand) parsedCmd;
			action = new DeleteAction(deleteCmd, taskList, latestDisplayedList,
					latestDisplayCmd);
			break;
		case MARK:
			MarkCommand markCmd = (MarkCommand) parsedCmd;
			action = new MarkAction(markCmd, taskList, latestDisplayedList,
					latestDisplayCmd);
			break;
		case UNDO:
			action = new UndoAction(taskList, taskListStack, cmdHistoryStack);
			break;
		case UI:
			action = new UIAction();
			break;
		case SAVE:
			SaveCommand saveCmd = (SaveCommand) parsedCmd;
			action = new SaveAction(saveCmd, storage);
			break;
		case DISPLAY:
			DisplayCommand displayCmd = (DisplayCommand) parsedCmd;
			action = new DisplayAction(displayCmd, taskList,
					latestDisplayedList, latestDisplayCmd);
			return action.execute();
		case INVALID:
			Output feedback = new Output(Constants.MESSAGE_INVALID_COMMAND);
			feedback.setPriority(Priority.HIGH);
			return feedback;
		case EXIT:
			System.exit(0);
		}
		feedbackToUI = action.execute();
		postExecutionRoutine(parsedCmd);
		return feedbackToUI;
	}

	/**
	 * BACKGROUND ROUTINES These functions are ran before and after
	 * executeCommand() to facilitate changes to the state of variables such as
	 * taskList, taskListStack, latestDisplayedList, cmdHistoryStack.
	 */

	private void prepareForExecution() {
		checkEditKeywordPreservation();
		updateOverdueStatus();
	}

	private void postExecutionRoutine(AbstractCommand parsedCmd) {
		recordChange(parsedCmd);
		updateOverdueStatus();
		refreshLatestDisplayed();
	}

	private void checkEditKeywordPreservation() {
		if (shouldKeepComplexEdit.getState()) {
			this.cmdHistoryStack.pop();
		} else {
			latestComplexEdit = new EditCommand(Nature.SIMPLE);
		}
		shouldKeepComplexEdit.setFalse();
	}

	// UndoCommand will not be tracked as it is not undo-able!
	// MarkCommands that do not change the state of its targeted tasks are
	// invalid and should not be undo-able too!
	private void recordChange(AbstractCommand parsedCmd) {
		storage.write(this.taskList.getTasks());
		if (!(parsedCmd instanceof UndoCommand) && !isInvalidMark(parsedCmd)) {
			TaskList clonedList = this.taskList.clone();
			this.taskListStack.push(clonedList);
			this.cmdHistoryStack.push(parsedCmd);
		}
	}

	private void refreshLatestDisplayed() {
		DisplayAction action = new DisplayAction(latestDisplayCmd, taskList,
				latestDisplayedList, latestDisplayCmd);
		action.execute();
	}

	private void updateOverdueStatus() {
		for (AbstractTask task : this.taskList.getTasks()) {
			if (task instanceof DeadlineTask) {
				DeadlineTask deadlineTask = (DeadlineTask) task;
				refreshOverdue(deadlineTask);
			}
		}
	}

	private void refreshOverdue(DeadlineTask task) {
		LocalDateTime dateTimeNow = LocalDateTime.now();
		if (dateTimeNow.isAfter(task.getEndDateTime())
				&& task.getStatus().equals(Status.UNDONE)) {
			task.setOverdue(true);
		}
	}

	private boolean isInvalidMark(AbstractCommand cmd) {
		if (cmd instanceof MarkCommand) {
			return ((MarkCommand) cmd).isInvalidMark();
		} else {
			return false;
		}
	}

	/**
	 * LOGIC TEST METHODS These methods are written for testing of the Logic
	 * Component of Flexi-List
	 */

	public TaskList getTaskList() {
		return this.taskList;
	}

	public TaskList getLastDisplayedList() {
		return this.latestDisplayedList;
	}

	/**
	 * UI OBSERVER METHODS These methods will be called by UI to refresh the
	 * program view with the latest display state of Flexi-List
	 */

	public Output getLastDisplayed() {
		return new Output(latestDisplayedList);
	}

	public Output loadDefaultView() {
		latestDisplayCmd = new DisplayCommand(DisplayCommand.Scope.DEFAULT);
		DisplayAction displayAction = new DisplayAction(latestDisplayCmd,
				taskList, latestDisplayedList, latestDisplayCmd);
		return displayAction.execute();
	}

}
```
###### src\logic\LogicInterface.java
``` java

public interface LogicInterface {

	public Output processInput(String command);
	
	public Output getLastDisplayed();
	
	public Output loadDefaultView();
}
```
###### src\logic\StorageStub.java
``` java

// Created for testing independently of Storage class
public class StorageStub extends Storage {
	@Override
	public ArrayList<AbstractTask> read() {
		ArrayList<AbstractTask> mockTaskList = new ArrayList<AbstractTask>();
		return mockTaskList;
	}
	
	@Override 
	public void write(ArrayList<AbstractTask> taskList) {
		return;
	}
}
```
###### src\logic\TaskList.java
``` java

/**
 * TaskList is an augmented ArrayList object created by the Logic Component to handle all its 
 * required list manipulation. It has the basic functionalities of ArrayList in Java API and many
 * filter methods customized for Flexi-List operations.
 */

public class TaskList {

	private ArrayList<AbstractTask> tasks;

	public TaskList() {
		this.tasks = new ArrayList<AbstractTask>();
	}

	public TaskList(ArrayList<AbstractTask> tasks) {
		this.tasks = tasks;
	}

	public void addTask(AbstractTask task) {
		assert task != null;
		this.tasks.add(task);
	}

	public void addTask(int index, AbstractTask task) {
		assert index > -1 && index < tasks.size();
		assert task != null;
		this.tasks.add(index, task);
	}

	public void addAll(TaskList taskList) {
		this.tasks.addAll(taskList.getTasks());
	}

	public AbstractTask getTask(int index) {
		assert index > -1 && index < tasks.size();
		return this.tasks.get(index);
	}

	public ArrayList<AbstractTask> getTasks() {
		assert this.tasks != null;
		return this.tasks;
	}

	public int indexOf(AbstractTask task) {
		assert task != null;
		return this.tasks.indexOf(task);
	}

	public void removeTask(AbstractTask task) {
		assert task != null;
		this.tasks.remove(task);
	}

	public void clear() {
		this.tasks.clear();
	}
	
	// Replaces current contents with the supplied TaskList.
	public void replaceContents(TaskList newContents) {
		this.tasks = newContents.getTasks();
	}

	@Override
	public TaskList clone() {
		TaskList clonedList = new TaskList();
		for (AbstractTask task : this.tasks) {
			clonedList.addTask(task.clone());
		}
		return clonedList;
	}

	public TaskList subList(int indexStart, int indexEnd) {
		assert indexStart <= indexEnd;
		List<AbstractTask> subList = this.tasks.subList(indexStart, indexEnd);
		ArrayList<AbstractTask> arraySubList = new ArrayList<AbstractTask>(
				subList);
		return new TaskList(arraySubList);
	}

	public void removeDuplicates() {
		ArrayList<AbstractTask> filteredTaskList = new ArrayList<AbstractTask>();
		for (AbstractTask task : this.tasks) {
			if (!filteredTaskList.contains(task)) {
				filteredTaskList.add(task);
			}
		}
		this.tasks = filteredTaskList;
	}

	public int size() {
		return this.tasks.size();
	}

	/**
	 * FILTER FUNCTIONS
	 * This is the main bulk of TaskList's extensive filter functionality.
	 */

	public TaskList getDateSortedClone() {
		TaskList clonedList = this.clone();
		Collections.sort(clonedList.getTasks());
		return clonedList;
	}

	public TaskList filterByNames(ArrayList<String> keywords) {
		TaskList masterFilteredList = new TaskList();
		for (int i = 0; i < keywords.size(); i++) {
			TaskList singleFilteredList = filterByName(keywords.get(i));
			masterFilteredList.addAll(singleFilteredList);
		}
		masterFilteredList.removeDuplicates();
		return masterFilteredList;
	}

	public TaskList filterByName(String keyword) {
		assert keyword != null;
		TaskList singleFilteredList = new TaskList();
		for (AbstractTask task : this.tasks) {
			if (task.getName().toLowerCase().contains(keyword.toLowerCase())) {
				singleFilteredList.addTask(task);
			}
		}
		return singleFilteredList;
	}

	public TaskList filterByDate(LocalDate queryDate) {
		TaskList filteredList = new TaskList();
		for (AbstractTask task : this.tasks) {
			if (task instanceof DeadlineTask
					&& isSameDate((DeadlineTask) task, queryDate)) {
				filteredList.addTask(task);
			} else if (task instanceof BoundedTask
					&& isSameDate((BoundedTask) task, queryDate)) {
				filteredList.addTask(task);
			}
		}
		return filteredList;
	}

	public TaskList filterInclusiveAfterDate(LocalDate queryDate) {
		TaskList sortedMasterList = this.getDateSortedClone();
		TaskList filteredList = new TaskList();
		for (AbstractTask task : sortedMasterList.getTasks()) {
			if (task instanceof DeadlineTask
					&& isInclusiveAfterDate((DeadlineTask) task, queryDate)) {
				filteredList.addTask(task);
			} else if (task instanceof BoundedTask
					&& isInclusiveAfterDate((BoundedTask) task, queryDate)) {
				filteredList.addTask(task);
			}
		}
		return filteredList;
	}

	public TaskList filterByStatus(Status status) {
		assert status != null;
		TaskList filteredList = new TaskList();
		for (AbstractTask task : this.tasks) {
			if (task.getStatus().equals(status)) {
				filteredList.addTask(task);
			}
		}
		return filteredList;
	}
	
	public TaskList filterByOverdue(boolean state) {
		TaskList filteredList = new TaskList();
		for (AbstractTask task : this.tasks) {
			if (task instanceof DeadlineTask) {
				DeadlineTask deadlineTask = (DeadlineTask) task;
				if (deadlineTask.isOverdue() == state) {
					filteredList.addTask(deadlineTask);
				}
			} else if (state == false) {
				filteredList.addTask(task);
			}
		}
		return filteredList;
	}
	
	public TaskList filterForFloating() {
		TaskList filteredList = new TaskList();
		for (AbstractTask task : this.tasks) {
			if (task instanceof FloatingTask) {
				filteredList.addTask(task);
			}
		}
		return filteredList;
	}

	private boolean isSameDate(DeadlineTask task, LocalDate queryDate) {
		return Objects.equals(task.getEndDateTime().toLocalDate(), queryDate);
	}

	private boolean isSameDate(BoundedTask task, LocalDate queryDate) {
		boolean startDateCheck = Objects.equals(task.getStartDateTime()
				.toLocalDate(), queryDate);
		boolean endDateCheck = Objects.equals(task.getEndDateTime()
				.toLocalDate(), queryDate);
		return startDateCheck || endDateCheck;
	}

	private boolean isInclusiveAfterDate(DeadlineTask task, LocalDate queryDate) {
		return task.getEndDateTime().toLocalDate().isAfter(queryDate)
				|| isSameDate(task, queryDate);
	}

	private boolean isInclusiveAfterDate(BoundedTask task, LocalDate queryDate) {
		return task.getStartDateTime().toLocalDate().isAfter(queryDate)
				|| isSameDate(task, queryDate);
	}

	@Override
	public boolean equals(Object obj) {
		if (!(obj instanceof TaskList)) {
			return false;
		} else {
			TaskList that = (TaskList) obj;
			return Objects.equals(this.getTasks(), that.getTasks());
		}
	}
}
```
###### src\shared\command\AbstractCommand.java
``` java
public abstract class AbstractCommand {
	public static enum CmdType {
		CREATE, EDIT, DISPLAY, DELETE, INVALID, EXIT, MARK, SAVE, UI, UNDO
	}

	public abstract CmdType getCmdType();

	public abstract String getUndoMessage();
}
```
###### src\shared\command\CreateCommand.java
``` java
public class CreateCommand extends AbstractCommand {

	private Type taskType;
	private String taskName;
	private LocalDateTime startDateTime;
	private LocalDateTime endDateTime;
	private String undoMessage = "\"create\" action has been undone!";

	public static enum Type {
		FLOATING, DEADLINE, BOUNDED;
	}

	public CreateCommand(String taskName) {
		this.taskType = Type.FLOATING;
		this.taskName = taskName;
	}

	public CreateCommand(String taskName, LocalDateTime endDateTime) {
		this.taskType = Type.DEADLINE;
		this.taskName = taskName;
		this.endDateTime = endDateTime;
	}

	public CreateCommand(String taskName, LocalDateTime startDateTime,
			LocalDateTime endDateTime) {
		this.taskType = Type.BOUNDED;
		this.taskName = taskName;
		this.startDateTime = startDateTime;
		this.endDateTime = endDateTime;

	}

	public Type getTaskType() {
		return this.taskType;
	}

	public String getTaskName() {
		return this.taskName;
	}

	public LocalDateTime getStartDateTime() {
		return this.startDateTime;
	}

	public LocalDateTime getEndDateTime() {
		return this.endDateTime;
	}

	public String getUndoMessage() {
		return undoMessage;
	}

	public CmdType getCmdType() {
		return CmdType.CREATE;
	}

	@Override
	public boolean equals(Object obj) {
		if (!(obj instanceof CreateCommand)) {
			return false;
		} else {
			CreateCommand that = (CreateCommand) obj;
			return Objects.equals(this.getTaskType(), that.getTaskType())
					&& Objects.equals(this.getTaskName(), that.getTaskName())
					&& Objects.equals(this.getStartDateTime(),
							that.getStartDateTime())
					&& Objects.equals(this.getEndDateTime(),
							that.getEndDateTime());
		}
	}
}
```
###### src\shared\command\DeleteCommand.java
``` java
public class DeleteCommand extends AbstractCommand {

	private Type type;
	private int index;
	private String searchKeyword;
	private Scope scope;
	private String undoMessage = "\"delete\" action has been undone!";

	public static enum Scope {
		ALL;
	}

	public static enum Type {
		INDEX, SEARCHKEYWORD, SCOPE;
	}

	public DeleteCommand(int index) {
		this.type = Type.INDEX;
		this.index = index;
	}

	public DeleteCommand(String searchKeyword) {
		this.type = Type.SEARCHKEYWORD;
		this.searchKeyword = searchKeyword;
	}

	public DeleteCommand(Scope scope) {
		this.type = Type.SCOPE;
		this.scope = scope;
	}

	public Type getType() {
		return this.type;
	}

	public int getIndex() {
		return this.index;
	}

	public String getSearchKeyword() {
		return this.searchKeyword;
	}

	public Scope getScope() {
		return this.scope;
	}

	public String getUndoMessage() {
		return undoMessage;
	}

	public CmdType getCmdType() {
		return CmdType.DELETE;
	}

	@Override
	public boolean equals(Object obj) {
		if (!(obj instanceof DeleteCommand)) {
			return false;
		} else {
			DeleteCommand that = (DeleteCommand) obj;
			return this.getType().equals(that.getType())
					&& this.getIndex() == that.getIndex()
					&& Objects.equals(this.getSearchKeyword(),
							that.getSearchKeyword())
					&& Objects.equals(this.getScope(), that.getScope());
		}
	}

}
```
###### src\shared\command\DisplayCommand.java
``` java
public class DisplayCommand extends AbstractCommand {

	private Type type;
	private ArrayList<String> searchKeyword;
	private LocalDateTime searchDate;
	private Scope scope;
	private String undoMessage = "\"display\" action cannot be undone!";

	public static enum Scope {
		ALL, DONE, UNDONE, DEFAULT, FLOATING;
	}

	public static enum Type {
		SEARCHKEY, SEARCHDATE, SCOPE;
	}

	public DisplayCommand(ArrayList<String> searchKeyword) {
		this.type = Type.SEARCHKEY;
		this.searchKeyword = searchKeyword;
	}

	public DisplayCommand(LocalDateTime searchDate) {
		this.type = Type.SEARCHDATE;
		this.searchDate = searchDate;
	}

	public DisplayCommand(Scope scope) {
		this.type = Type.SCOPE;
		this.scope = scope;
	}

	public Type getType() {
		return this.type;
	}

	public ArrayList<String> getSearchKeyword() {
		return this.searchKeyword;
	}

	public LocalDateTime getSearchDate() {
		return this.searchDate;
	}

	public Scope getScope() {
		return this.scope;
	}

	public String getUndoMessage() {
		return undoMessage;
	}

	public CmdType getCmdType() {
		return CmdType.DISPLAY;
	}

	public void replaceCmd(DisplayCommand newCmd) {
		if (newCmd.getType() == Type.SEARCHKEY) {
			this.type = Type.SEARCHKEY;
			this.searchKeyword = newCmd.getSearchKeyword();
		} else if (newCmd.getType() == Type.SEARCHDATE) {
			this.type = Type.SEARCHDATE;
			this.searchDate = newCmd.getSearchDate();
		} else if (newCmd.getType() == Type.SCOPE) {
			this.type = Type.SCOPE;
			this.scope = newCmd.getScope();
		}
	}

	@Override
	public boolean equals(Object obj) {
		if (!(obj instanceof DisplayCommand)) {
			return false;
		} else {
			DisplayCommand that = (DisplayCommand) obj;
			return this.getType().equals(that.getType())
					&& Objects.equals(this.getSearchKeyword(),
							that.getSearchKeyword())
					&& Objects.equals(this.getSearchDate(),
							that.getSearchDate())
					&& Objects.equals(this.getScope(), that.getScope());
		}
	}

}
```
###### src\shared\command\EditCommand.java
``` java
public class EditCommand extends AbstractCommand {

	private ArrayList<editField> editFields;
	private Type type;
	private Nature nature;

	private int index;
	private String searchKeyword;

	private String newName;
	private String newStartTime;
	private String newStartDate;
	private String newEndTime;
	private String newEndDate;
	private String undoMessage = "\"edit\" action has been undone!";

	public static enum editField {
		NAME, START_DATE, START_TIME, END_DATE, END_TIME;
	}

	public static enum Type {
		INDEX, SEARCHKEYWORD;
	}

	public static enum Nature {
		SIMPLE, COMPLEX;
	}

	public EditCommand(Nature nature) {
		this.nature = nature;
	}

	public EditCommand(int index) {
		this.type = Type.INDEX;
		this.index = index;
		this.nature = Nature.SIMPLE;
	}

	public EditCommand(String searchKeyword) {
		this.type = Type.SEARCHKEYWORD;
		this.searchKeyword = searchKeyword;
		this.nature = Nature.SIMPLE;
	}

	public ArrayList<editField> getEditFields() {
		return this.editFields;
	}

	public void setEditFields(ArrayList<editField> editFields) {
		this.editFields = editFields;
	}

	public Type getType() {
		return this.type;
	}

	public int getIndex() {
		return this.index;
	}

	public String getSearchKeyword() {
		return this.searchKeyword;
	}

	public String getNewName() {
		return this.newName;
	}

	public void setNewName(String newName) {
		this.newName = newName;
	}

	public String getNewStartTime() {
		return this.newStartTime;
	}

	public void setNewStartTime(String newStartTime) {
		this.newStartTime = newStartTime;
	}

	public String getNewStartDate() {
		return this.newStartDate;
	}

	public void setNewStartDate(String newStartDate) {
		this.newStartDate = newStartDate;
	}

	public String getNewEndTime() {
		return this.newEndTime;
	}

	public void setNewEndTime(String newEndTime) {
		this.newEndTime = newEndTime;
	}

	public String getNewEndDate() {
		return this.newEndDate;
	}

	public void setNewEndDate(String newEndDate) {
		this.newEndDate = newEndDate;
	}

	public Nature getNature() {
		return this.nature;
	}

	public void setNature(Nature nature) {
		this.nature = nature;
	}

	public void replaceCmd(EditCommand newCmd) {
		this.nature = newCmd.getNature();
		this.editFields = newCmd.getEditFields();
		if (newCmd.getType() == Type.INDEX) {
			this.type = Type.INDEX;
		} else if (newCmd.getType() == Type.SEARCHKEYWORD) {
			this.type = Type.SEARCHKEYWORD;
		}

		if (editFields.contains(editField.NAME)) {
			this.newName = newCmd.getNewName();
		} else if (editFields.contains(editField.START_DATE)) {
			this.newStartDate = newCmd.getNewStartDate();
		} else if (editFields.contains(editField.START_TIME)) {
			this.newStartTime = newCmd.getNewStartTime();
		} else if (editFields.contains(editField.END_DATE)) {
			this.newEndDate = newCmd.getNewEndDate();
		} else if (editFields.contains(editField.END_TIME)) {
			this.newEndTime = newCmd.getNewEndTime();
		}
	}

	public String getUndoMessage() {
		return undoMessage;
	}

	public CmdType getCmdType() {
		return CmdType.EDIT;
	}

	@Override
	public boolean equals(Object obj) {
		if (!(obj instanceof EditCommand)) {
			return false;
		} else {
			EditCommand that = (EditCommand) obj;
			return this.getEditFields().equals(that.getEditFields())
					&& this.getType().equals(that.getType())
					&& this.getIndex() == that.getIndex()
					&& Objects.equals(this.getNewEndDate(),
							that.getNewEndDate())
					&& Objects.equals(this.getNewEndTime(),
							that.getNewEndTime())
					&& Objects.equals(this.getNewName(), that.getNewName())
					&& Objects.equals(this.getNewStartDate(),
							that.getNewStartDate())
					&& Objects.equals(this.getNewStartTime(),
							that.getNewStartTime())
					&& Objects.equals(this.getSearchKeyword(),
							that.getSearchKeyword());
		}
	}
}
```
###### src\shared\Constants.java
``` java
	//Logic constants
	public static final String MESSAGE_INVALID_COMMAND = "Invalid Command!";
	public static final String MESSAGE_INVALID_KEYWORD = "No task with keyword \"%1$s\" has been found.";
	public static final String MESSAGE_INVALID_INDEX = "Invalid: There is no task with the given index.";
	public static final int MESSAGE_LENGTH = 72;
	//Logic constants ends
	
}
```
###### src\shared\task\AbstractTask.java
``` java
public abstract class AbstractTask implements Comparable<AbstractTask>{

	private String taskName;
	private Status status;
	protected DateTimeFormatter DTFormatter = DateTimeFormatter.ofPattern("dd MM yyyy HH mm");
	
	public static enum Status {
		UNDONE, DONE;
	}
	
	public AbstractTask(String name) {
		taskName = name;
		status = Status.UNDONE;
	}
	
	public String getName() {
		return taskName;
	}
	
	public Status getStatus() {
		return status;
	}
	
	public void setName(String name) {
		taskName = name;
	}
	
	public void setStatus(Status newStatus) {
		status = newStatus;
	}

	// Ensures that output is always 2 digit long. eg. 9--> 09
	protected String padWithZero(int number) {
		return String.format("%02d", number);
	}	
	
	public abstract ArrayList<String> toArray();
	
	public abstract AbstractTask clone();

}
```
###### src\shared\task\BoundedTask.java
``` java
public class BoundedTask extends AbstractTask {

	private LocalDateTime startDateTime;
	private LocalDateTime endDateTime;

	public BoundedTask(String name, LocalDateTime startDateTime,
			LocalDateTime endDateTime) throws IllegalArgumentException {
		super(name);
		if (endDateTime.isBefore(startDateTime)) {
			throw new IllegalArgumentException(
					"Invalid: Start date time must be before End date time!");
		} else {
			this.startDateTime = startDateTime;
			this.endDateTime = endDateTime;
		}
	}

	public String getStartDate() {
		String startDate = padWithZero(startDateTime.getDayOfMonth()) + "-"
				+ padWithZero(startDateTime.getMonthValue()) + "-"
				+ startDateTime.getYear();
		return startDate;
	}

	public String getStartTime() {
		return startDateTime.toLocalTime().toString();
	}

	public String getFriendlyStartTime() {
		String[] timeParts = this.getStartTime().split(":");
		int hourValue = Integer.parseInt(timeParts[0]);
		String timePeriod = "am";
		if (hourValue == 12) {
			timePeriod = "pm";
		} else if (hourValue > 12) {
			hourValue -= 12;
			timePeriod = "pm";
		} else if (hourValue == 0) {
			hourValue = 12;
		}

		if (timeParts[1].equals("00")) {
			return String.valueOf(hourValue) + timePeriod;
		} else {
			return String.valueOf(hourValue) + ":" + timeParts[1] + timePeriod;
		}
	}

	public LocalDateTime getStartDateTime() {
		return startDateTime;
	}

	public String getEndDate() {
		String endDate = padWithZero(endDateTime.getDayOfMonth()) + "-"
				+ padWithZero(endDateTime.getMonthValue()) + "-"
				+ endDateTime.getYear();
		return endDate;
	}

	public String getEndTime() {
		return endDateTime.toLocalTime().toString();
	}

	public String getFriendlyEndTime() {
		String[] timeParts = this.getEndTime().split(":");
		int hourValue = Integer.parseInt(timeParts[0]);
		String timePeriod = "am";
		if (hourValue == 12) {
			timePeriod = "pm";
		} else if (hourValue > 12) {
			hourValue -= 12;
			timePeriod = "pm";
		} else if (hourValue == 0) {
			hourValue = 12;
		}

		if (timeParts[1].equals("00")) {
			return String.valueOf(hourValue) + timePeriod;
		} else {
			return String.valueOf(hourValue) + ":" + timeParts[1] + timePeriod;
		}
	}

	public LocalDateTime getEndDateTime() {
		return endDateTime;
	}

	public void setStartDate(String newStartDate)
			throws IllegalArgumentException {
		String oldStartTime = padWithZero(startDateTime.getHour()) + " "
				+ padWithZero(startDateTime.getMinute());
		LocalDateTime newStart = LocalDateTime.parse(newStartDate + " "
				+ oldStartTime, DTFormatter);
		if (newStart.isAfter(this.endDateTime)) {
			throw new IllegalArgumentException(
					"Invalid: Start date time must be before End date time!");
		} else {
			this.startDateTime = newStart;
		}
	}

	public void setStartTime(String newStartTime)
			throws IllegalArgumentException {
		String oldStartDate = padWithZero(startDateTime.getDayOfMonth()) + " "
				+ padWithZero(startDateTime.getMonthValue()) + " "
				+ startDateTime.getYear();
		LocalDateTime newStart = LocalDateTime.parse(oldStartDate + " "
				+ newStartTime, DTFormatter);
		if (newStart.isAfter(this.endDateTime)) {
			throw new IllegalArgumentException(
					"Invalid: Start date time must be before End date time!");
		} else {
			this.startDateTime = newStart;
		}
	}

	public void setEndDate(String newEndDate) throws IllegalArgumentException {
		String oldEndTime = padWithZero(endDateTime.getHour()) + " "
				+ padWithZero(endDateTime.getMinute());
		LocalDateTime newEnd = LocalDateTime.parse(newEndDate + " "
				+ oldEndTime, DTFormatter);
		if (newEnd.isBefore(this.startDateTime)) {
			throw new IllegalArgumentException(
					"Invalid: Start date time must be before End date time!");
		}
		this.endDateTime = newEnd;
	}

	public void setEndTime(String newEndTime) throws IllegalArgumentException {
		String oldEndDate = padWithZero(endDateTime.getDayOfMonth()) + " "
				+ padWithZero(endDateTime.getMonthValue()) + " "
				+ endDateTime.getYear();
		LocalDateTime newEnd = LocalDateTime.parse(oldEndDate + " "
				+ newEndTime, DTFormatter);
		if (newEnd.isBefore(this.startDateTime)) {
			throw new IllegalArgumentException(
					"Invalid: Start date time must be before End date time!");
		}
		this.endDateTime = newEnd;
	}

	public String toString() {
		return this.getStatus().toString() + "`" + this.getName() + "`"
				+ String.format("%02d", startDateTime.getDayOfMonth()) + " "
				+ String.format("%02d", startDateTime.getMonthValue()) + " "
				+ startDateTime.getYear() + " "
				+ String.format("%02d", startDateTime.getHour()) + " "
				+ String.format("%02d", startDateTime.getMinute()) + "`"
				+ String.format("%02d", endDateTime.getDayOfMonth()) + " "
				+ String.format("%02d", endDateTime.getMonthValue()) + " "
				+ endDateTime.getYear() + " "
				+ String.format("%02d", endDateTime.getHour()) + " "
				+ String.format("%02d", endDateTime.getMinute());
	}

	public ArrayList<String> toArray() {
		LocalDate today = LocalDate.now();

		ArrayList<String> array = new ArrayList<String>();
		array.add(getName());
		array.add(getFriendlyStartTime());
		array.add((startDateTime.getDayOfWeek().toString()).substring(0, 3));

		if (startDateTime.toLocalDate().equals(today)) {
			array.add("TODAY");
			array.add("");
			array.add("");
		} else {
			array.add(String.valueOf(startDateTime.getDayOfMonth()));
			array.add((startDateTime.getMonth().toString()).substring(0, 3));
			array.add(String.valueOf(startDateTime.getYear()));
		}

		array.add(getFriendlyEndTime());
		array.add((endDateTime.getDayOfWeek().toString()).substring(0, 3));

		if (endDateTime.toLocalDate().equals(today)) {
			array.add("TODAY");
			array.add("");
			array.add("");
		} else {
			array.add(String.valueOf(endDateTime.getDayOfMonth()));
			array.add((endDateTime.getMonth().toString()).substring(0, 3));
			array.add(String.valueOf(endDateTime.getYear()));
		}

		array.add((this.getStatus()).toString());
		array.add("");

		return array;
	}

	@Override
	public int compareTo(AbstractTask task) {
		if (task instanceof FloatingTask) {
			return -1;
		} else if (task instanceof DeadlineTask) {
			return this.getStartDateTime().compareTo(
					((DeadlineTask) task).getEndDateTime());
		} else {
			return this.getStartDateTime().compareTo(
					((BoundedTask) task).getStartDateTime());
		}
	}

	@Override
	public boolean equals(Object obj) {
		if (!(obj instanceof BoundedTask)) {
			return false;
		} else {
			BoundedTask that = (BoundedTask) obj;
			return Objects.equals(this.getName(), that.getName())
					&& Objects.equals(this.getStatus(), that.getStatus())
					&& Objects.equals(this.getStartDate(), that.getStartDate())
					&& Objects.equals(this.getStartTime(), that.getStartTime())
					&& Objects.equals(this.getEndDate(), that.getEndDate())
					&& Objects.equals(this.getEndTime(), that.getEndTime());
		}
	}

	@Override
	public AbstractTask clone() {
		BoundedTask newTask = new BoundedTask(this.getName(),
				this.startDateTime, this.endDateTime);
		newTask.setStatus(this.getStatus());
		return newTask;
	}
}
```
###### src\shared\task\DeadlineTask.java
``` java
public class DeadlineTask extends AbstractTask {

	private LocalDateTime endDateTime;

	private boolean isOverdue = false;

	public DeadlineTask(String name, LocalDateTime endDateTime) {
		super(name);
		this.endDateTime = endDateTime;
	}

	public String getEndDate() {
		String endDate = padWithZero(endDateTime.getDayOfMonth()) + "-"
				+ padWithZero(endDateTime.getMonthValue()) + "-"
				+ endDateTime.getYear();
		return endDate;
	}

	public String getEndTime() {
		return endDateTime.toLocalTime().toString();
	}

	public LocalDateTime getEndDateTime() {
		return endDateTime;
	}

	public void setEndDate(String newEndDate) {
		String oldEndTime = padWithZero(endDateTime.getHour()) + " "
				+ padWithZero(endDateTime.getMinute());
		endDateTime = LocalDateTime.parse(newEndDate + " " + oldEndTime,
				DTFormatter);
	}

	public void setEndTime(String newEndTime) {
		String oldEndDate = padWithZero(endDateTime.getDayOfMonth()) + " "
				+ padWithZero(endDateTime.getMonthValue()) + " "
				+ endDateTime.getYear();
		endDateTime = LocalDateTime.parse(oldEndDate + " " + newEndTime,
				DTFormatter);
	}

	public String getFriendlyEndTime() {
		String[] timeParts = this.getEndTime().split(":");
		int hourValue = Integer.parseInt(timeParts[0]);
		String timePeriod = "am";

		if (hourValue == 12) {
			timePeriod = "pm";
		} else if (hourValue > 12) {
			hourValue -= 12;
			timePeriod = "pm";
		} else if (hourValue == 0) {
			hourValue = 12;
		}

		if (timeParts[1].equals("00")) {
			return String.valueOf(hourValue) + timePeriod;
		} else {
			return String.valueOf(hourValue) + ":" + timeParts[1] + timePeriod;
		}
	}

	public boolean isOverdue() {
		return this.isOverdue;
	}

	public void setOverdue(boolean state) {
		this.isOverdue = state;
	}

	public String toString() {
		return this.getStatus().toString() + "`" + this.getName() + "`"
				+ String.format("%02d", endDateTime.getDayOfMonth()) + " "
				+ String.format("%02d", endDateTime.getMonthValue()) + " "
				+ endDateTime.getYear() + " "
				+ String.format("%02d", endDateTime.getHour()) + " "
				+ String.format("%02d", endDateTime.getMinute());

	}

	public ArrayList<String> toArray() {
		LocalDate today = LocalDate.now();

		ArrayList<String> array = new ArrayList<String>();
		array.add(getName());
		array.add("");
		array.add("");
		array.add("");
		array.add("");
		array.add("");

		array.add(getFriendlyEndTime());
		array.add((endDateTime.getDayOfWeek().toString()).substring(0, 3));

		if (endDateTime.toLocalDate().equals(today)) {
			array.add("TODAY");
			array.add("");
			array.add("");
		} else {
			array.add(String.valueOf(endDateTime.getDayOfMonth()));
			array.add((endDateTime.getMonth().toString()).substring(0, 3));
			array.add(String.valueOf(endDateTime.getYear()));
		}

		array.add((this.getStatus()).toString());
		array.add(String.valueOf(isOverdue));

		return array;
	}

	@Override
	public int compareTo(AbstractTask task) {
		if (task instanceof FloatingTask) {
			return -1;
		} else if (task instanceof DeadlineTask) {
			return this.getEndDateTime().compareTo(
					((DeadlineTask) task).getEndDateTime());
		} else {
			return this.getEndDateTime().compareTo(
					((BoundedTask) task).getStartDateTime());
		}
	}

	@Override
	public boolean equals(Object obj) {
		if (!(obj instanceof DeadlineTask)) {
			return false;
		} else {
			DeadlineTask that = (DeadlineTask) obj;
			return Objects.equals(this.getName(), that.getName())
					&& Objects.equals(this.getStatus(), that.getStatus())
					&& Objects.equals(this.getEndDate(), that.getEndDate())
					&& Objects.equals(this.getEndTime(), that.getEndTime());
		}
	}

	@Override
	public AbstractTask clone() {
		DeadlineTask newTask = new DeadlineTask(this.getName(),
				this.endDateTime);
		newTask.setStatus(this.getStatus());
		newTask.setOverdue(isOverdue);
		return newTask;
	}
}
```
###### src\shared\task\FloatingTask.java
``` java
public class FloatingTask extends AbstractTask {

	public FloatingTask(String name) {
		super(name);
	}

	public String toString() {
		return this.getStatus().toString() + "`" + this.getName();
	}

	public ArrayList<String> toArray() {
		ArrayList<String> returnArray = new ArrayList<String>();
		returnArray.add(getName());
		returnArray.add("");
		returnArray.add("");
		returnArray.add("");
		returnArray.add("");
		returnArray.add("");
		returnArray.add("");
		returnArray.add("");
		returnArray.add("");
		returnArray.add("");
		returnArray.add("");
		returnArray.add((this.getStatus()).toString());
		returnArray.add("");

		return returnArray;
	}

	@Override
	public int compareTo(AbstractTask task) {
		if (task instanceof FloatingTask) {
			return 0;
		} else {
			return 1;
		}
	}

	@Override
	public boolean equals(Object obj) {
		if (!(obj instanceof FloatingTask)) {
			return false;
		} else {
			FloatingTask that = (FloatingTask) obj;

			return Objects.equals(this.getName(), that.getName())
					&& Objects.equals(this.getStatus(), that.getStatus());
		}
	}

	@Override
	public AbstractTask clone() {
		FloatingTask newTask = new FloatingTask(this.getName());
		newTask.setStatus(this.getStatus());
		return newTask;
	}
}
```
###### src\shared\task\TaskTest.java
``` java

/**
 * TEST FOR TASK CLASSES These tests check if the 3 task classes are exported in
 * the correct format when they are converted to either an ArrayList<String> or
 * just a String
 */

public class TaskTest {
	DateTimeFormatter DTFormatter = DateTimeFormatter
			.ofPattern("dd MM yyyy HH mm");

	private ArrayList<String> arrayToArrayList(String[] stringArray) {
		ArrayList<String> arrayListToReturn = new ArrayList<String>();
		for (int i = 0; i < stringArray.length; i++) {
			arrayListToReturn.add(stringArray[i]);
		}
		return arrayListToReturn;
	}

	@Test
	public void toArrayFloating() {
		FloatingTask task = new FloatingTask("hello");
		String[] floatingTask = { "hello", "", "", "", "", "", "", "", "", "",
				"", "UNDONE", "" };
		ArrayList<String> expectedArray = arrayToArrayList(floatingTask);

		assertEquals(expectedArray, task.toArray());
	}

	@Test
	public void toArrayDeadline() {
		LocalDateTime myEnd = LocalDateTime.parse("13 10 2015 20 00",
				DTFormatter);
		DeadlineTask task = new DeadlineTask("hello", myEnd);
		String[] deadlineTask = { "hello", "", "", "", "", "", "8pm", "TUE",
				"13", "OCT", "2015", "UNDONE", "false" };
		ArrayList<String> expectedArray = arrayToArrayList(deadlineTask);

		assertEquals(expectedArray, task.toArray());
	}

	@Test
	public void toArrayBounded() {
		LocalDateTime myStart = LocalDateTime.parse("12 10 2015 00 00",
				DTFormatter);
		LocalDateTime myEnd = LocalDateTime.parse("13 10 2015 20 00",
				DTFormatter);
		BoundedTask task = new BoundedTask("hello", myStart, myEnd);
		String[] boundedTask = { "hello", "12am", "MON", "12", "OCT", "2015",
				"8pm", "TUE", "13", "OCT", "2015", "UNDONE", "" };
		ArrayList<String> expectedArray = arrayToArrayList(boundedTask);

		assertEquals(expectedArray, task.toArray());
	}

	@Test
	public void toStringFloating() {
		FloatingTask floatingTask = new FloatingTask("assignment");
		String output = floatingTask.toString();
		String expected = "UNDONE`assignment";
		assertEquals(expected, output);
	}

	@Test
	public void toStringDeadline() {
		LocalDateTime myEnd = LocalDateTime.parse("13 10 2015 20 00",
				DTFormatter);
		DeadlineTask deadlineTask = new DeadlineTask("assignment for biology",
				myEnd);
		String output = deadlineTask.toString();
		String expected = "UNDONE`assignment for biology`13 10 2015 20 00";
		assertEquals(expected, output);
	}

	@Test
	public void toStringBounded() {
		LocalDateTime myStart = LocalDateTime.parse("12 10 2015 00 00",
				DTFormatter);
		LocalDateTime myEnd = LocalDateTime.parse("13 10 2015 20 00",
				DTFormatter);
		BoundedTask boundedTask = new BoundedTask("hello", myStart, myEnd);
		String output = boundedTask.toString();
		String expected = "UNDONE`hello`12 10 2015 00 00`13 10 2015 20 00";
		assertEquals(expected, output);
	}

}
```
###### src\test\LogicTest.java
``` java
public class LogicTest {
	private StorageStub storageStub = new StorageStub();
	private Logic logic = new Logic(storageStub);
	DateTimeFormatter DTFormatter = DateTimeFormatter
			.ofPattern("dd MM yyyy HH mm");
	LocalDateTime dummyStart = LocalDateTime.parse("12 10 2015 08 00",
			DTFormatter);
	LocalDateTime dummyEnd = LocalDateTime.parse("13 10 2015 08 00",
			DTFormatter);

	CreateCommand createFloating = new CreateCommand("birthday");
	CreateCommand createDeadline = new CreateCommand("assignment", dummyEnd);
	CreateCommand createBounded = new CreateCommand("dinner", dummyStart,
			dummyEnd);
	DisplayCommand displayAll = new DisplayCommand(DisplayCommand.Scope.ALL);

	private ArrayList<String> arrayToArrayList(String[] stringArray) {
		ArrayList<String> arrayListToReturn = new ArrayList<String>();
		for (int i = 0; i < stringArray.length; i++) {
			arrayListToReturn.add(stringArray[i]);
		}
		return arrayListToReturn;
	}
	
	/**
	 * CREATEACTION TESTS
	 */
	
	@Test
	public void createFloatingTask() {
		Output output = logic.executeCommand(createFloating);
		Output expected = new Output();
		expected.setReturnMessage("\"birthday\" has been created!");
		assertEquals(expected, output);

		FloatingTask expectedTask = new FloatingTask("birthday");
		AbstractTask createdTask = (logic.getTaskList()).getTask(0);
		assertEquals(expectedTask, createdTask);
	}

	@Test
	public void createDeadlineTask() {
		Output output = logic.executeCommand(createDeadline);
		Output expected = new Output();
		expected.setReturnMessage("\"assignment\" has been created!");
		assertEquals(expected, output);

		DeadlineTask expectedTask = new DeadlineTask("assignment", dummyEnd);
		AbstractTask createdTask = (logic.getTaskList()).getTask(0);
		assertEquals(expectedTask, createdTask);
	}

	@Test
	public void createBoundedTask() {
		Output output = logic.executeCommand(createBounded);
		Output expected = new Output();
		expected.setReturnMessage("\"dinner\" has been created!");
		assertEquals(expected, output);

		BoundedTask expectedTask = new BoundedTask("dinner", dummyStart,
				dummyEnd);
		AbstractTask createdTask = (logic.getTaskList()).getTask(0);
		assertEquals(expectedTask, createdTask);
	}

	@Test
	public void createBoundedTaskWithWrongDateOrder() {
		CreateCommand createWrongBounded = new CreateCommand("dinner",
				dummyEnd, dummyStart);
		Output output = logic.executeCommand(createWrongBounded);
		Output expected = new Output();
		expected.setReturnMessage("Invalid: Start date time must be before End date time!");
		expected.setPriority(Priority.HIGH);
		assertEquals(expected, output);

		int expectedTaskListSize = 0;
		int actualTaskListSize = (logic.getTaskList()).size();
		assertEquals(expectedTaskListSize, actualTaskListSize);
	}

	/**
	 * DISPLAYACTION TESTS
	 */
	
	@Test
	public void displayAllTasks() {
		logic.executeCommand(createFloating);
		logic.executeCommand(createDeadline);
		logic.executeCommand(createBounded);
		Output output = logic.executeCommand(displayAll);

		String[] boundedTask = { "1", "dinner", "8am", "MON", "12", "OCT",
				"2015", "8am", "TUE", "13", "OCT", "2015", "UNDONE", "" };
		ArrayList<String> expectedBoundedTask = arrayToArrayList(boundedTask);

		String[] deadlineTask = { "2", "assignment", "", "", "", "", "", "8am",
				"TUE", "13", "OCT", "2015", "UNDONE", "true" };
		ArrayList<String> expectedDeadlineTask = arrayToArrayList(deadlineTask);

		String[] floatingTask = { "3", "birthday", "", "", "", "", "", "", "",
				"", "", "", "UNDONE", "" };
		ArrayList<String> expectedFloatingTask = arrayToArrayList(floatingTask);

		Output expected = new Output();
		ArrayList<ArrayList<String>> expectedList = new ArrayList<ArrayList<String>>();
		expectedList.add(expectedBoundedTask);
		expectedList.add(expectedDeadlineTask);
		expectedList.add(expectedFloatingTask);
		expected.setOutput(expectedList);
		expected.setReturnMessage("All tasks are now displayed!");
		assertEquals(expected, output);

		TaskList expectedTaskList = new TaskList();
		expectedTaskList
				.addTask(new BoundedTask("dinner", dummyStart, dummyEnd));
		expectedTaskList.addTask(new DeadlineTask("assignment", dummyEnd));
		expectedTaskList.addTask(new FloatingTask("birthday"));
		assertEquals(expectedTaskList, logic.getLastDisplayedList());
	}

	@Test
	public void displayFloatingTasks() {
		logic.executeCommand(createFloating);
		logic.executeCommand(createDeadline);
		logic.executeCommand(createBounded);

		DisplayCommand displayFloating = new DisplayCommand(
				DisplayCommand.Scope.FLOATING);
		Output output = logic.executeCommand(displayFloating);

		String[] floatingTask = { "1", "birthday", "", "", "", "", "", "", "",
				"", "", "", "UNDONE", "" };
		ArrayList<String> expectedFloatingTask = arrayToArrayList(floatingTask);

		Output expected = new Output();
		ArrayList<ArrayList<String>> expectedList = new ArrayList<ArrayList<String>>();
		expectedList.add(expectedFloatingTask);
		expected.setOutput(expectedList);
		expected.setReturnMessage("All floating tasks are now displayed!");
		assertEquals(expected, output);

		TaskList expectedTaskList = new TaskList();
		expectedTaskList.addTask(new FloatingTask("birthday"));
		assertEquals(expectedTaskList, logic.getLastDisplayedList());
	}

	@Test
	public void displayDefault() {
		LocalDateTime currentStart = LocalDateTime.now().plusDays(1);
		LocalDateTime currentEnd = currentStart.plusDays(1);
		LocalDateTime overdueEnd = currentStart.minusDays(2);

		CreateCommand createDeadline = new CreateCommand("assignment",
				currentEnd);
		CreateCommand createOverdue = new CreateCommand("late work", overdueEnd);
		CreateCommand createBounded = new CreateCommand("dinner", currentStart,
				currentEnd);

		BoundedTask dummyBounded = new BoundedTask("dinner", currentStart,
				currentEnd);
		DeadlineTask dummyOverdue = new DeadlineTask("late work", overdueEnd);

		logic.executeCommand(createFloating);
		logic.executeCommand(createOverdue);
		logic.executeCommand(createDeadline);
		logic.executeCommand(createBounded);

		DisplayCommand displayDefault = new DisplayCommand(
				DisplayCommand.Scope.DEFAULT);
		Output output = logic.executeCommand(displayDefault);

		String[] floatingTask = { "4", "birthday", "", "", "", "", "", "", "",
				"", "", "", "UNDONE", "" };
		ArrayList<String> expectedFloatingTask = arrayToArrayList(floatingTask);

		ArrayList<String> expectedDeadlineTask = new ArrayList<String>();
		expectedDeadlineTask.add("3");
		expectedDeadlineTask.add("assignment");
		expectedDeadlineTask.add("");
		expectedDeadlineTask.add("");
		expectedDeadlineTask.add("");
		expectedDeadlineTask.add("");
		expectedDeadlineTask.add("");
		expectedDeadlineTask.add(dummyBounded.getFriendlyEndTime());
		expectedDeadlineTask.add(currentEnd.getDayOfWeek().toString()
				.substring(0, 3));
		expectedDeadlineTask.add(String.valueOf(currentEnd.getDayOfMonth()));
		expectedDeadlineTask.add(currentEnd.getMonth().toString()
				.substring(0, 3));
		expectedDeadlineTask.add(String.valueOf(currentEnd.getYear()));
		expectedDeadlineTask.add("UNDONE");
		expectedDeadlineTask.add("false");

		ArrayList<String> expectedBoundedTask = new ArrayList<String>();
		expectedBoundedTask.add("2");
		expectedBoundedTask.add("dinner");
		expectedBoundedTask.add(dummyBounded.getFriendlyStartTime());
		expectedBoundedTask.add(currentStart.getDayOfWeek().toString()
				.substring(0, 3));
		expectedBoundedTask.add(String.valueOf(currentStart.getDayOfMonth()));
		expectedBoundedTask.add(currentStart.getMonth().toString()
				.substring(0, 3));
		expectedBoundedTask.add(String.valueOf(currentStart.getYear()));
		expectedBoundedTask.add(dummyBounded.getFriendlyEndTime());
		expectedBoundedTask.add(currentEnd.getDayOfWeek().toString()
				.substring(0, 3));
		expectedBoundedTask.add(String.valueOf(currentEnd.getDayOfMonth()));
		expectedBoundedTask.add(currentEnd.getMonth().toString()
				.substring(0, 3));
		expectedBoundedTask.add(String.valueOf(currentEnd.getYear()));
		expectedBoundedTask.add("UNDONE");
		expectedBoundedTask.add("");

		ArrayList<String> expectedOverdueTask = new ArrayList<String>();
		expectedOverdueTask.add("1");
		expectedOverdueTask.add("late work");
		expectedOverdueTask.add("");
		expectedOverdueTask.add("");
		expectedOverdueTask.add("");
		expectedOverdueTask.add("");
		expectedOverdueTask.add("");
		expectedOverdueTask.add(dummyOverdue.getFriendlyEndTime());
		expectedOverdueTask.add(overdueEnd.getDayOfWeek().toString()
				.substring(0, 3));
		expectedOverdueTask.add(String.valueOf(overdueEnd.getDayOfMonth()));
		expectedOverdueTask.add(overdueEnd.getMonth().toString()
				.substring(0, 3));
		expectedOverdueTask.add(String.valueOf(overdueEnd.getYear()));
		expectedOverdueTask.add("UNDONE");
		expectedOverdueTask.add("true");

		Output expected = new Output();
		ArrayList<ArrayList<String>> expectedList = new ArrayList<ArrayList<String>>();
		expectedList.add(expectedOverdueTask);
		expectedList.add(expectedBoundedTask);
		expectedList.add(expectedDeadlineTask);
		expectedList.add(expectedFloatingTask);
		expected.setOutput(expectedList);
		expected.setReturnMessage("Welcome to Flexi-List!");

		assertEquals(expected.getTasks(), output.getTasks());

		TaskList expectedTaskList = new TaskList();
		expectedTaskList.addTask(new DeadlineTask("late work", overdueEnd));
		expectedTaskList.addTask(new BoundedTask("dinner", currentStart,
				currentEnd));
		expectedTaskList.addTask(new DeadlineTask("assignment", currentEnd));
		expectedTaskList.addTask(new FloatingTask("birthday"));
		assertEquals(expectedTaskList, logic.getLastDisplayedList());
	}

	@Test
	public void displayDoneTasks() {
		MarkCommand markFloating = new MarkCommand("birthday");
		markFloating.setMarkField(markField.MARK);
		logic.executeCommand(createFloating);
		logic.executeCommand(createDeadline);
		logic.executeCommand(createBounded);
		logic.executeCommand(displayAll);
		logic.executeCommand(markFloating);

		DisplayCommand displayDone = new DisplayCommand(
				DisplayCommand.Scope.DONE);
		Output output = logic.executeCommand(displayDone);

		String[] floatingTask = { "1", "birthday", "", "", "", "", "", "", "",
				"", "", "", "DONE", "" };
		ArrayList<String> expectedFloatingTask = arrayToArrayList(floatingTask);

		Output expected = new Output();
		ArrayList<ArrayList<String>> expectedList = new ArrayList<ArrayList<String>>();
		expectedList.add(expectedFloatingTask);
		expected.setOutput(expectedList);
		expected.setReturnMessage("All DONE tasks are now displayed!");
		assertEquals(expected, output);

		TaskList expectedLastDisplayed = new TaskList();
		FloatingTask doneFloating = new FloatingTask("birthday");
		doneFloating.setStatus(Status.DONE);
		expectedLastDisplayed.addTask(doneFloating);
		assertEquals(expectedLastDisplayed, logic.getLastDisplayedList());
	}

	@Test
	public void displayUndoneTasks() {
		MarkCommand markFloating = new MarkCommand("birthday");
		markFloating.setMarkField(markField.MARK);
		logic.executeCommand(createFloating);
		logic.executeCommand(createDeadline);
		logic.executeCommand(createBounded);
		logic.executeCommand(displayAll);
		logic.executeCommand(markFloating);

		DisplayCommand testCommand = new DisplayCommand(
				DisplayCommand.Scope.UNDONE);
		Output output = logic.executeCommand(testCommand);

		String[] boundedTask = { "1", "dinner", "8am", "MON", "12", "OCT",
				"2015", "8am", "TUE", "13", "OCT", "2015", "UNDONE", "" };
		ArrayList<String> expectedBoundedTask = arrayToArrayList(boundedTask);

		String[] deadlineTask = { "2", "assignment", "", "", "", "", "", "8am",
				"TUE", "13", "OCT", "2015", "UNDONE", "true" };
		ArrayList<String> expectedDeadlineTask = arrayToArrayList(deadlineTask);

		Output expected = new Output();
		ArrayList<ArrayList<String>> expectedList = new ArrayList<ArrayList<String>>();
		expectedList.add(expectedBoundedTask);
		expectedList.add(expectedDeadlineTask);
		expected.setOutput(expectedList);
		expected.setReturnMessage("All UNDONE tasks are now displayed!");
		assertEquals(expected.getTasks(), output.getTasks());

		TaskList expectedLastDisplayed = new TaskList();
		expectedLastDisplayed.addTask(new BoundedTask("dinner", dummyStart,
				dummyEnd));
		expectedLastDisplayed.addTask(new DeadlineTask("assignment", dummyEnd));
		assertEquals(expectedLastDisplayed, logic.getLastDisplayedList());
	}

	@Test
	public void displayByKeyword() {
		logic.executeCommand(createFloating);
		CreateCommand createDeadline = new CreateCommand("examday", dummyEnd);
		logic.executeCommand(createDeadline);
		logic.executeCommand(createBounded);

		ArrayList<String> keywords = new ArrayList<String>();
		keywords.add("day");
		DisplayCommand displayKeyword = new DisplayCommand(keywords);
		Output output = logic.executeCommand(displayKeyword);

		String[] deadlineTask = { "1", "examday", "", "", "", "", "", "8am",
				"TUE", "13", "OCT", "2015", "UNDONE", "true" };
		ArrayList<String> expectedDeadlineTask = arrayToArrayList(deadlineTask);

		String[] floatingTask = { "2", "birthday", "", "", "", "", "", "", "",
				"", "", "", "UNDONE", "" };
		ArrayList<String> expectedFloatingTask = arrayToArrayList(floatingTask);

		Output expected = new Output();
		ArrayList<ArrayList<String>> expectedList = new ArrayList<ArrayList<String>>();
		expectedList.add(expectedDeadlineTask);
		expectedList.add(expectedFloatingTask);
		expected.setOutput(expectedList);
		expected.setReturnMessage("All tasks with keyword \"day\" are now displayed!");
		assertEquals(expected, output);

		TaskList expectedLastDisplayed = new TaskList();
		expectedLastDisplayed.addTask(new DeadlineTask("examday", dummyEnd));
		expectedLastDisplayed.addTask(new FloatingTask("birthday"));
		assertEquals(expectedLastDisplayed, logic.getLastDisplayedList());
	}

	@Test
	public void displayByDate() {
		logic.executeCommand(createFloating);
		logic.executeCommand(createDeadline);
		logic.executeCommand(createBounded);

		DisplayCommand displayCommand = new DisplayCommand(dummyEnd);
		Output output = logic.executeCommand(displayCommand);

		String[] boundedTask = { "1", "dinner", "8am", "MON", "12", "OCT",
				"2015", "8am", "TUE", "13", "OCT", "2015", "UNDONE", "" };
		ArrayList<String> expectedBoundedTask = arrayToArrayList(boundedTask);

		String[] deadlineTask = { "2", "assignment", "", "", "", "", "", "8am",
				"TUE", "13", "OCT", "2015", "UNDONE", "true" };
		ArrayList<String> expectedDeadlineTask = arrayToArrayList(deadlineTask);

		Output expected = new Output();
		ArrayList<ArrayList<String>> expectedList = new ArrayList<ArrayList<String>>();
		expectedList.add(expectedBoundedTask);
		expectedList.add(expectedDeadlineTask);
		expected.setOutput(expectedList);
		expected.setReturnMessage("All tasks with date \"13 10 2015\" are now displayed!");
		assertEquals(expected, output);

		TaskList expectedLastDisplayed = new TaskList();
		expectedLastDisplayed.addTask(new BoundedTask("dinner", dummyStart,
				dummyEnd));
		expectedLastDisplayed.addTask(new DeadlineTask("assignment", dummyEnd));
		assertEquals(expectedLastDisplayed, logic.getLastDisplayedList());
	}

	/**
	 * EDITACTION TESTS
	 */
	
	@Test
	public void editTaskNameByIndex() {
		CreateCommand createFloating1 = new CreateCommand("birthday");
		CreateCommand createFloating2 = new CreateCommand("birth");
		CreateCommand createFloating3 = new CreateCommand("birthday");
		CreateCommand createFloating4 = new CreateCommand("vday");
		CreateCommand createFloating5 = new CreateCommand("birtay");

		logic.executeCommand(createFloating1);
		logic.executeCommand(createFloating2);
		logic.executeCommand(createFloating3);
		logic.executeCommand(createFloating4);
		logic.executeCommand(createFloating5);

		ArrayList<String> keywords = new ArrayList<String>();
		keywords.add("day");
		DisplayCommand displayCommand = new DisplayCommand(keywords);
		logic.executeCommand(displayCommand);

		// item 2 after filtering should be "vday"
		EditCommand editCommand = new EditCommand(2);
		ArrayList<EditCommand.editField> editFields = new ArrayList<EditCommand.editField>();
		editFields.add(EditCommand.editField.NAME);
		editCommand.setEditFields(editFields);
		editCommand.setNewName("assignment");
		Output output = logic.executeCommand(editCommand);

		Output expected = new Output();
		expected.setReturnMessage("\"vday\" has been edited!");

		assertEquals(expected, output);

		// vday is item of index 3 in mockTaskList
		AbstractTask editedTask = logic.getTaskList().getTask(3);
		FloatingTask expectedTask = new FloatingTask("assignment");
		assertEquals(expectedTask, editedTask);
	}

	@Test
	public void editTaskStartByIndex() {
		logic.executeCommand(createBounded);
		logic.executeCommand(displayAll);

		EditCommand editCommand = new EditCommand(1);
		ArrayList<EditCommand.editField> editFields = new ArrayList<EditCommand.editField>();
		editFields.add(EditCommand.editField.START_DATE);
		editFields.add(EditCommand.editField.START_TIME);
		editCommand.setEditFields(editFields);
		editCommand.setNewStartDate("11 10 2015");
		editCommand.setNewStartTime("10 00");
		Output output = logic.executeCommand(editCommand);

		Output expected = new Output();
		expected.setReturnMessage("\"dinner\" has been edited!");

		assertEquals(expected, output);

		AbstractTask editedTask = logic.getTaskList().getTask(0);
		LocalDateTime newStart = LocalDateTime.parse("11 10 2015 10 00",
				DTFormatter);
		BoundedTask expectedTask = new BoundedTask("dinner", newStart, dummyEnd);
		assertEquals(expectedTask, editedTask);
	}

	@Test
	public void editTaskStartByIndexWithWrongDateOrder() {
		logic.executeCommand(createBounded);
		logic.executeCommand(displayAll);

		EditCommand editCommand = new EditCommand(1);
		ArrayList<EditCommand.editField> editFields = new ArrayList<EditCommand.editField>();
		editFields.add(EditCommand.editField.START_DATE);
		editFields.add(EditCommand.editField.START_TIME);
		editCommand.setEditFields(editFields);
		editCommand.setNewStartDate("14 10 2015");
		editCommand.setNewStartTime("10 00");
		Output output = logic.executeCommand(editCommand);

		Output expected = new Output();
		expected.setReturnMessage("Invalid: Start date time must be before End date time!");
		expected.setPriority(Priority.HIGH);

		assertEquals(expected, output);

		AbstractTask editedTask = logic.getTaskList().getTask(0);
		BoundedTask expectedTask = new BoundedTask("dinner", dummyStart,
				dummyEnd);
		assertEquals(expectedTask, editedTask);
	}

	@Test
	public void editDeadlineTaskEndByIndex() {
		logic.executeCommand(createDeadline);
		logic.executeCommand(displayAll);

		EditCommand editCommand = new EditCommand(1);
		ArrayList<EditCommand.editField> editFields = new ArrayList<EditCommand.editField>();
		editFields.add(EditCommand.editField.END_DATE);
		editFields.add(EditCommand.editField.END_TIME);
		editCommand.setEditFields(editFields);
		editCommand.setNewEndDate("14 10 2015");
		editCommand.setNewEndTime("10 00");
		Output output = logic.executeCommand(editCommand);

		Output expected = new Output();
		expected.setReturnMessage("\"assignment\" has been edited!");

		assertEquals(expected, output);

		AbstractTask editedTask = logic.getTaskList().getTask(0);
		LocalDateTime newEnd = LocalDateTime.parse("14 10 2015 10 00",
				DTFormatter);
		DeadlineTask expectedTask = new DeadlineTask("assignment", newEnd);
		assertEquals(expectedTask, editedTask);
	}

	@Test
	public void editBoundedTaskEndByIndex() {
		logic.executeCommand(createBounded);
		logic.executeCommand(displayAll);

		EditCommand editCommand = new EditCommand(1);
		ArrayList<EditCommand.editField> editFields = new ArrayList<EditCommand.editField>();
		editFields.add(EditCommand.editField.END_DATE);
		editFields.add(EditCommand.editField.END_TIME);
		editCommand.setEditFields(editFields);
		editCommand.setNewEndDate("14 10 2015");
		editCommand.setNewEndTime("10 00");
		Output output = logic.executeCommand(editCommand);

		Output expected = new Output();
		expected.setReturnMessage("\"dinner\" has been edited!");

		assertEquals(expected, output);

		AbstractTask editedTask = logic.getTaskList().getTask(0);
		LocalDateTime newEnd = LocalDateTime.parse("14 10 2015 10 00",
				DTFormatter);
		BoundedTask expectedTask = new BoundedTask("dinner", dummyStart, newEnd);
		assertEquals(expectedTask, editedTask);
	}

	@Test
	public void editTaskEndByIndexWithWrongDateOrder() {
		logic.executeCommand(createBounded);
		logic.executeCommand(displayAll);

		EditCommand editCommand = new EditCommand(1);
		ArrayList<EditCommand.editField> editFields = new ArrayList<EditCommand.editField>();
		editFields.add(EditCommand.editField.END_DATE);
		editFields.add(EditCommand.editField.END_TIME);
		editCommand.setEditFields(editFields);
		editCommand.setNewEndDate("10 10 2015");
		editCommand.setNewEndTime("10 00");
		Output output = logic.executeCommand(editCommand);

		Output expected = new Output();
		expected.setReturnMessage("Invalid: Start date time must be before End date time!");
		expected.setPriority(Priority.HIGH);

		assertEquals(expected, output);

		AbstractTask editedTask = logic.getTaskList().getTask(0);
		BoundedTask expectedTask = new BoundedTask("dinner", dummyStart,
				dummyEnd);
		assertEquals(expectedTask, editedTask);
	}

	@Test
	public void editTaskNameByNameOneHIT() {
		logic.executeCommand(createFloating);

		EditCommand editCommand = new EditCommand("birthday");
		ArrayList<EditCommand.editField> editFields = new ArrayList<EditCommand.editField>();
		editFields.add(EditCommand.editField.NAME);
		editCommand.setEditFields(editFields);
		editCommand.setNewName("assignment");
		Output output = logic.executeCommand(editCommand);

		Output expected = new Output();
		expected.setReturnMessage("\"birthday\" has been edited!");

		assertEquals(expected, output);

		AbstractTask editedTask = logic.getTaskList().getTask(0);
		FloatingTask expectedTask = new FloatingTask("assignment");
		assertEquals(expectedTask, editedTask);
	}

	@Test
	public void editTaskNameAndEndByNameOneHIT() {
		logic.executeCommand(createDeadline);

		EditCommand editCommand = new EditCommand("assignment");
		ArrayList<EditCommand.editField> editFields = new ArrayList<EditCommand.editField>();
		editFields.add(EditCommand.editField.NAME);
		editFields.add(EditCommand.editField.END_TIME);
		editFields.add(EditCommand.editField.END_DATE);
		editCommand.setEditFields(editFields);
		editCommand.setNewName("birthday");
		editCommand.setNewEndTime("08 00");
		editCommand.setNewEndDate("12 10 2015");
		Output output = logic.executeCommand(editCommand);

		Output expected = new Output();
		expected.setReturnMessage("\"assignment\" has been edited!");

		assertEquals(expected, output);

		AbstractTask editedTask = logic.getTaskList().getTask(0);
		DeadlineTask expectedTask = new DeadlineTask("birthday", dummyStart);
		assertEquals(expectedTask, editedTask);
	}

	@Test
	public void editTaskNameByNamePartialHIT() {
		logic.executeCommand(createFloating);

		EditCommand editCommand = new EditCommand("day");
		ArrayList<EditCommand.editField> editFields = new ArrayList<EditCommand.editField>();
		editFields.add(EditCommand.editField.NAME);
		editCommand.setEditFields(editFields);
		editCommand.setNewName("assignment");
		Output output = logic.executeCommand(editCommand);

		Output expected = new Output();
		expected.setReturnMessage("All tasks with keyword \"day\" are now displayed!");

		String[] floatingTask = { "1", "birthday", "", "", "", "", "", "", "",
				"", "", "", "UNDONE", "" };
		ArrayList<String> expectedFloatingTask = arrayToArrayList(floatingTask);

		ArrayList<ArrayList<String>> expectedList = new ArrayList<ArrayList<String>>();
		expectedList.add(expectedFloatingTask);
		expected.setOutput(expectedList);
		assertEquals(expected, output);

		AbstractTask editedTask = logic.getTaskList().getTask(0);
		FloatingTask expectedTask = new FloatingTask("birthday");
		assertEquals(expectedTask, editedTask);

		// Second step of edit by keyword partial or multiple hit

		EditCommand editByIndex = new EditCommand(1);
		Output secondOutput = logic.executeCommand(editByIndex);

		Output expectedSecondOutput = new Output();
		expectedSecondOutput.setReturnMessage("\"birthday\" has been edited!");

		assertEquals(expectedSecondOutput, secondOutput);

		AbstractTask editedAgainTask = logic.getTaskList().getTask(0);
		FloatingTask expectedAgainTask = new FloatingTask("assignment");
		assertEquals(expectedAgainTask, editedAgainTask);

	}

	@Test
	public void editTaskStartAndEndOneMonthLater() {
		logic.executeCommand(createBounded);
		logic.executeCommand(displayAll);

		EditCommand editCommand = new EditCommand(1);
		ArrayList<EditCommand.editField> editFields = new ArrayList<EditCommand.editField>();
		editFields.add(EditCommand.editField.START_DATE);
		editFields.add(EditCommand.editField.END_DATE);
		editCommand.setEditFields(editFields);
		editCommand.setNewStartDate("12 11 2015");
		editCommand.setNewEndDate("13 11 2015");
		Output output = logic.executeCommand(editCommand);

		Output expected = new Output();
		expected.setReturnMessage("\"dinner\" has been edited!");
		assertEquals(expected, output);

		AbstractTask editedTask = logic.getTaskList().getTask(0);
		LocalDateTime newStart = LocalDateTime.parse("12 11 2015 08 00",
				DTFormatter);
		LocalDateTime newEnd = LocalDateTime.parse("13 11 2015 08 00",
				DTFormatter);
		BoundedTask expectedTask = new BoundedTask("dinner", newStart, newEnd);
		assertEquals(expectedTask, editedTask);
	}
	
	/**
	 * DELETEACTION TESTS
	 */

	@Test
	public void deleteTaskByIndex() {
		logic.executeCommand(createFloating);
		logic.executeCommand(createDeadline);
		logic.executeCommand(createBounded);
		logic.executeCommand(displayAll);

		// dinner will be first task in last displayed
		DeleteCommand deleteCommand = new DeleteCommand(1);
		Output output = logic.executeCommand(deleteCommand);

		Output expected = new Output();
		expected.setReturnMessage("\"dinner\" has been deleted!");
		expected.setPriority(Priority.HIGH);

		assertEquals(expected, output);
		TaskList expectedTaskList = new TaskList();
		expectedTaskList.addTask(new FloatingTask("birthday"));
		expectedTaskList.addTask(new DeadlineTask("assignment", dummyEnd));
		assertEquals(expectedTaskList, logic.getTaskList());
	}

	@Test
	public void deleteTaskByKeywordOneHIT() {
		logic.executeCommand(createFloating);
		logic.executeCommand(createDeadline);
		logic.executeCommand(createBounded);

		DeleteCommand deleteCommand = new DeleteCommand("birthday");
		Output output = logic.executeCommand(deleteCommand);

		Output expected = new Output();
		expected.setReturnMessage("\"birthday\" has been deleted!");
		expected.setPriority(Priority.HIGH);

		assertEquals(expected, output);
		TaskList expectedTaskList = new TaskList();
		expectedTaskList.addTask(new DeadlineTask("assignment", dummyEnd));
		expectedTaskList
				.addTask(new BoundedTask("dinner", dummyStart, dummyEnd));
		assertEquals(expectedTaskList, logic.getTaskList());
	}

	@Test
	public void deleteTaskByKeywordOnePartialHIT() {
		logic.executeCommand(createFloating);
		logic.executeCommand(createDeadline);
		logic.executeCommand(createBounded);

		DeleteCommand deleteCommand = new DeleteCommand("day");
		Output output = logic.executeCommand(deleteCommand);

		String[] floatingTask = { "1", "birthday", "", "", "", "", "", "", "",
				"", "", "", "UNDONE", "" };
		ArrayList<String> expectedFloatingTask = arrayToArrayList(floatingTask);

		Output expected = new Output();
		ArrayList<ArrayList<String>> expectedList = new ArrayList<ArrayList<String>>();
		expectedList.add(expectedFloatingTask);
		expected.setOutput(expectedList);
		expected.setReturnMessage("All tasks with keyword \"day\" are now displayed!");
		assertEquals(expected, output);
		
		TaskList expectedTaskList = new TaskList();
		expectedTaskList.addTask(new FloatingTask("birthday"));
		expectedTaskList.addTask(new DeadlineTask("assignment", dummyEnd));
		expectedTaskList
				.addTask(new BoundedTask("dinner", dummyStart, dummyEnd));

		assertEquals(expectedTaskList, logic.getTaskList());
	}

	@Test
	public void deleteTaskByKeywordMultipleHIT() {
		CreateCommand createDeadline = new CreateCommand("examday", dummyEnd);
		logic.executeCommand(createFloating);
		logic.executeCommand(createDeadline);
		logic.executeCommand(createBounded);

		DeleteCommand deleteCommand = new DeleteCommand("day");
		Output output = logic.executeCommand(deleteCommand);

		String[] deadlineTask = { "1", "examday", "", "", "", "", "", "8am",
				"TUE", "13", "OCT", "2015", "UNDONE", "true" };
		ArrayList<String> expectedDeadlineTask = arrayToArrayList(deadlineTask);

		String[] floatingTask = { "2", "birthday", "", "", "", "", "", "", "",
				"", "", "", "UNDONE", "" };
		ArrayList<String> expectedFloatingTask = arrayToArrayList(floatingTask);

		Output expected = new Output();
		ArrayList<ArrayList<String>> expectedList = new ArrayList<ArrayList<String>>();
		expectedList.add(expectedDeadlineTask);
		expectedList.add(expectedFloatingTask);
		expected.setOutput(expectedList);
		expected.setReturnMessage("All tasks with keyword \"day\" are now displayed!");
		assertEquals(expected, output);
		
		TaskList expectedTaskList = new TaskList();
		expectedTaskList.addTask(new FloatingTask("birthday"));
		expectedTaskList.addTask(new DeadlineTask("examday", dummyEnd));
		expectedTaskList
				.addTask(new BoundedTask("dinner", dummyStart, dummyEnd));
		assertEquals(expectedTaskList, logic.getTaskList());
	}

	@Test
	public void deleteAllTasks() {
		logic.executeCommand(createFloating);
		logic.executeCommand(createDeadline);
		logic.executeCommand(createBounded);

		DeleteCommand deleteCommand = new DeleteCommand(Scope.ALL);
		Output output = logic.executeCommand(deleteCommand);

		Output expected = new Output();
		expected.setReturnMessage("All tasks have been deleted!");
		expected.setPriority(Priority.HIGH);

		assertEquals(expected, output);
		TaskList expectedTaskList = new TaskList();
		assertEquals(expectedTaskList, logic.getTaskList());
	}

	/**
	 * MARKACTION TESTS
	 */
	
	@Test
	public void markTaskByIndex() {
		logic.executeCommand(createFloating);
		logic.executeCommand(createDeadline);
		logic.executeCommand(createBounded);
		logic.executeCommand(displayAll);

		// dinner will be first task in last displayed
		MarkCommand markCommand = new MarkCommand(1);
		markCommand.setMarkField(markField.MARK);
		Output output = logic.executeCommand(markCommand);

		Output expected = new Output();
		expected.setReturnMessage("\"dinner\" has been marked done.");
		assertEquals(expected, output);
		
		AbstractTask expectedTask = new BoundedTask("dinner", dummyStart,
				dummyEnd);
		expectedTask.setStatus(Status.DONE);
		assertEquals(expectedTask, logic.getTaskList().getTask(2));
	}

	@Test
	public void markTaskByKeywordOneHIT() {
		logic.executeCommand(createFloating);
		logic.executeCommand(createDeadline);
		logic.executeCommand(createBounded);
		
		MarkCommand markCommand = new MarkCommand("birthday");
		markCommand.setMarkField(markField.MARK);
		Output output = logic.executeCommand(markCommand);

		Output expected = new Output();
		expected.setReturnMessage("\"birthday\" has been marked done.");
		assertEquals(expected, output);
		
		AbstractTask expectedTask = new FloatingTask("birthday");
		expectedTask.setStatus(Status.DONE);
		assertEquals(expectedTask, logic.getTaskList().getTask(0));
	}

	@Test
	public void markTaskByKeywordOnePartialHIT() {
		logic.executeCommand(createFloating);
		logic.executeCommand(createDeadline);
		logic.executeCommand(createBounded);
		
		MarkCommand markCommand = new MarkCommand("day");
		markCommand.setMarkField(markField.MARK);
		Output output = logic.executeCommand(markCommand);
		
		String[] floatingTask = { "1", "birthday", "", "", "", "", "", "", "",
				"", "", "", "UNDONE", "" };
		ArrayList<String> expectedFloatingTask = arrayToArrayList(floatingTask);

		Output expected = new Output();
		ArrayList<ArrayList<String>> expectedList = new ArrayList<ArrayList<String>>();
		expectedList.add(expectedFloatingTask);
		expected.setOutput(expectedList);
		expected.setReturnMessage("All tasks with keyword \"day\" are now displayed!");
		assertEquals(expected, output);
		
		TaskList expectedTaskList = new TaskList();
		expectedTaskList.addTask(new FloatingTask("birthday"));
		expectedTaskList.addTask(new DeadlineTask("assignment", dummyEnd));
		expectedTaskList
				.addTask(new BoundedTask("dinner", dummyStart, dummyEnd));

		assertEquals(expectedTaskList, logic.getTaskList());
	}

	@Test
	public void markTaskByKeywordMultipleHIT() {
		CreateCommand createDeadline = new CreateCommand("examday", dummyEnd);
		logic.executeCommand(createFloating);
		logic.executeCommand(createDeadline);
		logic.executeCommand(createBounded);

		MarkCommand markCommand = new MarkCommand("day");
		markCommand.setMarkField(markField.MARK);
		Output output = logic.executeCommand(markCommand);

		String[] deadlineTask = { "1", "examday", "", "", "", "", "", "8am",
				"TUE", "13", "OCT", "2015", "UNDONE", "true" };
		ArrayList<String> expectedDeadlineTask = arrayToArrayList(deadlineTask);

		String[] floatingTask = { "2", "birthday", "", "", "", "", "", "", "",
				"", "", "", "UNDONE", "" };
		ArrayList<String> expectedFloatingTask = arrayToArrayList(floatingTask);

		Output expected = new Output();
		ArrayList<ArrayList<String>> expectedList = new ArrayList<ArrayList<String>>();
		expectedList.add(expectedDeadlineTask);
		expectedList.add(expectedFloatingTask);
		expected.setOutput(expectedList);
		expected.setReturnMessage("All tasks with keyword \"day\" are now displayed!");
		assertEquals(expected, output);
		
		TaskList expectedTaskList = new TaskList();
		expectedTaskList.addTask(new FloatingTask("birthday"));
		expectedTaskList.addTask(new DeadlineTask("examday", dummyEnd));
		expectedTaskList
				.addTask(new BoundedTask("dinner", dummyStart, dummyEnd));
		assertEquals(expectedTaskList, logic.getTaskList());
	}

	/**
	 * UNDOACTION TESTS
	 */
	
	@Test
	public void undoPreviousActionCreate() {
		logic.executeCommand(createFloating);

		UndoCommand undoCommand = new UndoCommand();
		Output output = logic.executeCommand(undoCommand);
		Output expected = new Output();
		expected.setReturnMessage("\"create\" action has been undone!");
		assertEquals(expected, output);
		
		int expectedTaskListSize = 0;
		int actualTaskListSize = logic.getTaskList().size();
		assertEquals(expectedTaskListSize, actualTaskListSize);
	}

	@Test
	public void undoPreviousActionDelete() {
		DeleteCommand deleteCommand = new DeleteCommand(1);
		logic.executeCommand(createFloating);
		logic.executeCommand(displayAll);
		logic.executeCommand(deleteCommand);

		UndoCommand undoCommand = new UndoCommand();
		Output output = logic.executeCommand(undoCommand);
		Output expected = new Output();
		expected.setReturnMessage("\"delete\" action has been undone!");
		assertEquals(expected, output);
		assertTrue(logic.getTaskList().size() == 1);
		
		FloatingTask expectedTask = new FloatingTask("birthday");
		assertEquals(expectedTask, logic.getTaskList().getTask(0));
	}

}
```
