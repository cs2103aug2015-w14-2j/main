# A0131188H
###### parser\DateParser.java
``` java
public class DateParser {
	DateTimeChecker dtChecker = new DateTimeChecker();
	private ArrayList<String> args;

	public DateParser(ArrayList<String> args) {
		this.args = args;
	}

	protected int getDateIndex(int start, int end) {
		for (int i = start; i < end; i++) {
			String first = args.get(i);
			String second = Constants.EMPTY;
			String third = Constants.EMPTY;
			if (i + 2 < end) {
				second = args.get(i + 1);
				third = args.get(i + 1);
			} else if (i + 1 < end) {
				second = args.get(i + 1);
			}

			if (dtChecker.isDate(first) || dtChecker.isYtdOrTodayOrTmr(first)) {
				return i;
			} else if (dtChecker.isNaturalLanguageDate(first, second)) {
				return i;
			} else if (dtChecker.isMonthInEngDate(first, second, third)) {
				return i;
			} else if (dtChecker.isMonthInEngDate1(first, second)) {
				return i;
			} else if (dtChecker.isMonthInEngDate2(first, second)) {
				return i;
			} else if (dtChecker.isMonthInEngDate(first)) {
				return i;
			}
		}
		return -1;
	}

	protected String getDate(int start, int end) {
		int dateIndex = getDateIndex(start, end);
		String date = args.get(dateIndex);
		return getDate(date);
	}

	protected String getDate(String date) {
		assert (dtChecker.isDate(date));

		String[] dateParts = date.split(Constants.SPLITTER_DATE);
		int dayRaw = Integer.parseInt(dateParts[0]);
		int monthRaw = Integer.parseInt(dateParts[1]);
		String day = String.format(Constants.FORMATTER_2DP, dayRaw);
		String month = String.format(Constants.FORMATTER_2DP, monthRaw);
		String year;
		if (dateParts.length == 2) { // no year entered
			year = getCorrectYear(day, month);
		} else {
			year = dateParts[2];
		}
		return day + Constants.WHITESPACE + month + Constants.WHITESPACE + year;
	}

	protected String getActualDate(String str) {
		assert (dtChecker.isYtdOrTodayOrTmr(str));

		LocalDateTime date = LocalDateTime.now();

		switch (str.toLowerCase()) {
		case Constants.YESTERDAY:
		case Constants.YTD:
			date = date.minusDays(1);
			break;

		case Constants.TOMORROW:
		case Constants.TMR:
			date = date.plusDays(1);
			break;

		case Constants.TODAY:
		case Constants.TONIGHT:
			break;

		default:
		}

		return date.getDayOfMonth() + Constants.SLASH + date.getMonthValue()
				+ Constants.SLASH + date.getYear();
	}

	protected String getActualDate(String str1, String str2) {
		assert (dtChecker.isNaturalLanguageDate(str1, str2));

		LocalDateTime now = LocalDateTime.now();
		LocalDateTime date = now.with(DayOfWeek.MONDAY);

		switch (str2.toLowerCase()) {
		case Constants.MONDAY:
		case Constants.MON:
			break;

		case Constants.TUESDAY:
		case Constants.TUES:
			date = date.plusDays(1);
			break;

		case Constants.WEDNESDAY:
		case Constants.WED:
			date = date.plusDays(2);
			break;

		case Constants.THURSDAY:
		case Constants.THURS:
			date = date.plusDays(3);
			break;

		case Constants.FRIDAY:
		case Constants.FRI:
			date = date.plusDays(4);
			break;

		case Constants.SATURDAY:
		case Constants.SAT:
			date = date.plusDays(5);
			break;

		case Constants.SUNDAY:
		case Constants.SUN:
			date = date.plusDays(6);
			break;

		default:
		}

		if (str1.equals(Constants.LAST)) {
			date = date.minusWeeks(1);
		} else if (str1.equals(Constants.NEXT)) {
			date = date.plusWeeks(1);
		} else if (str1.equals(Constants.THIS)) {
		} else {
		}

		return date.getDayOfMonth() + Constants.SLASH + date.getMonthValue()
				+ Constants.SLASH + date.getYear();
	}

	protected String getCorrectYear(String day, String month) {
		LocalDateTime now = LocalDateTime.now();
		String year;
		if (Integer.parseInt(month) < now.getMonthValue()) {
			year = String.valueOf(now.plusYears(1).getYear());
		} else if (Integer.parseInt(month) == now.getMonthValue()
				&& Integer.parseInt(day) < now.getDayOfMonth()) {
			year = String.valueOf(now.plusYears(1).getYear());
		} else {
			year = String.valueOf(now.getYear());
		}
		return year;
	}

}
```
###### parser\DateProcessor.java
``` java
public class DateProcessor {
	DateTimeChecker dtChecker = new DateTimeChecker();

	/**
	 * Processes yesterday/today/tomorrow to DD/MM/YYYY Processes
	 * [last/this/next] [day] to DD/MM/YYYY Processes month-in-Eng to DD/MM/YYYY
	 */

	protected ArrayList<String> processDeadline(ArrayList<String> args) {
		IndexParser indexParser = new IndexParser(args);
		TimeParser timeParser = new TimeParser(args);
		DateParser dateParser = new DateParser(args);

		int index = indexParser.getIndex(Constants.KEYWORD_BY);

		assert (index != -1); // check done by isDeadline

		int timeIndex = timeParser.getTimeIndex(index, args.size());
		int dateIndex = dateParser.getDateIndex(index, args.size());

		assert (timeIndex != -1); // check done by isDeadline
		assert (dateIndex != -1); // check done by isDeadline

		args = processDate(args, dateIndex);

		assert (dtChecker.isDate(args.get(dateIndex))); // done by processDeadline

		return args;
	}

	protected ArrayList<String> processBounded(ArrayList<String> args) {
		IndexParser indexParser = new IndexParser(args);
		TimeParser timeParser = new TimeParser(args);
		DateParser dateParser = new DateParser(args);

		int sIndex = indexParser.getIndex(Constants.KEYWORD_FROM);
		int eIndex = indexParser.getIndex(Constants.KEYWORD_TO);

		assert (sIndex != -1); // check done by isBounded
		assert (eIndex != -1); // check done by isBounded

		int sTimeIndex = timeParser.getTimeIndex(sIndex, eIndex);
		int sDateIndex = dateParser.getDateIndex(sIndex, eIndex);
		int eTimeIndex = timeParser.getTimeIndex(eIndex, args.size());
		int eDateIndex = dateParser.getDateIndex(eIndex, args.size());

		assert (sTimeIndex != -1); // check done by isBounded
		assert (eTimeIndex != -1); // check done by isBounded
		assert (sDateIndex != -1 || eDateIndex != -1); // check done by isBounded

		// case 1: one date entered for start date and end date,
		// the date is between "from" and "to"
		// case 2: one date entered for start date and end date,
		// the date is after "to"
		// case 3: one date entered for start date and
		// one date entered for end date
		if (sDateIndex != -1 && eDateIndex == -1) { // case 1
			args = processDate(args, sDateIndex);
			args.add(eIndex + 1, args.get(sDateIndex));

			indexParser = refreshIndexParser(args);
			dateParser = refreshDateParser(args);
			timeParser = refreshTimeParser(args);

			eTimeIndex = timeParser.getTimeIndex(eIndex, args.size());
			eDateIndex = dateParser.getDateIndex(eIndex, args.size());

		} else if (sDateIndex == -1 && eDateIndex != -1) { // case 2
			args = processDate(args, eDateIndex);
			args.add(sIndex + 1, args.get(eDateIndex));

			indexParser = refreshIndexParser(args);
			dateParser = refreshDateParser(args);
			timeParser = refreshTimeParser(args);

			eIndex = indexParser.getIndex(Constants.KEYWORD_TO);
			sTimeIndex = timeParser.getTimeIndex(sIndex, eIndex);
			sDateIndex = dateParser.getDateIndex(sIndex, eIndex);
			eTimeIndex = timeParser.getTimeIndex(eIndex, args.size());
			eDateIndex = dateParser.getDateIndex(eIndex, args.size());

		} else { // case 3
			args = processDate(args, sDateIndex);

			indexParser = refreshIndexParser(args);
			dateParser = refreshDateParser(args);
			timeParser = refreshTimeParser(args);

			eTimeIndex = timeParser.getTimeIndex(eIndex, args.size());
			eDateIndex = dateParser.getDateIndex(eIndex, args.size());

			args = processDate(args, eDateIndex);
		}

		assert (dtChecker.isDate(args.get(sDateIndex))); // done by processBounded
		assert (dtChecker.isDate(args.get(eDateIndex))); // done by processBounded

		return args;
	}

	protected ArrayList<String> processAllDay(ArrayList<String> args) {
		IndexParser indexParser = new IndexParser(args);
		DateParser dateParser = new DateParser(args);

		int index = indexParser.getIndex(Constants.KEYWORD_ON);

		assert (index != -1); // check done by isAllDay

		int dateIndex = dateParser.getDateIndex(index, args.size());

		assert (dateIndex != -1);

		args = processDate(args, dateIndex);

		assert (dtChecker.isDate(args.get(dateIndex))); // done by processAllDay

		return args;
	}

	protected ArrayList<String> processDate(ArrayList<String> args,
			int dateIndex) {
		assert (dateIndex != -1); // check done by processDeadline or processBounded

		DateParser dateParser = new DateParser(args);

		ArrayList<String> pArgs = new ArrayList<String>(args);

		String datePart1 = pArgs.get(dateIndex);
		String datePart2 = Constants.EMPTY;
		String datePart3 = Constants.EMPTY;
		if (dateIndex + 1 < pArgs.size()) {
			datePart2 = pArgs.get(dateIndex + 1);
		}
		if (dateIndex + 2 < pArgs.size()) {
			datePart3 = pArgs.get(dateIndex + 2);
		}

		if (dtChecker.isDate(datePart1)) {

		} else if (dtChecker.isYtdOrTodayOrTmr(datePart1)) {
			pArgs.set(dateIndex, dateParser.getActualDate(datePart1));

		} else if (dtChecker.isNaturalLanguageDate(datePart1, datePart2)) {
			pArgs.set(dateIndex, dateParser.getActualDate(datePart1, datePart2));
			pArgs.remove(dateIndex + 1);

		} else if (dtChecker.isMonthInEngDate(datePart1, datePart2, datePart3)) {
			String day = datePart1;
			String month = dtChecker.getMonthStr(datePart2);
			String year = datePart3;
			String date = day + Constants.SLASH + month + Constants.SLASH
					+ year;
			pArgs.set(dateIndex, dateParser.getDate(date));
			pArgs.remove(dateIndex + 2);
			pArgs.remove(dateIndex + 1);

		} else if (dtChecker.isMonthInEngDate1(datePart1, datePart2)) {
			String day = datePart1;
			String month = dtChecker.getMonthStr(datePart2);
			String year = dateParser.getCorrectYear(day, month);
			String date = day + Constants.SLASH + month + Constants.SLASH
					+ year;
			pArgs.set(dateIndex, dateParser.getDate(date));
			pArgs.remove(dateIndex + 1);

		} else if (dtChecker.isMonthInEngDate2(datePart1, datePart2)) {
			String dayMonth = datePart1;
			String day = dtChecker.getDayOfDayMonth(dayMonth);
			String month = dtChecker.getMonthOfDayMonth(dayMonth);
			String year = datePart2;
			String date = day + Constants.SLASH + month + Constants.SLASH
					+ year;
			pArgs.set(dateIndex, dateParser.getDate(date));
			pArgs.remove(dateIndex + 1);

		} else if (dtChecker.isMonthInEngDate(datePart1)) {
			String dayMonth = datePart1;
			String day = dtChecker.getDayOfDayMonth(dayMonth);
			String month = dtChecker.getMonthOfDayMonth(dayMonth);
			String year = dateParser.getCorrectYear(day, month);
			String date = day + Constants.SLASH + month + Constants.SLASH
					+ year;
			pArgs.set(dateIndex, dateParser.getDate(date));
		}

		return pArgs;
	}

	/**
	 * Helper methods
	 */
	private DateParser refreshDateParser(ArrayList<String> args) {
		return new DateParser(args);
	}

	private TimeParser refreshTimeParser(ArrayList<String> args) {
		return new TimeParser(args);
	}

	private IndexParser refreshIndexParser(ArrayList<String> args) {
		return new IndexParser(args);
	}

}
```
###### parser\DateTimeChecker.java
``` java
public class DateTimeChecker {

	/**
	 * Accepts 24-hour format: 8:00, 08:00, 20:00 8.00, 08.00, 20.00 Accepts
	 * 12-hour format: 1:00am, 1:00pm 1.00am, 1.00pm 1am, 1pm
	 */
	protected boolean isTime(String str) {
		if (Pattern.matches(Constants.TIME_FORMAT_1, str)) {
			return (str.contains(Constants.COLON) || 
					str.contains(Constants.DOT));
		} else if (Pattern.matches(Constants.TIME_FORMAT_2, str)) {
			return true;
		}

		String[] strParts;
		if (str.contains(Constants.DOT)) {
			strParts = str.split(Constants.SPLITTER_DOT);
		} else {
			strParts = str.split(Constants.SPLITTER_COLON);
		}

		if (strParts.length != 2) {
			return false;
		}

		String hour = strParts[0];
		String minute = strParts[1];
		if (!(Pattern.matches(Constants.TIME_INTEGER, hour) && 
				Pattern.matches(Constants.TIME_INTEGER, minute))) {
			return false;
		}

		int hourInInt = Integer.parseInt(hour);
		int minuteInInt = Integer.parseInt(minute);

		return hourInInt >= 0 && hourInInt <= 23 
				&& minuteInInt >= 0 && minuteInInt <= 59;
	}

	/**
	 * Accepts DD-MM-YYYY and DD/MM/YYYY Accepts DD-MM and DD/MM - If date is
	 * not over in current year, current year is assumed - If date is over in
	 * current year, following year is assumed
	 */
	protected boolean isDate(String str) {
		LocalDateTime now = LocalDateTime.now();
		String[] strPartsArr = str.split(Constants.SPLITTER_DATE);
		ArrayList<String> strParts = arrayToArrayList(strPartsArr);

		if (strParts.size() == 2) {
			strParts.add(String.valueOf(now.getYear()));
		}

		if (strParts.size() != 3) {
			return false;
		}

		String day = strParts.get(0);
		String month = strParts.get(1);
		String year = strParts.get(2);
		if (!(Pattern.matches(Constants.TIME_INTEGER, day)
				&& Pattern.matches(Constants.TIME_INTEGER, month) 
				&& Pattern.matches(Constants.TIME_INTEGER, year))) {
			return false;
		}

		if (!(Integer.parseInt(year) > 1915 && Integer.parseInt(year) < 2115)) {
			return false;
		}

		switch (month) {
		case "4":
		case "6":
		case "9":
		case "11":
		case "04":
		case "06":
		case "09":
			return 0 < Integer.parseInt(day) && Integer.parseInt(day) <= 30;

		case "1":
		case "3":
		case "5":
		case "7":
		case "8":
		case "10":
		case "12":
		case "01":
		case "03":
		case "05":
		case "07":
		case "08":
			return 0 < Integer.parseInt(day) && Integer.parseInt(day) <= 31;

		case "2":
		case "02":
			if (isLeapYear(Integer.parseInt(year))) {
				return 0 < Integer.parseInt(day) && Integer.parseInt(day) <= 29;
			} else {
				return 0 < Integer.parseInt(day) && Integer.parseInt(day) <= 28;
			}

		default:
			return false;
		}
	}

	/**
	 * Accepts DDmonth-in-Eng - If date is not over in current year, current
	 * year is assumed - If date is over in current year, following year is
	 * assumed e.g. 1jan
	 */
	protected boolean isMonthInEngDate(String str1) {
		if (isDayMonth(str1)) {
			return isDate(getDayOfDayMonth(str1)
					+ Constants.SLASH
					+ getMonthOfDayMonth(str1)
					+ Constants.SLASH
					+ getCorrectYear(getDayOfDayMonth(str1),
							getMonthOfDayMonth(str1)));
		} else {
			return false;
		}
	}

	/**
	 * Accepts DD month-in-Eng - If date is not over in current year, current
	 * year is assumed - If date is over in current year, following year is
	 * assumed e.g. 1 jan
	 */
	protected boolean isMonthInEngDate1(String str1, String str2) {
		if (isInteger(str1) && getMonthInt(str2) != -1) {
			return isDate(str1 + Constants.SLASH + getMonthStr(str2)
					+ Constants.SLASH + getCorrectYear(str1, getMonthStr(str2)));
		} else {
			return false;
		}
	}

	/**
	 * Accepts DDmonth-in-Eng YYYY e.g. 1jan 2016
	 */
	protected boolean isMonthInEngDate2(String str1, String str2) {
		if (isDayMonth(str1) && isInteger(str2)) {
			return isDate(getDayOfDayMonth(str1) + Constants.SLASH
					+ getMonthOfDayMonth(str1) + Constants.SLASH + str2);
		} else {
			return false;
		}
	}

	/**
	 * Accepts DD month-in-Eng YYYY e.g. 1 jan 2016
	 */
	protected boolean isMonthInEngDate(String str1, String str2, String str3) {
		if ((isInteger(str1) && getMonthInt(str2) != -1 && isInteger(str3))) {
			return isDate(str1 + Constants.SLASH + getMonthStr(str2)
					+ Constants.SLASH + str3);
		} else {
			return false;
		}
	}

	/**
	 * Accepts yesterday/ytd/ today/tonight/ tomorrow/tmr
	 */
	protected boolean isYtdOrTodayOrTmr(String str) {
		String[] ytdOrTodayOrTmr = { Constants.YESTERDAY, Constants.YTD,
				Constants.TODAY, Constants.TONIGHT, Constants.TOMORROW,
				Constants.TMR };
		return isInArray(str, ytdOrTodayOrTmr);
	}

	/**
	 * Accepts [last/this/next] [day] e.g. last mon, this tuesday, this Wed,
	 * next Thursday
	 */
	protected boolean isNaturalLanguageDate(String str1, String str2) {
		String[] lastOrThisOrNext = { Constants.LAST, Constants.THIS,
				Constants.NEXT };
		String[] days = { Constants.MONDAY, Constants.MON, Constants.TUESDAY,
				Constants.TUES, Constants.WEDNESDAY, Constants.WED,
				Constants.THURSDAY, Constants.THURS, Constants.FRIDAY,
				Constants.FRI, Constants.SATURDAY, Constants.SAT,
				Constants.SUNDAY, Constants.SUN };
		boolean isLastOrThisOrNext = isInArray(str1, lastOrThisOrNext);
		boolean isDay = isInArray(str2, days);
		return isLastOrThisOrNext && isDay;
	}

	/**
	 * Helper methods
	 */
	protected String getDayOfDayMonth(String dayMonth) {
		assert (isDayMonth(dayMonth)); // check done by isDayMonth

		String firstChar = dayMonth.substring(0, 1);
		String removeFirstChar = dayMonth.substring(1);
		String firstTwoChars = dayMonth.substring(0, 2);
		if (isInteger(firstChar) && getMonthInt(removeFirstChar) != -1) {
			return firstChar;
		} else {
			return firstTwoChars;
		}
	}

	protected String getMonthOfDayMonth(String dayMonth) {
		assert (isDayMonth(dayMonth)); // check done by isDayMonth

		String firstChar = dayMonth.substring(0, 1);
		String removeFirstChar = dayMonth.substring(1);
		String removeFirstTwoChars = dayMonth.substring(2);
		if (isInteger(firstChar) && getMonthInt(removeFirstChar) != -1) {
			return getMonthStr(removeFirstChar);
		} else {
			return getMonthStr(removeFirstTwoChars);
		}
	}

	protected String getMonthStr(String str) {
		return String.valueOf(getMonthInt(str));
	}

	private int getMonthInt(String str) {
		switch (str.toLowerCase()) {
		case Constants.JANUARY:
		case Constants.JAN:
			return 1;

		case Constants.FEBRUARY:
		case Constants.FEB:
			return 2;

		case Constants.MARCH:
		case Constants.MAR:
			return 3;

		case Constants.APRIL:
		case Constants.APR:
			return 4;

		case Constants.MAY:
			return 5;

		case Constants.JUNE:
		case Constants.JUN:
			return 6;

		case Constants.JULY:
		case Constants.JUL:
			return 7;

		case Constants.AUGUST:
		case Constants.AUG:
			return 8;

		case Constants.SEPTEMBER:
		case Constants.SEP:
			return 9;

		case Constants.OCTOBER:
		case Constants.OCT:
			return 10;

		case Constants.NOVEMBER:
		case Constants.NOV:
			return 11;

		case Constants.DECEMBER:
		case Constants.DEC:
			return 12;

		default:
			return -1;
		}
	}

	private String getCorrectYear(String day, String month) {
		LocalDateTime now = LocalDateTime.now();
		String year;
		if (Integer.parseInt(month) < now.getMonthValue()) {
			year = String.valueOf(now.plusYears(1).getYear());
		} else if (Integer.parseInt(month) == now.getMonthValue()
				&& Integer.parseInt(day) < now.getDayOfMonth()) {
			year = String.valueOf(now.plusYears(1).getYear());
		} else {
			year = String.valueOf(now.getYear());
		}
		return year;
	}

	private boolean isDayMonth(String str) {
		if (str.length() < 4) {
			return false;
		}

		String firstChar = str.substring(0, 1);
		String removeFirstChar = str.substring(1);
		String firstTwoChars = str.substring(0, 2);
		String removeFirstTwoChars = str.substring(2);

		if (isInteger(firstChar) && getMonthInt(removeFirstChar) != -1) {
			return true;
		} else if (isInteger(firstTwoChars)
				&& getMonthInt(removeFirstTwoChars) != -1) {
			return true;
		} else {
			return false;
		}
	}

	private boolean isLeapYear(int year) {
		return (year % 400 == 0) || ((year % 4 == 0) && (year % 100 != 0));
	}

	private boolean isInteger(String str) {
		try {
			Integer.parseInt(str);
			return true;
		} catch (NumberFormatException e) {
			return false;
		}
	}

	private boolean isInArray(String str, String[] array) {
		for (int i = 0; i < array.length; i++) {
			if (str.toLowerCase().equals(array[i])) {
				return true;
			}
		}
		return false;
	}

	private ArrayList<String> arrayToArrayList(String[] array) {
		ArrayList<String> arrayList = new ArrayList<String>();
		for (int i = 0; i < array.length; i++) {
			arrayList.add(array[i]);
		}
		return arrayList;
	}

}
```
###### parser\IndexParser.java
``` java
public class IndexParser {
	private ArrayList<String> args;

	public IndexParser(ArrayList<String> args) {
		this.args = args;
	}

	/**
	 * Checks if keyword is in args Returns index of first occurrence of keyword
	 * if true; Returns -1 if false
	 */
	protected int getIndexOfFirst(String keyword) {
		int index = -1;
		for (int i = 0; i < args.size(); i++) {
			if (args.get(i).toLowerCase().equals(keyword)) {
				index = i;
				break;
			}
		}
		return index;
	}

	/**
	 * Checks if keyword is in args Returns index of last occurrence of keyword
	 * if true; Returns -1 if false
	 */
	protected int getIndex(String keyword) {
		int index = -1;
		for (int i = 0; i < args.size(); i++) {
			if (args.get(i).toLowerCase().equals(keyword)) {
				index = i;
			}
		}
		return index;
	}

	/**
	 * Checks if keyword1 and keyword2 are adjacent elements in args Returns
	 * index of keyword1 if true; Returns -1 if false
	 */
	protected int getIndex(String keyword1, String keyword2) {
		int index = -1;
		for (int i = 0; i < args.size(); i++) {
			if (i + 1 < args.size() && 
					args.get(i).toLowerCase().equals(keyword1) && 
					args.get(i + 1).toLowerCase().equals(keyword2)) {
				index = i;
			}
		}
		return index;
	}

}
```
###### parser\NameParser.java
``` java
public class NameParser {
	private ArrayList<String> args;

	public NameParser(ArrayList<String> args) {
		this.args = args;
	}

	protected String getName(int stop) {
		String output = Constants.EMPTY;
		for (int i = 0; i < stop; i++) {
			output += args.get(i) + Constants.WHITESPACE;
		}
		return removeSlash(output.trim());
	}

	protected String getName(int start, int stop) {
		String output = Constants.EMPTY;
		for (int i = start; i < stop; i++) {
			output += args.get(i) + Constants.WHITESPACE;
		}
		return removeSlash(output.trim());
	}

	protected String getNameWithSlash(int stop) {
		String output = Constants.EMPTY;
		for (int i = 0; i < stop; i++) {
			output += args.get(i) + Constants.WHITESPACE;
		}
		return output.trim();
	}

	/**
	 * Removes slash character from every element in args
	 */
	protected ArrayList<String> removeSlash(ArrayList<String> args) {
		for (int i = 0; i < args.size(); i++) {
			args.set(i, removeSlash(args.get(i)));
		}
		return args;
	}

	private String removeSlash(String str) {
		return str.replace(Constants.SLASH, Constants.EMPTY);
	}

}
```
###### parser\Parser.java
``` java
public class Parser {
	private Logger logger = SharedLogger.getInstance().getLogger();
	private DateProcessor dateProcessor = new DateProcessor();
	private IndexParser indexParser;
	private NameParser nameParser;
	private DateParser dateParser;
	private TimeParser timeParser;

	private void refreshParsers(ArrayList<String> args) {
		indexParser = new IndexParser(args);
		nameParser = new NameParser(args);
		dateParser = new DateParser(args);
		timeParser = new TimeParser(args);
	}

	/**
	 * Takes in raw user input string Gets cmd (first word of string) Gets args
	 * (rest of string) Calls command handler function of cmd with args Returns
	 * AbstractCommand
	 */
	public AbstractCommand parseInput(String rawInput) {
		String[] argsArr = rawInput.split(Constants.SPLITTER_WHITESPACE);
		ArrayList<String> args = arrayToArrayList(argsArr);
		refreshParsers(args);

		try {
			String cmd = args.remove(0);
			switch (cmd.toLowerCase()) {
			case Constants.CMD_CREATE:
			case Constants.CMD_C:
			case Constants.CMD_ADD:
			case Constants.CMD_A:
				return create(args);

			case Constants.CMD_DISPLAY:
			case Constants.CMD_DP:
				return display(args);

			case Constants.CMD_DELETE:
			case Constants.CMD_DL:
				return delete(args);

			case Constants.CMD_EDIT:
			case Constants.CMD_E:
				return edit(args);

			case Constants.CMD_SEARCH:
			case Constants.CMD_S:
				return search(args);

			case Constants.CMD_MARK:
			case Constants.CMD_M:
				return mark(args, Constants.CMD_MARK);

			case Constants.CMD_UNMARK:
			case Constants.CMD_UM:
				return mark(args, Constants.CMD_UNMARK);

			case Constants.CMD_UNDO:
			case Constants.CMD_U:
				return undo(args);

			case Constants.CMD_SAVE:
				return save(args);

			case Constants.CMD_EXIT:
				return exit(args);

			case Constants.CMD_DAY:
			case Constants.CMD_NIGHT:
			case Constants.CMD_HELP:
				return uiOneWord(args);

			case Constants.CMD_HIDE:
			case Constants.CMD_SHOW:
			case Constants.CMD_QUIT:
				args.add(0, cmd);
				return uiTwoWords(args);

			default:
				return invalidCommand();
			}
		} catch (DateTimeParseException e) {
			return invalidCommand();
		}
	}

	private AbstractCommand create(ArrayList<String> args)
			throws DateTimeParseException {
		if (isAllDay(args)) {
			args = dateProcessor.processAllDay(args);
			refreshParsers(args);
			return createAllDay(args);
		} else if (isBounded(args)) {
			args = dateProcessor.processBounded(args);
			refreshParsers(args);
			return createBounded(args);
		} else if (isDeadline(args)) {
			args = dateProcessor.processDeadline(args);
			refreshParsers(args);
			return createDeadline(args);
		} else if (isFloating(args)) {
			return createFloating(args);
		} else {
			return invalidCommand();
		}
	}

	private AbstractCommand createFloating(ArrayList<String> args) {
		assert (isFloating(args)); // check done by isFloating

		logger.log(Level.INFO, "Creating CreateCommand for floating task");

		String name = nameParser.getName(args.size());
		return new CreateCommand(name);
	}

	private AbstractCommand createDeadline(ArrayList<String> args)
			throws DateTimeParseException {
		assert (isDeadline(args)); // check done by isDeadline

		int index = indexParser.getIndex(Constants.KEYWORD_BY);
		String time = timeParser.getTime(index, args.size());
		String date = dateParser.getDate(index, args.size());
		String dateTimeStr = date + Constants.WHITESPACE + time;

		logger.log(Level.INFO, "Creating CreateCommand for deadline task");

		String name = nameParser.getName(index);
		LocalDateTime dateTime = getDateTime(dateTimeStr);
		return new CreateCommand(name, dateTime);
	}

	private AbstractCommand createBounded(ArrayList<String> args)
			throws DateTimeParseException {
		assert (isBounded(args)); // check done by isBounded

		int sIndex = indexParser.getIndex(Constants.KEYWORD_FROM);
		int eIndex = indexParser.getIndex(Constants.KEYWORD_TO);
		String sTime = timeParser.getTime(sIndex, eIndex);
		String sDate = dateParser.getDate(sIndex, eIndex);
		String eTime = timeParser.getTime(eIndex, args.size());
		String eDate = dateParser.getDate(eIndex, args.size());
		String sDateTimeStr = sDate + Constants.WHITESPACE + sTime;
		String eDateTimeStr = eDate + Constants.WHITESPACE + eTime;

		logger.log(Level.INFO, "Creating CreateCommand for bounded task");

		String name = nameParser.getName(sIndex);
		LocalDateTime sDateTime = getDateTime(sDateTimeStr);
		LocalDateTime eDateTime = getDateTime(eDateTimeStr);
		return new CreateCommand(name, sDateTime, eDateTime);
	}

	private AbstractCommand createAllDay(ArrayList<String> args)
			throws DateTimeParseException {
		assert (isAllDay(args)); // check done by isAllDay

		int index = indexParser.getIndex(Constants.KEYWORD_ON);
		String date = dateParser.getDate(index, args.size());
		String sDateTimeStr = date + Constants.WHITESPACE
				+ Constants.DUMMY_TIME_S;
		String eDateTimeStr = date + Constants.WHITESPACE
				+ Constants.DUMMY_TIME_E;

		logger.log(Level.INFO, "Creating CreateCommand for bounded task");

		String name = nameParser.getName(index);
		LocalDateTime sDateTime = getDateTime(sDateTimeStr);
		LocalDateTime eDateTime = getDateTime(eDateTimeStr);
		return new CreateCommand(name, sDateTime, eDateTime);
	}

	private AbstractCommand display(ArrayList<String> args)
			throws DateTimeParseException {
		if (args.isEmpty()) {
			logger.log(Level.INFO, "Creating DisplayCommand for default view");
			return new DisplayCommand(DisplayCommand.Scope.DEFAULT);
		}

		String firstWord = args.get(0).toLowerCase();
		boolean oneWord = args.size() == 1;
		boolean isAll = firstWord.equals(Constants.SCOPE_ALL) && oneWord;
		boolean isDone = (firstWord.equals(Constants.SCOPE_DONE) || 
				firstWord.equals(Constants.CMD_MARK)) && oneWord;
		boolean isUndone = (firstWord.equals(Constants.SCOPE_UNDONE) || 
				firstWord.equals(Constants.CMD_UNMARK)) && oneWord;
		boolean isFloating = firstWord.equals(Constants.SCOPE_FLOATING)
				&& oneWord;

		if (isAll) {
			logger.log(Level.INFO, "Creating DisplayCommand for all view");
			return new DisplayCommand(DisplayCommand.Scope.ALL);
		} else if (isDone) {
			logger.log(Level.INFO, "Creating DisplayCommand for done view");
			return new DisplayCommand(DisplayCommand.Scope.DONE);
		} else if (isUndone) {
			logger.log(Level.INFO, "Creating DisplayCommand for undone view");
			return new DisplayCommand(DisplayCommand.Scope.UNDONE);
		} else if (isFloating) {
			logger.log(Level.INFO, "Creating DisplayCommand for floating view");
			return new DisplayCommand(DisplayCommand.Scope.FLOATING);
		} else {
			return search(args);
		}
	}

	private AbstractCommand search(ArrayList<String> args)
			throws DateTimeParseException {
		if (args.isEmpty()) {
			logger.log(Level.INFO, "Creating DisplayCommand for default view");
			return new DisplayCommand(DisplayCommand.Scope.DEFAULT);
		}

		int dateIndex = dateParser.getDateIndex(0, args.size());
		boolean isDate = dateIndex != -1
				&& dateProcessor.processDate(args, dateIndex).size() == 1;

		if (isDate) {
			args = dateProcessor.processDate(args, dateIndex);
			String date = dateParser.getDate(args.get(dateIndex));
			String dateTimeStr = date + Constants.WHITESPACE
					+ Constants.DUMMY_TIME_S;
			logger.log(Level.INFO, "Creating DisplayCommand by search date");
			return new DisplayCommand(getDateTime(dateTimeStr));
		} else {
			args = nameParser.removeSlash(args);
			logger.log(Level.INFO, "Creating DisplayCommand by search keyword");
			return new DisplayCommand(args);
		}
	}

	private AbstractCommand delete(ArrayList<String> args) {
		if (args.isEmpty()) {
			return invalidCommand();
		}

		String firstWord = args.get(0).toLowerCase();
		boolean oneWord = args.size() == 1;
		boolean isAll = firstWord.equals(Constants.SCOPE_ALL) && oneWord;
		boolean isIndex = isPositiveInteger(firstWord) && oneWord;

		if (isAll) {
			logger.log(Level.INFO, "Creating DeleteCommand for all");
			return new DeleteCommand(DeleteCommand.Scope.ALL);
		} else if (isIndex) {
			logger.log(Level.INFO, "Creating DeleteCommand by index");
			return new DeleteCommand(Integer.parseInt(firstWord));
		} else {
			logger.log(Level.INFO, "Creating DeleteCommand by search keyword");
			return new DeleteCommand(nameParser.getName(args.size()));
		}
	}

	private AbstractCommand edit(ArrayList<String> args) {
		if (args.isEmpty()) {
			return invalidCommand();
		}

		EditCommand output;
		ArrayList<EditCommand.editField> editType = new ArrayList<EditCommand.editField>();

		// pre-process "start to" to "start" and "end to" to "end"
		int sIndex = indexParser.getIndex(Constants.KEYWORD_START,
				Constants.KEYWORD_TO);
		if (sIndex != -1) {
			args.remove(sIndex + 1);
		}
		int eIndex = indexParser.getIndex(Constants.KEYWORD_END,
				Constants.KEYWORD_TO);
		if (eIndex != -1) {
			args.remove(eIndex + 1);
		}
		int toIndex = indexParser.getIndexOfFirst(Constants.KEYWORD_TO);

		// index 0 to index endPointOldName (non-inclusive)
		// forms old task name
		int endPointOldName = getEndPointOldName(toIndex, sIndex, eIndex,
				args.size());

		// index startPointName to index endPointName (non-inclusive)
		// forms new task name
		int endPointName = getEndPointName(sIndex, eIndex, args.size());
		int startPointName = getStartPointName(toIndex, endPointName);

		// index sIndex to index endPointStart (non-inclusive)
		// forms range for new start datetime
		int endPointStart = getEndPointStart(eIndex, args.size());

		// find search index or search keyword
		String search = nameParser.getNameWithSlash(endPointOldName);
		if (isPositiveInteger(search)) {
			output = new EditCommand(Integer.parseInt(search));
		} else {
			output = new EditCommand(nameParser.getName(endPointOldName));
		}

		// edit name
		String newName = nameParser.getName(startPointName, endPointName);
		if (newName.length() != 0) {
			editType.add(EditCommand.editField.NAME);
			output.setNewName(newName);
		}

		if (sIndex != -1) {

			// edit start time
			int indexOfsTime = timeParser.getTimeIndex(sIndex, endPointStart);
			if (indexOfsTime != -1) {
				String sTime = timeParser.getTime(args.get(indexOfsTime));
				editType.add(EditCommand.editField.START_TIME);
				output.setNewStartTime(sTime);
			}

			// edit start date
			int indexOfsDate = dateParser.getDateIndex(sIndex, endPointStart);
			if (indexOfsDate != -1) {
				args = dateProcessor.processDate(args, indexOfsDate);
				refreshParsers(args);
				String sDate = dateParser.getDate(args.get(indexOfsDate));
				editType.add(EditCommand.editField.START_DATE);
				output.setNewStartDate(sDate);
			}

		}

		if (eIndex != -1) {

			// edit end time
			int indexOfeTime = timeParser.getTimeIndex(eIndex, args.size());
			if (indexOfeTime != -1) {
				String eTime = timeParser.getTime(args.get(indexOfeTime));
				editType.add(EditCommand.editField.END_TIME);
				output.setNewEndTime(eTime);
			}

			// edit end date
			int indexOfeDate = dateParser.getDateIndex(eIndex, args.size());
			if (indexOfeDate != -1) {
				args = dateProcessor.processDate(args, indexOfeDate);
				refreshParsers(args);
				String eDate = dateParser.getDate(args.get(indexOfeDate));
				editType.add(EditCommand.editField.END_DATE);
				output.setNewEndDate(eDate);
			}

		}

		if (editType.isEmpty() && 
				output.getType().equals(EditCommand.Type.SEARCHKEYWORD)) {
			return invalidCommand();
		} else {
			logger.log(Level.INFO, "Creating EditCommand");
			output.setEditFields(editType);
			return output;
		}
	}

	private AbstractCommand mark(ArrayList<String> args, String field) {
		if (args.isEmpty()) {
			return invalidCommand();
		}

		MarkCommand output;

		String firstWord = args.get(0).toLowerCase();
		boolean oneWord = args.size() == 1;
		boolean isIndex = isPositiveInteger(firstWord) && oneWord;

		if (isIndex) {
			logger.log(Level.INFO, "Creating MarkCommand by index");
			output = new MarkCommand(Integer.parseInt(firstWord));
		} else {
			logger.log(Level.INFO, "Creating MarkCommand by search keyword");
			output = new MarkCommand(nameParser.getName(args.size()));
		}

		if (field.equals(Constants.CMD_MARK)) {
			output.setMarkField(MarkCommand.markField.MARK);
		} else if (field.equals(Constants.CMD_UNMARK)) {
			output.setMarkField(MarkCommand.markField.UNMARK);
		} else {
			return invalidCommand();
		}

		return output;
	}

	private AbstractCommand undo(ArrayList<String> args) {
		if (args.isEmpty()) {
			logger.log(Level.INFO, "Creating UndoCommand");
			return new UndoCommand();
		} else {
			return invalidCommand();
		}
	}

	private AbstractCommand save(ArrayList<String> args) {
		if (args.size() != 1) {
			return invalidCommand();
		} else {
			logger.log(Level.INFO, "Creating SaveCommand");
			String firstWord = args.get(0);
			return new SaveCommand(firstWord);
		}
	}

	private AbstractCommand exit(ArrayList<String> args) {
		if (args.size() != 0) {
			return invalidCommand();
		} else {
			logger.log(Level.INFO, "Creating ExitCommand");
			return new ExitCommand();
		}
	}

	private AbstractCommand uiOneWord(ArrayList<String> args) {
		if (args.size() != 0) {
			return invalidCommand();
		} else {
			logger.log(Level.INFO, "Creating UICommand");
			return new UICommand();
		}
	}

	private AbstractCommand uiTwoWords(ArrayList<String> args) {
		if (args.size() != 2) {
			return invalidCommand();
		}

		String firstWord = args.get(0);
		String secondWord = args.get(1);
		boolean isHideOrShowYear = (firstWord.equals(Constants.CMD_HIDE) || 
				firstWord.equals(Constants.CMD_SHOW)) && 
				secondWord.equals(Constants.CMD_YEAR);
		boolean isQuitHelp = firstWord.equals(Constants.CMD_QUIT) && 
				secondWord.equals(Constants.CMD_HELP);

		if (isHideOrShowYear || isQuitHelp) {
			logger.log(Level.INFO, "Creating UICommand");
			return new UICommand();
		} else {
			return invalidCommand();
		}
	}

	private AbstractCommand invalidCommand() {
		logger.log(Level.INFO, "Creating InvalidCommand");
		return new InvalidCommand();
	}

	
	
	/**
	 * Boolean methods to check task type
	 */
	private boolean isFloating(ArrayList<String> args) {
		return !args.isEmpty();
	}

	private boolean isDeadline(ArrayList<String> args) {
		int index = indexParser.getIndex(Constants.KEYWORD_BY);

		if (index == -1) {
			return false;
		} else {
			String name = nameParser.getName(index);
			int timeIndex = timeParser.getTimeIndex(index, args.size());
			int dateIndex = dateParser.getDateIndex(index, args.size());

			if ((name.length() != 0) && (timeIndex != -1) && (dateIndex != -1)) {
				ArrayList<String> argsCopy = dateProcessor.processDeadline(args);
				return argsCopy.size() == index + Constants.NUM_AFTER_BY;
			} else {
				return false;
			}
		}
	}

	private boolean isBounded(ArrayList<String> args) {
		int sIndex = indexParser.getIndex(Constants.KEYWORD_FROM);
		int eIndex = indexParser.getIndex(Constants.KEYWORD_TO);

		if (sIndex == -1 || eIndex == -1) {
			return false;
		} else {
			String name = nameParser.getName(sIndex);
			int sTimeIndex = timeParser.getTimeIndex(sIndex, eIndex);
			int sDateIndex = dateParser.getDateIndex(sIndex, eIndex);
			int eTimeIndex = timeParser.getTimeIndex(eIndex, args.size());
			int eDateIndex = dateParser.getDateIndex(eIndex, args.size());

			if ((name.length() != 0) && 
					(sTimeIndex != -1) && (eTimeIndex != -1) &&
					(sDateIndex != -1 || eDateIndex != -1)) {
				ArrayList<String> argsCopy = dateProcessor.processBounded(args);
				IndexParser indexParserCopy = new IndexParser(argsCopy);
				sIndex = indexParserCopy.getIndex(Constants.KEYWORD_FROM);
				eIndex = indexParserCopy.getIndex(Constants.KEYWORD_TO);
				return argsCopy.size() == eIndex + Constants.NUM_AFTER_TO
						&& eIndex - sIndex == Constants.NUM_BETWEEN_FROM_TO;
			} else {
				return false;
			}
		}
	}

	private boolean isAllDay(ArrayList<String> args) {
		int index = indexParser.getIndex(Constants.KEYWORD_ON);

		if (index == -1) {
			return false;
		} else {
			String name = nameParser.getName(index);
			int dateIndex = dateParser.getDateIndex(index, args.size());

			if ((name.length() != 0) && (dateIndex != -1)) {
				ArrayList<String> argsCopy = dateProcessor.processAllDay(args);
				return argsCopy.size() == index + Constants.NUM_AFTER_ON;
			} else {
				return false;
			}
		}
	}

	
	
	/**
	 * Helper methods for command handler function edit
	 */
	private int getEndPointOldName(int toIndex, int sIndex, int eIndex,
			int maxIndex) {
		if (toIndex != -1) {
			return toIndex;
		} else if (sIndex != -1) {
			return sIndex;
		} else if (eIndex != -1) {
			return eIndex;
		} else {
			return maxIndex;
		}
	}

	private int getStartPointName(int toIndex, int endPointName) {
		if (toIndex == -1) {
			return endPointName;
		} else {
			return toIndex + 1;
		}
	}

	private int getEndPointName(int sIndex, int eIndex, int maxIndex) {
		if (sIndex != -1) {
			return sIndex;
		} else if (eIndex != -1) {
			return eIndex;
		} else {
			return maxIndex;
		}
	}

	private int getEndPointStart(int eIndex, int maxIndex) {
		if (eIndex != -1) {
			return eIndex;
		} else {
			return maxIndex;
		}
	}

	
	
	/**
	 * Helper methods
	 */
	private boolean isPositiveInteger(String str) {
		try {
			int integer = Integer.parseInt(str);
			return integer > 0;
		} catch (NumberFormatException e) {
			return false;
		}
	}

	private LocalDateTime getDateTime(String dateTimeStr) {
		return LocalDateTime.parse(dateTimeStr, Constants.DTFormatter);
	}

	private ArrayList<String> arrayToArrayList(String[] array) {
		ArrayList<String> arrayList = new ArrayList<String>();
		for (int i = 0; i < array.length; i++) {
			arrayList.add(array[i]);
		}
		return arrayList;
	}

}
```
###### parser\TimeParser.java
``` java
public class TimeParser {
	DateTimeChecker dtChecker = new DateTimeChecker();
	private ArrayList<String> args;

	public TimeParser(ArrayList<String> args) {
		this.args = args;
	}

	protected int getTimeIndex(int start, int end) {
		for (int i = start; i < end; i++) {
			if (dtChecker.isTime(args.get(i))) {
				return i;
			}
		}
		return -1;
	}

	protected String getTime(int start, int end) {
		int timeIndex = getTimeIndex(start, end);
		String time = args.get(timeIndex);
		return getTime(time);
	}

	protected String getTime(String time) {
		time = time.toLowerCase();
		assert (dtChecker.isTime(time));

		int hourInInt = getHour(time);
		int minuteInInt = getMinute(time);
		String AMPM = getAMPM(time);

		if (AMPM.equals(Constants.PM) && hourInInt != 12) {
			hourInInt += 12;
		}
		if (AMPM.equals(Constants.AM) && hourInInt == 12) {
			hourInInt = 0;
		}

		String hour = String.format(Constants.FORMATTER_2DP, hourInInt);
		String minute = String.format(Constants.FORMATTER_2DP, minuteInInt);
		return hour + Constants.WHITESPACE + minute;
	}

	/**
	 * Helper methods
	 */
	private int getHour(String time) {
		assert (dtChecker.isTime(time));

		time = time.replace(Constants.AM, Constants.EMPTY);
		time = time.replace(Constants.PM, Constants.EMPTY);
		if (time.contains(Constants.COLON)) {
			String[] timeParts = time.split(Constants.SPLITTER_COLON);
			return Integer.parseInt(timeParts[0]);
		} else if (time.contains(Constants.DOT)) {
			String[] timeParts = time.split(Constants.SPLITTER_DOT);
			return Integer.parseInt(timeParts[0]);
		} else {
			return Integer.parseInt(time);
		}
	}

	private int getMinute(String time) {
		assert (dtChecker.isTime(time));

		time = time.replace(Constants.AM, Constants.EMPTY);
		time = time.replace(Constants.PM, Constants.EMPTY);
		if (time.contains(Constants.COLON)) {
			String[] timeParts = time.split(Constants.SPLITTER_COLON);
			return Integer.parseInt(timeParts[1]);
		} else if (time.contains(Constants.DOT)) {
			String[] timeParts = time.split(Constants.SPLITTER_DOT);
			return Integer.parseInt(timeParts[1]);
		} else {
			return 0;
		}
	}

	private String getAMPM(String time) {
		assert (dtChecker.isTime(time));

		if (time.contains(Constants.AM)) {
			return Constants.AM;
		} else if (time.contains(Constants.PM)) {
			return Constants.PM;
		} else {
			return Constants.EMPTY;
		}
	}

}
```
###### shared\command\ExitCommand.java
``` java
public class ExitCommand extends AbstractCommand {

	private String undoMessage = "\"exit\" action cannot be undone!";

	public String getUndoMessage() {
		return undoMessage;
	}

	public CmdType getCmdType() {
		return CmdType.EXIT;
	}

	@Override
	public boolean equals(Object obj) {
		if (!(obj instanceof ExitCommand)) {
			return false;
		} else {
			return true;
		}
	}
}
```
###### shared\command\InvalidCommand.java
``` java
public class InvalidCommand extends AbstractCommand {
	private String undoMessage = "\"invalid\" action cannot be undone!";

	public String getUndoMessage() {
		return undoMessage;
	}

	public CmdType getCmdType() {
		return CmdType.INVALID;
	}

	@Override
	public boolean equals(Object obj) {
		if (!(obj instanceof InvalidCommand)) {
			return false;
		} else {
			return true;
		}
	}
}
```
###### shared\command\MarkCommand.java
``` java
public class MarkCommand extends AbstractCommand {

	private markField markField;
	private Type type;
	private int index;
	private String searchKeyword;
	private String undoMessage = "\"mark\" action has been undone!";

	public static enum markField {
		MARK, UNMARK;
	}

	public static enum Type {
		INDEX, SEARCHKEYWORD;
	}

	public MarkCommand(int index) {
		this.type = Type.INDEX;
		this.index = index;
	}

	public MarkCommand(String searchKeyword) {
		this.type = Type.SEARCHKEYWORD;
		this.searchKeyword = searchKeyword;
	}

	public void setMarkField(markField markField) {
		this.markField = markField;
	}

	public markField getMarkField() {
		return this.markField;
	}

	public Type getType() {
		return this.type;
	}

	public int getIndex() {
		return this.index;
	}

	public String getSearchKeyword() {
		return this.searchKeyword;
	}

	public String getUndoMessage() {
		return undoMessage;
	}

	public CmdType getCmdType() {
		return CmdType.MARK;
	}

	@Override
	public boolean equals(Object obj) {
		if (!(obj instanceof MarkCommand)) {
			return false;
		} else {
			MarkCommand that = (MarkCommand) obj;
			return this.getType().equals(that.getType())
					&& this.getIndex() == that.getIndex()
					&& Objects.equals(this.getSearchKeyword(),
							that.getSearchKeyword())
					&& Objects.equals(this.getMarkField(), that.getMarkField());
		}
	}
}
```
###### shared\command\SaveCommand.java
``` java
public class SaveCommand extends AbstractCommand {

	private String path;
	private String undoMessage = "\"save\" action cannot be undone!";

	public SaveCommand(String path) {
		this.path = path;
	}

	public String getPath() {
		return this.path;
	}

	public String getUndoMessage() {
		return undoMessage;
	}

	public CmdType getCmdType() {
		return CmdType.SAVE;
	}

	@Override
	public boolean equals(Object obj) {
		if (!(obj instanceof SaveCommand)) {
			return false;
		} else {
			SaveCommand that = (SaveCommand) obj;
			return Objects.equals(this.getPath(), that.getPath());
		}
	}
}
```
###### shared\command\UICommand.java
``` java
public class UICommand extends AbstractCommand {
	private String undoMessage = "\"UI\" action cannot be undone!";

	public String getUndoMessage() {
		return undoMessage;
	}

	public CmdType getCmdType() {
		return CmdType.UI;
	}

	@Override
	public boolean equals(Object obj) {
		return (obj instanceof UICommand);
	}
}
```
###### shared\command\UndoCommand.java
``` java
public class UndoCommand extends AbstractCommand {
	private String undoMessage = "\"undo\" action cannot be undone!";

	public String getUndoMessage() {
		return undoMessage;
	}

	public CmdType getCmdType() {
		return CmdType.UNDO;
	}

	@Override
	public boolean equals(Object obj) {
		if (!(obj instanceof UndoCommand)) {
			return false;
		} else {
			return true;
		}
	}
}
```
###### shared\Constants.java
``` java
	// Parser constants
	/**
   * Formatter constants
   */
	public static final DateTimeFormatter DTFormatter =  DateTimeFormatter.ofPattern("dd MM yyyy HH mm");
	public static final String FORMATTER_2DP = "%02d";
	
	/**
   * Command constants
   */
	public static final String CMD_CREATE = "create";
	public static final String CMD_C = "c";
	public static final String CMD_ADD = "add";
	public static final String CMD_A = "a";
	public static final String CMD_DISPLAY = "display";
	public static final String CMD_DP = "dp";
	public static final String CMD_DELETE = "delete";
	public static final String CMD_DL = "dl";
	public static final String CMD_EDIT = "edit";
	public static final String CMD_E = "e";
	public static final String CMD_SEARCH = "search";
	public static final String CMD_S = "s";
	public static final String CMD_MARK = "mark";
	public static final String CMD_M = "m";
	public static final String CMD_UNMARK = "unmark";
	public static final String CMD_UM = "um";
	public static final String CMD_UNDO = "undo";
	public static final String CMD_U = "u";
	public static final String CMD_SAVE = "save";
	public static final String CMD_EXIT = "exit";
	public static final String CMD_DAY = "day";
	public static final String CMD_NIGHT = "night";
	public static final String CMD_HIDE = "hide";
	public static final String CMD_SHOW = "show";
	public static final String CMD_YEAR = "year";
	public static final String CMD_HELP = "help";
	public static final String CMD_QUIT = "quit";
	
	/**
   * Scope constants
   */
	public static final String SCOPE_ALL = "all";
	public static final String SCOPE_DONE = "done";
	public static final String SCOPE_UNDONE = "undone";
	public static final String SCOPE_FLOATING = "floating";
	
	/**
   * Keyword constants
   */
	public static final String KEYWORD_BY = "by";
	public static final String KEYWORD_FROM = "from";
	public static final String KEYWORD_TO = "to";
	public static final String KEYWORD_ON = "on";
	public static final String KEYWORD_START = "start";
	public static final String KEYWORD_END = "end";
	
	public static final int NUM_AFTER_BY = 3;
	public static final int NUM_AFTER_ON = 2;
	public static final int NUM_AFTER_TO = 3;
	public static final int NUM_BETWEEN_FROM_TO = 3;
	
	/**
   * Splitter constants
   */
	public static final String SPLITTER_DATE = "(-|\\/|\\s)";
	public static final String SPLITTER_WHITESPACE = " ";
	public static final String SPLITTER_COLON = ":";
	public static final String SPLITTER_DOT = "\\.";
  
	/**
   * Date constants
   */
	public static final String YESTERDAY = "yesterday";
	public static final String YTD = "ytd";
	public static final String TODAY = "today";
	public static final String TONIGHT = "tonight";
	public static final String TOMORROW = "tomorrow";
	public static final String TMR = "tmr";
	
	public static final String LAST = "last";
	public static final String THIS = "this";
	public static final String NEXT = "next";
	
	public static final String MONDAY = "monday";
	public static final String MON = "mon";
	public static final String TUESDAY = "tuesday";
	public static final String TUES = "tues";
	public static final String WEDNESDAY = "wednesday";
	public static final String WED = "wed";
	public static final String THURSDAY = "thursday";
	public static final String THURS = "thurs";
	public static final String FRIDAY= "friday";
	public static final String FRI = "fri";
	public static final String SATURDAY = "saturday";
	public static final String SAT = "sat";
	public static final String SUNDAY= "sunday";
	public static final String SUN = "sun";
	
	public static final String JANUARY = "january";
	public static final String JAN = "jan";
	public static final String FEBRUARY = "february";
	public static final String FEB = "feb";
	public static final String MARCH = "march";
	public static final String MAR = "mar";
	public static final String APRIL = "april";
	public static final String APR = "apr";
	public static final String MAY = "may";
	public static final String JUNE = "june";
	public static final String JUN = "jun";
	public static final String JULY = "july";
	public static final String JUL = "jul";
	public static final String AUGUST = "august";
	public static final String AUG = "aug";
	public static final String SEPTEMBER = "september";
	public static final String SEP = "sep";
	public static final String OCTOBER = "october";
	public static final String OCT = "oct";
	public static final String NOVEMBER = "november";
	public static final String NOV = "nov";
	public static final String DECEMBER = "december";
	public static final String DEC = "dec";
	
	/**
   * Time constants
   */
	public static final String TIME_FORMAT_1 = "(0[1-9]|[1-9]|1[012])(:|.)[0-5][0-9](?i)(am|pm)";
	public static final String TIME_FORMAT_2 = "(1[012]|[1-9])(?i)(am|pm)";
	
	public static final String TIME_INTEGER = "0|00|(^[0-9]*[1-9][0-9]*$)";
	
	public static final String DUMMY_TIME_S = "00 00";
	public static final String DUMMY_TIME_E = "23 59";
	
	public static final String AM = "am";
	public static final String PM = "pm";
	
	/**
   * General constants
   */
	public static final String EMPTY = "";
	public static final String WHITESPACE = " ";
	public static final String SLASH = "/";
	public static final String COLON = ":";
	public static final String DOT = ".";
	// Parser constants ends
	
	
	
```
###### shared\SharedLogger.java
``` java
public class SharedLogger {
	
	private static Logger logger = Logger.getLogger(SharedLogger.class.getName());

	public Logger getLogger() {
		return logger;
	}
	
	private static SharedLogger instance = null;
	
	public static SharedLogger getInstance() {
		try {
			if(instance == null) {
				prepareLogger();
        instance = new SharedLogger();
  		 }
  		 return instance;
		 } catch (SecurityException e) {
				System.out.println("A security violation has occurred: " + e.getMessage());
				return null;
			} catch (IOException e) {
				System.out.println("The log file is not found: " + e.getMessage());
				return null;
			}
   }
  
   private static void prepareLogger() throws SecurityException, IOException {
  	 FileHandler fileHandler = new FileHandler("log.txt");
  	 fileHandler.setFormatter(new SimpleFormatter());
  	 logger.addHandler(fileHandler);
  	 logger.setUseParentHandlers(false);
   }
   
}
```
###### test\ParserTest.java
``` java
public class ParserTest {

	Parser parser = new Parser();

	InvalidCommand expectedInvalid = new InvalidCommand();

	String dummyTime = "00 00";
	LocalDateTime currentDate = LocalDateTime.now();
	LocalDateTime currentMon = LocalDateTime.now().with(DayOfWeek.MONDAY);

	private String stringify(LocalDateTime date) {
		return String.format("%02d", date.getDayOfMonth()) + " "
				+ String.format("%02d", date.getMonthValue()) + " "
				+ date.getYear();
	}

	private LocalDateTime getDateTime(String dateTimeStr) {
		return LocalDateTime.parse(dateTimeStr, Constants.DTFormatter);
	}

	private String getCorrectYear(String str) {
		LocalDateTime dt = LocalDateTime.now();
		String[] strParts = str.split(" ");
		String day = strParts[0];
		String month = strParts[1];
		String year;

		if (Integer.parseInt(month) < dt.getMonthValue()) {
			year = String.valueOf(dt.plusYears(1).getYear());
		} else if (Integer.parseInt(month) == dt.getMonthValue()
				&& Integer.parseInt(day) < dt.getDayOfMonth()) {
			year = String.valueOf(dt.plusYears(1).getYear());
		} else {
			year = String.valueOf(dt.getYear());
		}

		return year;
	}

	// *******************************************************************
	// *******************************************************************
	// FOR CREATE COMMAND
	// *******************************************************************
	// *******************************************************************

	// ===================================================================
	// STANDARD CREATE TESTS
	// ===================================================================

	@Test
	public void createFTOneWordName() {
		String input = "create lecture!";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("lecture!");
		assertEquals(expected, output);
	}

	@Test
	public void cFTManyWordsName() {
		String input = "c buy apples, oranges and starfruits";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"buy apples, oranges and starfruits");
		assertEquals(expected, output);
	}

	@Test
	public void cDTOneWordName() {
		String input = "c lecture by 12:10pm 10-10-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("lecture",
				getDateTime("10 10 2015 12 10"));
		assertEquals(expected, output);
	}

	@Test
	public void createDTManyWordsName() {
		String input = "create buy apples, oranges and starfruits by 12pm 28/2/2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"buy apples, oranges and starfruits",
				getDateTime("28 02 2015 12 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createBTOneWordName() {
		String input = "create lecture from 21/10/2015 12PM to 2:19PM 1-11-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("lecture",
				getDateTime("21 10 2015 12 00"),
				getDateTime("01 11 2015 14 19"));
		assertEquals(expected, output);
	}

	@Test
	public void cBTManyWordsName() {
		String input = "c buy apples, oranges and starfruits from 12am 11-11-2015 to 12-12-2015 0:17";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"buy apples, oranges and starfruits",
				getDateTime("11 11 2015 00 00"),
				getDateTime("12 12 2015 00 17"));
		assertEquals(expected, output);
	}

	@Test
	public void cBTAllDayOneWordName() {
		String input = "create chalet on 9/9/2016";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("chalet",
				getDateTime("09 09 2016 " + Constants.DUMMY_TIME_S),
				getDateTime("09 09 2016 " + Constants.DUMMY_TIME_E));
		assertEquals(expected, output);
	}

	@Test
	public void createBTAllDayManyWordsName() {
		String input = "create wedding day on 7-11";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("wedding day",
				getDateTime("07 11 " + getCorrectYear("07 11") + " "
						+ Constants.DUMMY_TIME_S), 
				getDateTime("07 11 " + getCorrectYear("07 11") + " "
						+ Constants.DUMMY_TIME_E));
		assertEquals(expected, output);
	}

	@Test
	public void createBTAllDayToday() {
		String input = "create workshop on today";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("workshop",
				getDateTime(stringify(currentDate) + " "
						+ Constants.DUMMY_TIME_S),
				getDateTime(stringify(currentDate) + " "
						+ Constants.DUMMY_TIME_E));
		assertEquals(expected, output);
	}

	@Test
	public void createBTAllDayNextWed() {
		String input = "create gss sale on next wed";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("gss sale",
				getDateTime(stringify(currentMon.plusWeeks(1).plusDays(2))
						+ " " + Constants.DUMMY_TIME_S),
				getDateTime(stringify(currentMon.plusWeeks(1).plusDays(2))
						+ " " + Constants.DUMMY_TIME_E));
		assertEquals(expected, output);
	}

	@Test
	public void createBTAllDayMonthInEng1() {
		String input = "create zoukout on 22 nov 2016";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("zoukout",
				getDateTime("22 11 2016 " + Constants.DUMMY_TIME_S),
				getDateTime("22 11 2016 " + Constants.DUMMY_TIME_E));
		assertEquals(expected, output);
	}

	@Test
	public void createBTAllDayMonthInEng2() {
		String input = "create 21st birthday on 13dec";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("21st birthday",
				getDateTime("13 12 " + getCorrectYear("13 12") + " "
						+ Constants.DUMMY_TIME_S), 
				getDateTime("13 12 " + getCorrectYear("13 12") + " "
						+ Constants.DUMMY_TIME_E));
		assertEquals(expected, output);
	}

	@Test
	public void createDTSplitName() {
		String input = "create merging sentence by 9am today over here";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"merging sentence by 9am today over here");
		assertEquals(expected, output);
	}

	@Test
	public void createBTSplitName1() {
		String input = "create lecture from today random 3pm to 6pm";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"lecture from today random 3pm to 6pm");
		assertEquals(expected, output);
	}

	@Test
	public void createBTSplitName2() {
		String input = "create lecture from today 3pm to 6pm random";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"lecture from today 3pm to 6pm random");
		assertEquals(expected, output);
	}

	@Test
	public void createBTSplitName3() {
		String input = "create lecture from 3pm 22nov 2016 to 6pm random";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"lecture from 3pm 22nov 2016 to 6pm random");
		assertEquals(expected, output);
	}

	@Test
	public void createBTSplitName4() {
		String input = "create lecture from 3pm 22nov 2016 random to 6pm";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"lecture from 3pm 22nov 2016 random to 6pm");
		assertEquals(expected, output);
	}

	@Test
	public void createBTAllDaySplitName() {
		String input = "create chalet on hello 7-11 hello";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("chalet on hello 7-11 hello");
		assertEquals(expected, output);
	}

	@Test
	public void createFTNoName() {
		String input = "create";
		AbstractCommand output = parser.parseInput(input);
		assertEquals(expectedInvalid, output);
	}

	@Test
	public void createDTNoName() {
		String input = "create by 12pm 10-10-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("by 12pm 10-10-2015");
		assertEquals(expected, output);
	}

	@Test
	public void createBTNoName() {
		String input = "create from 12pm 10-10-2015 to 2pm 10-10-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"from 12pm 10-10-2015 to 2pm 10-10-2015");
		assertEquals(expected, output);
	}

	@Test
	public void createFTWhitespace() {
		String input = "create   ";
		AbstractCommand output = parser.parseInput(input);
		assertEquals(expectedInvalid, output);
	}

	// ===================================================================
	// CREATE WITH DIFFERENT TIME FORMATS
	// ===================================================================

	@Test
	public void createValidTime1() {
		String input = "create example by 8am 06-7-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example",
				getDateTime("06 07 2015 08 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createValidTime2() {
		String input = "create example from 12AM 4-4-2015 to 10pm 5-04-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example",
				getDateTime("04 04 2015 00 00"),
				getDateTime("05 04 2015 22 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createValidTime3() {
		String input = "create example by 9PM 03-03-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example",
				getDateTime("03 03 2015 21 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createValidTime4() {
		String input = "create example by 12:30am 8-12-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example",
				getDateTime("08 12 2015 00 30"));
		assertEquals(expected, output);
	}

	@Test
	public void createValidTime5() {
		String input = "create example from 06:30AM 05-1-2015 to 7:15pm 10-02-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example",
				getDateTime("05 01 2015 06 30"),
				getDateTime("10 02 2015 19 15"));
		assertEquals(expected, output);
	}

	@Test
	public void createValidTime6() {
		String input = "create example by 11:48PM 25-09-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example",
				getDateTime("25 09 2015 23 48"));
		assertEquals(expected, output);
	}

	@Test
	public void createValidTime7() {
		String input = "create example by 00:41 12-12-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example",
				getDateTime("12 12 2015 00 41"));
		assertEquals(expected, output);
	}

	@Test
	public void createValidTime8() {
		String input = "create example from 4:15 6-01-2015 to 0:21 07-08-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example",
				getDateTime("06 01 2015 04 15"),
				getDateTime("07 08 2015 00 21"));
		assertEquals(expected, output);
	}

	@Test
	public void createValidTime9() {
		String input = "create example by 08:30 09-10-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example",
				getDateTime("09 10 2015 08 30"));
		assertEquals(expected, output);
	}

	@Test
	public void createValidTime10() {
		String input = "create example by 16:45 6-6-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example",
				getDateTime("06 06 2015 16 45"));
		assertEquals(expected, output);
	}

	@Test
	public void createValidTime11() {
		String input = "create watch avatar by 1.30pm 5-10-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("watch avatar",
				getDateTime("05 10 2015 13 30"));
		assertEquals(expected, output);
	}

	@Test
	public void createValidTime12() {
		String input = "create watch avatar by 11.45am 5-10-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("watch avatar",
				getDateTime("05 10 2015 11 45"));
		assertEquals(expected, output);
	}

	@Test
	public void createValidTime13() {
		String input = "create watch avatar by 23.59 5-10-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("watch avatar",
				getDateTime("05 10 2015 23 59"));
		assertEquals(expected, output);
	}

	@Test
	public void createValidTime14() {
		String input = "create watch avatar by 09.15 5-10-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("watch avatar",
				getDateTime("05 10 2015 09 15"));
		assertEquals(expected, output);
	}

	@Test
	public void createValidTime15() {
		String input = "create watch avatar by 1.25 5-10-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("watch avatar",
				getDateTime("05 10 2015 01 25"));
		assertEquals(expected, output);
	}

	@Test
	public void createInvalidTime1() {
		String input = "create example by 25:00 10-10-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"example by 25:00 10-10-2015");
		assertEquals(expected, output);
	}

	@Test
	public void createInvalidTime2() {
		String input = "create example by 24:00 10-10-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"example by 24:00 10-10-2015");
		assertEquals(expected, output);
	}

	@Test
	public void createInvalidTime3() {
		String input = "create example by 25pm 10-10-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example by 25pm 10-10-2015");
		assertEquals(expected, output);
	}

	@Test
	public void createInvalidTime4() {
		String input = "create example by 0AM 10-10-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example by 0AM 10-10-2015");
		assertEquals(expected, output);
	}

	@Test
	public void createInvalidTime5() {
		String input = "create example by 0pm 10-10-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example by 0pm 10-10-2015");
		assertEquals(expected, output);
	}

	@Test
	public void createInvalidTime6() {
		String input = "create example by 10000am 10-10-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"example by 10000am 10-10-2015");
		assertEquals(expected, output);
	}

	@Test
	public void createInvalidTime7() {
		String input = "create example by 24am 10-10-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example by 24am 10-10-2015");
		assertEquals(expected, output);
	}

	@Test
	public void createInvalidTime8() {
		String input = "create example by 24PM 10-10-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example by 24PM 10-10-2015");
		assertEquals(expected, output);
	}

	// ===================================================================
	// CREATE WITH DIFFERENT DATE FORMATS
	// ===================================================================

	@Test
	public void createValidDate1() {
		String input = "create example by 2am 01-01-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example",
				getDateTime("01 01 2015 02 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createValidDate2() {
		String input = "create example from 2-01-2015 3AM to 02-1-2015 3:15am";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example",
				getDateTime("02 01 2015 03 00"),
				getDateTime("02 01 2015 03 15"));
		assertEquals(expected, output);
	}

	@Test
	public void createValidDate3() {
		String input = "create example by 4:28AM 1-1-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example",
				getDateTime("01 01 2015 04 28"));
		assertEquals(expected, output);
	}

	@Test
	public void createValidDate4() {
		String input = "create example by 05:19am 3-10";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example",
				getDateTime("03 10 " + getCorrectYear("03 10") + " 05 19"));
		assertEquals(expected, output);
	}

	@Test
	public void createValidDate5() {
		String input = "create example from 06:53AM 4-4 to 12pm 10-10";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example",
				getDateTime("04 04 " + getCorrectYear("4 4") + " 06 53"),
				getDateTime("10 10 " + getCorrectYear("10 10") + " 12 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createValidDate6() {
		String input = "create example by 7pm 05-11";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example",
				getDateTime("05 11 " + getCorrectYear("05 11") + " 19 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createValidDate7() {
		String input = "create example by 7PM 6/07/2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example",
				getDateTime("06 07 2015 19 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createValidDate8() {
		String input = "create example from 19:15 6/7/2015 to 7:25pm 07/8/2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example",
				getDateTime("06 07 2015 19 15"),
				getDateTime("07 08 2015 19 25"));
		assertEquals(expected, output);
	}

	@Test
	public void createValidDate9() {
		String input = "create example by 07:55PM 09/09/2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example",
				getDateTime("09 09 2015 19 55"));
		assertEquals(expected, output);
	}

	@Test
	public void createValidDate10() {
		String input = "create example by 10am 11/12";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example",
				getDateTime("11 12 " + getCorrectYear("11 12") + " 10 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createValidDate11() {
		String input = "create example from 10AM 1/10 to 12PM 10/1";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example",
				getDateTime("01 10 " + getCorrectYear("01 10") + " 10 00"),
				getDateTime("10 01 " + getCorrectYear("10 01") + " 12 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createValidDate12() {
		String input = "create example by 10:50am 1/1";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example",
				getDateTime("01 01 " + getCorrectYear("01 01") + " 10 50"));
		assertEquals(expected, output);
	}

	@Test
	public void createValidDate13() {
		String input = "create example by 10:50am 31/12";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("example",
				getDateTime("31 12 " + getCorrectYear("31 12") + " 10 50"));
		assertEquals(expected, output);
	}

	// ===================================================================
	// CREATE WITH MONTH IN ENGLISH DATE FORMATS
	// ===================================================================

	@Test
	public void createDTWithJan1() {
		String input = "create build a sandcastle by 14:45 2 Jan 2016";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("build a sandcastle",
				getDateTime("02 01 2016 14 45"));
		assertEquals(expected, output);
	}

	@Test
	public void createDTWithJan2() {
		String input = "create build a sandcastle by 14:45 02 Jan 2016";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("build a sandcastle",
				getDateTime("02 01 2016 14 45"));
		assertEquals(expected, output);
	}

	@Test
	public void createDTWithFebruary() {
		String input = "create go to work in my closet company by 28 February 2016 0:00";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"go to work in my closet company",
				getDateTime("28 02 2016 00 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createDTWithMarNoYear() {
		String input = "create buy black pumps by 00:00 10 MAR";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("buy black pumps",
				getDateTime("10 03 " + getCorrectYear("10 03") + " 00 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createDTWithAprilNoYear() {
		String input = "create watch webcast by 10pm 4 april";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("watch webcast",
				getDateTime("04 04 " + getCorrectYear("04 04") + " 22 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createBTWithJuneAndJulNoYear() {
		String input = "create reach nirvana from 15 jun 2016 1:00am to 2am 18 july";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("reach nirvana",
				getDateTime("15 06 2016 01 00"), 
				getDateTime("18 07 " + getCorrectYear("18 07") + " 02 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createDTWithAugust() {
		String input = "create watch national day rally by 9august 2016 12pm";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("watch national day rally",
				getDateTime("09 08 2016 12 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createDTWithSep() {
		String input = "create wake me up when september ends by 30sep 2016 23:59";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"wake me up when september ends",
				getDateTime("30 09 2016 23 59"));
		assertEquals(expected, output);
	}

	@Test
	public void createDTWithOctoberNoYear1() {
		String input = "create buy tickets for octoberfest by 2october 16:15";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"buy tickets for octoberfest", 
				getDateTime("02 10 " + getCorrectYear("02 10") + " 16 15"));
		assertEquals(expected, output);
	}

	@Test
	public void createDTWithOctoberNoYear2() {
		String input = "create buy tickets for octoberfest by 02october 16:15";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"buy tickets for octoberfest", 
				getDateTime("02 10 " + getCorrectYear("02 10") + " 16 15"));
		assertEquals(expected, output);
	}

	@Test
	public void createBTWithNovNoYearAndDecember() {
		String input = "create cruise trip from 8AM 1Nov to 31December 2016 10PM";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("cruise trip",
				getDateTime("01 11 " + getCorrectYear("01 11") + " 08 00"),
				getDateTime("31 12 2016 22 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createBTWithFebAndAprilNoYear() {
		String input = "create OCIP from 6am 12 feb 2016 to 7am 16april";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("OCIP",
				getDateTime("12 02 2016 06 00"), 
				getDateTime("16 04 " + getCorrectYear("16 04") + " 07 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createBTWithSepAndNovemberNoYear() {
		String input = "create OCIP from 23sep 2016 11am to 28 november 12pm";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("OCIP",
				getDateTime("23 09 2016 11 00"), 
				getDateTime("28 11 " + getCorrectYear("28 11") + " 12 00"));
		assertEquals(expected, output);
	}

	// ===================================================================
	// CREATE WITH NATURAL LANGUAGE DATE FORMATS
	// ===================================================================

	@Test
	public void createDTWithTmr() {
		String input = "create watch dancing with the stars by 4pm TMR";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"watch dancing with the stars",
				getDateTime(stringify(currentDate.plusDays(1)) + " 16 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createDTWithYesterday() {
		String input = "create should have been done by yesterday 12pm";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("should have been done",
				getDateTime(stringify(currentDate.minusDays(1)) + " 12 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createDTWithTonight() {
		String input = "create buy dinner ingredients by 5pm tonight";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("buy dinner ingredients",
				getDateTime(stringify(currentDate) + " 17 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createBTWithYtdAndTomorrow() {
		String input = "create a special event from ytd 1pm to 6:30pm tomorrow";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("a special event",
				getDateTime(stringify(currentDate.minusDays(1)) + " 13 00"),
				getDateTime(stringify(currentDate.plusDays(1)) + " 18 30"));
		assertEquals(expected, output);
	}

	@Test
	public void createBTWithYesterdayAndTmr() {
		String input = "create staycation from 10pm YESTERDAY to tmr 11pm";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("staycation",
				getDateTime(stringify(currentDate.minusDays(1)) + " 22 00"),
				getDateTime(stringify(currentDate.plusDays(1)) + " 23 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createDTWithNextMonday() {
		String input = "create hand in annual report by 2pm next Monday";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("hand in annual report",
				getDateTime(stringify(currentMon.plusWeeks(1)) + " 14 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createDTWithThisFri() {
		String input = "create eat steak by this Fri 15:30";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("eat steak",
				getDateTime(stringify(currentMon.plusDays(4)) + " 15 30"));
		assertEquals(expected, output);
	}

	@Test
	public void createDTWithLastSaturday() {
		String input = "create call mom by 7:07 last Saturday";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("call mom",
				getDateTime(stringify(currentMon.minusWeeks(1).plusDays(5))
						+ " 07 07"));
		assertEquals(expected, output);
	}

	@Test
	public void createBTWithLastSunAndNextThursday() {
		String input = "create hibernate like a polar bear from 08:18 last sun to next Thursday 12:16am";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"hibernate like a polar bear", 
				getDateTime(stringify(currentMon.minusWeeks(1).plusDays(6)) 
						+ " 08 18"),
				getDateTime(stringify(currentMon.plusWeeks(1).plusDays(3))
						+ " 00 16"));
		assertEquals(expected, output);
	}

	@Test
	public void createBTWithLastSundayAndThisWed() {
		String input = "create meditate from last sunday 7pm to 6:06 THIS WED";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("meditate",
				getDateTime(stringify(currentMon.minusWeeks(1).plusDays(6))
						+ " 19 00"),
				getDateTime(stringify(currentMon.plusDays(2)) + " 06 06"));
		assertEquals(expected, output);
	}

	@Test
	public void createBTWithTodayAndNextTues() {
		String input = "create renovate house from ToDaY 4:19pm to 09:28am next tUeS";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("renovate house",
				getDateTime(stringify(currentDate) + " 16 19"),
				getDateTime(stringify(currentMon.plusWeeks(1).plusDays(1))
						+ " 09 28"));
		assertEquals(expected, output);
	}

	// ===================================================================
	// CREATE WITH INVALID DATES
	// ===================================================================

	@Test
	public void createDeadlineTaskWeirdDay1() {
		String input = "create something by 10:00 32-09-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"something by 10:00 32-09-2015");
		assertEquals(expected, output);
	}

	@Test
	public void createDeadlineTaskWeirdDay2() {
		String input = "create something by 10:00 -10-09-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"something by 10:00 -10-09-2015");
		assertEquals(expected, output);
	}

	@Test
	public void createDeadlineTaskWeirdDay3() {
		String input = "create something by 10:00 0-09-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"something by 10:00 0-09-2015");
		assertEquals(expected, output);
	}

	@Test
	public void createDeadlineTaskWeirdMonth1() {
		String input = "create something by 10:00 3-13-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"something by 10:00 3-13-2015");
		assertEquals(expected, output);
	}

	@Test
	public void createDeadlineTaskWeirdMonth2() {
		String input = "create something by 10:00 3--10-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"something by 10:00 3--10-2015");
		assertEquals(expected, output);
	}

	@Test
	public void createDeadlineTaskWeirdMonth3() {
		String input = "create something by 10:00 3-0-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"something by 10:00 3-0-2015");
		assertEquals(expected, output);
	}

	@Test
	public void createDeadlineTaskWeirdYear() {
		String input = "create something by 10:00 3-10-100";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"something by 10:00 3-10-100");
		assertEquals(expected, output);
	}

	// ===================================================================
	// CREATE WITH DAY+MONTH COMBINATIONS
	// ===================================================================

	@Test
	public void createDeadlineTaskValidDateJan() {
		String input = "create something by 10:00 31-1-2016";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("something",
				getDateTime("31 01 2016 10 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createDeadlineTaskValidDateFeb1() {
		String input = "create something by 10:17 28-2-2016";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("something",
				getDateTime("28 02 2016 10 17"));
		assertEquals(expected, output);
	}

	@Test
	public void createDeadlineTaskValidDateFeb2() {
		String input = "create something by 10:17am 29-2-2016";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("something",
				getDateTime("29 02 2016 10 17"));
		assertEquals(expected, output);
	}

	@Test
	public void createDeadlineTaskValidDateMar() {
		String input = "create something by 16:59 31-3-2016";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("something",
				getDateTime("31 03 2016 16 59"));
		assertEquals(expected, output);
	}

	@Test
	public void createDeadlineTaskValidDateApr() {
		String input = "create something by 4:59pm 30-4-2016";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("something",
				getDateTime("30 04 2016 16 59"));
		assertEquals(expected, output);
	}

	@Test
	public void createDeadlineTaskValidDateMay() {
		String input = "create something by 12am 31-5-2016";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("something",
				getDateTime("31 05 2016 00 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createDeadlineTaskValidDateJun() {
		String input = "create something by 11:00 30-6-2016";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("something",
				getDateTime("30 06 2016 11 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createDeadlineTaskValidDateJul() {
		String input = "create something by 5:05am 31-7-2016";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("something",
				getDateTime("31 07 2016 05 05"));
		assertEquals(expected, output);
	}

	@Test
	public void createDeadlineTaskValidDateAug() {
		String input = "create something by 4:09pm 31-8-2016";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("something",
				getDateTime("31 08 2016 16 09"));
		assertEquals(expected, output);
	}

	@Test
	public void createDeadlineTaskValidDateSep() {
		String input = "create something by 1:37aM 30-9-2016";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("something",
				getDateTime("30 09 2016 01 37"));
		assertEquals(expected, output);
	}

	@Test
	public void createDeadlineTaskValidDateOct() {
		String input = "create something by 01:37AM 31-10-2016";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("something",
				getDateTime("31 10 2016 01 37"));
		assertEquals(expected, output);
	}

	@Test
	public void createDeadlineTaskValidDateNov() {
		String input = "create something by 3:10Pm 30-11-2016";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("something",
				getDateTime("30 11 2016 15 10"));
		assertEquals(expected, output);
	}

	@Test
	public void createDeadlineTaskValidDateDec() {
		String input = "create something by 03:10pm 31-12-2016";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("something",
				getDateTime("31 12 2016 15 10"));
		assertEquals(expected, output);
	}

	@Test
	public void createDeadlineTaskInvalidDateFeb() {
		String input = "create something by 10:00 30-2-2016";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"something by 10:00 30-2-2016");
		assertEquals(expected, output);
	}

	@Test
	public void createDeadlineTaskInvalidDateFeb3() {
		String input = "create something by 10:00 31-2-2016";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"something by 10:00 31-2-2016");
		assertEquals(expected, output);
	}

	@Test
	public void createDeadlineTaskInvalidDateApr() {
		String input = "create something by 10:00 31-4-2016";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"something by 10:00 31-4-2016");
		assertEquals(expected, output);
	}

	@Test
	public void createDeadlineTaskInvalidDateJun() {
		String input = "create something by 10:00 31-6-2016";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"something by 10:00 31-6-2016");
		assertEquals(expected, output);
	}

	@Test
	public void createDeadlineTaskInvalidDateSep() {
		String input = "create something by 10:00 31-09-2016";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"something by 10:00 31-09-2016");
		assertEquals(expected, output);
	}

	@Test
	public void createDeadlineTaskInvalidDateNov() {
		String input = "create something by 10:00 31-11-2016";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"something by 10:00 31-11-2016");
		assertEquals(expected, output);
	}

	// ===================================================================
	// TEST WITH KEYWORDS (FROM, TO, BY) IN NAME
	// ===================================================================

	@Test
	public void createFTWithKeyword1() {
		String input = "create by something something something";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"by something something something");
		assertEquals(expected, output);
	}

	@Test
	public void createFTWithKeyword2() {
		String input = "create something by something something";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"something by something something");
		assertEquals(expected, output);
	}

	@Test
	public void createFTWithKeyword3() {
		String input = "create something something by something";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"something something by something");
		assertEquals(expected, output);
	}

	@Test
	public void createFTWithKeyword4() {
		String input = "create something something something by";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"something something something by");
		assertEquals(expected, output);
	}

	@Test
	public void createFTWithKeyword5() {
		String input = "create from something something something";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"from something something something");
		assertEquals(expected, output);
	}

	@Test
	public void createFTWithKeyword6() {
		String input = "create something from something something";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"something from something something");
		assertEquals(expected, output);
	}

	@Test
	public void createFTWithKeyword7() {
		String input = "create something something from something";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"something something from something");
		assertEquals(expected, output);
	}

	@Test
	public void createFTWithKeyword8() {
		String input = "create something something something from";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"something something something from");
		assertEquals(expected, output);
	}

	@Test
	public void createFTWithKeyword9() {
		String input = "create to something something something";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"to something something something");
		assertEquals(expected, output);
	}

	@Test
	public void createFTWithKeyword10() {
		String input = "create something to something something";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"something to something something");
		assertEquals(expected, output);
	}

	@Test
	public void createFTWithKeyword11() {
		String input = "create something something to something";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"something something to something");
		assertEquals(expected, output);
	}

	@Test
	public void createFTWithKeyword12() {
		String input = "create something something something to";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"something something something to");
		assertEquals(expected, output);
	}

	@Test
	public void createFTWithKeyword13() {
		String input = "create from something to something";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"from something to something");
		assertEquals(expected, output);
	}

	@Test
	public void createFTWithKeyword14() {
		String input = "create something from something to something";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"something from something to something");
		assertEquals(expected, output);
	}

	@Test
	public void createFTWithKeyword15() {
		String input = "create from something something to something something";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"from something something to something something");
		assertEquals(expected, output);
	}

	@Test
	public void createFTWithKeyword16() {
		String input = "create something from something something to something something";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"something from something something to something something");
		assertEquals(expected, output);
	}

	@Test
	public void createDTWithKeyword1() {
		String input = "create test test test by by 09:00am 9/09";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("test test test by",
				getDateTime("09 09 " + getCorrectYear("09 09") + " 09 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createDTWithKeyword2() {
		String input = "create test by 9am 05-05 by 9am 05-05";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("test by 9am 05-05",
				getDateTime("05 05 " + getCorrectYear("05 05") + " 09 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createDTWithKeyword3() {
		String input = "create test from 09:00AM 07-7 by 09:00AM 07-7";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("test from 09:00AM 07-7",
				getDateTime("07 07 " + getCorrectYear("07 07") + " 09 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createDTWithKeyword4() {
		String input = "create test to 2-2-2015 09:00 by 02-02-2015 09:00";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("test to 2-2-2015 09:00",
				getDateTime("02 02 2015 09 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createDTWithKeyword5() {
		String input = "create update exam details from /10AM /05-05-2015 /to /10AM /05-05-2015 by 10AM 05-05-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"update exam details from 10AM 05-05-2015 to 10AM 05-05-2015",
				getDateTime("05 05 2015 10 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createBTWithKeyword1() {
		String input = "create test by 10am 5-5-15 from 10.00am 5-5-2015 to 13:00 05-05-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("test by 10am 5-5-15",
				getDateTime("05 05 2015 10 00"),
				getDateTime("05 05 2015 13 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createBTWithKeyword2() {
		String input = "create test from 10am 5-5-2015 to 10am 5-5-2015 from 10am 5-5-2015 to 13.00 05-05-2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand(
				"test from 10am 5-5-2015 to 10am 5-5-2015",
				getDateTime("05 05 2015 10 00"),
				getDateTime("05 05 2015 13 00"));
		assertEquals(expected, output);
	}

	// ===================================================================
	// TEST SHORTCUT FOR CREATING BOUNDED TASKS WITH SAME START & END DATE
	// ===================================================================

	@Test
	public void createBTSameDate1() {
		String input = "create networking session from 7pm to 10pm today";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("networking session",
				getDateTime(stringify(currentDate) + " 19 00"),
				getDateTime(stringify(currentDate) + " 22 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createBTSameDate2() {
		String input = "create art and crafts time from 15:00 next fri to 17:30";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("art and crafts time",
				getDateTime(stringify(currentMon.plusWeeks(1).plusDays(4))
						+ " 15 00"), 
				getDateTime(stringify(currentMon.plusWeeks(1).plusDays(4)) 
						+ " 17 30"));
		assertEquals(expected, output);
	}

	@Test
	public void createBTSameDate3() {
		String input = "create lockcity x lockdown from 10AM to 9PM 25 october 2015";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("lockcity x lockdown",
				getDateTime("25 10 2015 10 00"),
				getDateTime("25 10 2015 21 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createBTSameDate4() {
		String input = "create find a vampire from 10:57 to 17 sep 14:23";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("find a vampire",
				getDateTime("17 09 " + getCorrectYear("17 09") + " 10 57"),
				getDateTime("17 09 " + getCorrectYear("17 09") + " 14 23"));
		assertEquals(expected, output);
	}

	@Test
	public void createBTSameDate5() {
		String input = "create Scrabble competition from 1:30pm 5feb 2016 to 3:30pm";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("Scrabble competition",
				getDateTime("05 02 2016 13 30"),
				getDateTime("05 02 2016 15 30"));
		assertEquals(expected, output);
	}

	@Test
	public void createBTSameDate6() {
		String input = "create hockey competition from 10jan 11am to 1pm";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("hockey competition",
				getDateTime("10 01 " + getCorrectYear("10 01") + " 11 00"),
				getDateTime("10 01 " + getCorrectYear("10 01") + " 13 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createBTSameDate7() {
		String input = "create stay up late from 2am to 4am 5/5/2016";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("stay up late",
				getDateTime("05 05 2016 02 00"),
				getDateTime("05 05 2016 04 00"));
		assertEquals(expected, output);
	}

	@Test
	public void createBTSameDate8() {
		String input = "create vacation from 00:00 7/8 to 23:59";
		AbstractCommand output = parser.parseInput(input);
		CreateCommand expected = new CreateCommand("vacation",
				getDateTime("07 08 " + getCorrectYear("07 08") + " 00 00"),
				getDateTime("07 08 " + getCorrectYear("07 08") + " 23 59"));
		assertEquals(expected, output);
	}

	// *******************************************************************
	// *******************************************************************
	// FOR EDIT COMMAND
	// *******************************************************************
	// *******************************************************************

	@Test
	public void editByIndex() {
		String input = "edit 5";
		AbstractCommand output = parser.parseInput(input);

		EditCommand expected = new EditCommand(5);
		ArrayList<EditCommand.editField> editType = new ArrayList<EditCommand.editField>();
		expected.setEditFields(editType);

		assertEquals(expected, output);
	}

	@Test
	public void editByIndexN() {
		String input = "edit 1 to eat lunch";
		AbstractCommand output = parser.parseInput(input);

		EditCommand expected = new EditCommand(1);
		ArrayList<EditCommand.editField> editType = new ArrayList<EditCommand.editField>();
		editType.add(EditCommand.editField.NAME);
		expected.setNewName("eat lunch");
		expected.setEditFields(editType);

		assertEquals(expected, output);
	}

	@Test
	public void editByIndexNSTSDETED() {
		String input = "EDIT 2 TO fun and games start to 3pm 20-10-2015 end to 5pm 20-10-2015";
		AbstractCommand output = parser.parseInput(input);

		EditCommand expected = new EditCommand(2);
		ArrayList<EditCommand.editField> editType = new ArrayList<EditCommand.editField>();
		editType.add(EditCommand.editField.NAME);
		expected.setNewName("fun and games");
		editType.add(EditCommand.editField.START_TIME);
		expected.setNewStartTime("15 00");
		editType.add(EditCommand.editField.START_DATE);
		expected.setNewStartDate("20 10 2015");
		editType.add(EditCommand.editField.END_TIME);
		expected.setNewEndTime("17 00");
		editType.add(EditCommand.editField.END_DATE);
		expected.setNewEndDate("20 10 2015");
		expected.setEditFields(editType);

		assertEquals(expected, output);
	}

	@Test
	public void editBySearchKeywordNumberN() {
		String input = "edit /1 to eat lunch";
		AbstractCommand output = parser.parseInput(input);

		EditCommand expected = new EditCommand("1");
		ArrayList<EditCommand.editField> editType = new ArrayList<EditCommand.editField>();
		editType.add(EditCommand.editField.NAME);
		expected.setNewName("eat lunch");
		expected.setEditFields(editType);

		assertEquals(expected, output);
	}

	@Test
	public void editBySearchKeyword() {
		String input = "edit birthday";
		AbstractCommand output = parser.parseInput(input);
		assertEquals(expectedInvalid, output);
	}

	@Test
	public void editBySearchKeywordNSTSDETED() {
		String input = "edit anniversary lunch TO anniversary dinner start to 4.19PM 6/06 end to 5.00am 09/6";
		AbstractCommand output = parser.parseInput(input);

		EditCommand expected = new EditCommand("anniversary lunch");
		ArrayList<EditCommand.editField> editType = new ArrayList<EditCommand.editField>();
		editType.add(EditCommand.editField.NAME);
		expected.setNewName("anniversary dinner");
		editType.add(EditCommand.editField.START_TIME);
		expected.setNewStartTime("16 19");
		editType.add(EditCommand.editField.START_DATE);
		expected.setNewStartDate("06 06 " + getCorrectYear("06 06"));
		editType.add(EditCommand.editField.END_TIME);
		expected.setNewEndTime("05 00");
		editType.add(EditCommand.editField.END_DATE);
		expected.setNewEndDate("09 06 " + getCorrectYear("09 06"));
		expected.setEditFields(editType);

		assertEquals(expected, output);
	}

	@Test
	public void eBySearchKeywordNSTSDETED() {
		String input = "E morning swim to lazing in on Sunday start to 2-2-2015 07:10 end to 02-02-2015 10AM";
		AbstractCommand output = parser.parseInput(input);

		EditCommand expected = new EditCommand("morning swim");
		ArrayList<EditCommand.editField> editType = new ArrayList<EditCommand.editField>();
		editType.add(EditCommand.editField.NAME);
		expected.setNewName("lazing in on Sunday");
		editType.add(EditCommand.editField.START_TIME);
		expected.setNewStartTime("07 10");
		editType.add(EditCommand.editField.START_DATE);
		expected.setNewStartDate("02 02 2015");
		editType.add(EditCommand.editField.END_TIME);
		expected.setNewEndTime("10 00");
		editType.add(EditCommand.editField.END_DATE);
		expected.setNewEndDate("02 02 2015");
		expected.setEditFields(editType);

		assertEquals(expected, output);
	}

	@Test
	public void editBySearchKeywordNSDSTEDET() {
		String input = "EDIT play with cat to /start training dog start to 2/09 8:19AM end to 18:53 02/09";
		AbstractCommand output = parser.parseInput(input);

		EditCommand expected = new EditCommand("play with cat");
		ArrayList<EditCommand.editField> editType = new ArrayList<EditCommand.editField>();
		editType.add(EditCommand.editField.NAME);
		expected.setNewName("start training dog");
		editType.add(EditCommand.editField.START_TIME);
		expected.setNewStartTime("08 19");
		editType.add(EditCommand.editField.START_DATE);
		expected.setNewStartDate("02 09 " + getCorrectYear("02 09"));
		editType.add(EditCommand.editField.END_TIME);
		expected.setNewEndTime("18 53");
		editType.add(EditCommand.editField.END_DATE);
		expected.setNewEndDate("02 09 " + getCorrectYear("02 09"));
		expected.setEditFields(editType);

		assertEquals(expected, output);
	}

	@Test
	public void editBySearchKeywordNSTSD() {
		String input = "edit travel /to Narnia to /to Kansas instead start to 08:10 31/1";
		AbstractCommand output = parser.parseInput(input);

		EditCommand expected = new EditCommand("travel to Narnia");
		ArrayList<EditCommand.editField> editType = new ArrayList<EditCommand.editField>();
		editType.add(EditCommand.editField.NAME);
		expected.setNewName("to Kansas instead");
		editType.add(EditCommand.editField.START_TIME);
		expected.setNewStartTime("08 10");
		editType.add(EditCommand.editField.START_DATE);
		expected.setNewStartDate("31 01 " + getCorrectYear("31 01"));
		expected.setEditFields(editType);

		assertEquals(expected, output);
	}

	@Test
	public void editBySearchKeywordNEDET() {
		String input = "edit happy /to to see you end to 8/8 10:03PM";
		AbstractCommand output = parser.parseInput(input);

		EditCommand expected = new EditCommand("happy to");
		ArrayList<EditCommand.editField> editType = new ArrayList<EditCommand.editField>();
		editType.add(EditCommand.editField.NAME);
		expected.setNewName("see you");
		editType.add(EditCommand.editField.END_TIME);
		expected.setNewEndTime("22 03");
		editType.add(EditCommand.editField.END_DATE);
		expected.setNewEndDate("08 08 " + getCorrectYear("08 08"));
		expected.setEditFields(editType);

		assertEquals(expected, output);
	}

	@Test
	public void editBySearchKeywordSTSDETED() {
		String input = "edit something start to 5:10 2/3/2015 end to 04-05-2015 18:40";
		AbstractCommand output = parser.parseInput(input);

		String input2 = "edit something to start to 2/03/2015 05:10 end to 06:40PM 04/5/2015";
		AbstractCommand output2 = parser.parseInput(input2);

		EditCommand expected = new EditCommand("something");
		ArrayList<EditCommand.editField> editType = new ArrayList<EditCommand.editField>();
		editType.add(EditCommand.editField.START_TIME);
		expected.setNewStartTime("05 10");
		editType.add(EditCommand.editField.START_DATE);
		expected.setNewStartDate("02 03 2015");
		editType.add(EditCommand.editField.END_TIME);
		expected.setNewEndTime("18 40");
		editType.add(EditCommand.editField.END_DATE);
		expected.setNewEndDate("04 05 2015");
		expected.setEditFields(editType);

		assertEquals(expected, output);
		assertEquals(output2, expected);
	}

	@Test
	public void editBySearchKeywordSTET() {
		String input = "edit tuition start to 1:10pM end to 3:20Pm";
		AbstractCommand output = parser.parseInput(input);

		String input2 = "edit tuition to start to 13:10 end to 03:20pm";
		AbstractCommand output2 = parser.parseInput(input2);

		EditCommand expected = new EditCommand("tuition");
		ArrayList<EditCommand.editField> editType = new ArrayList<EditCommand.editField>();
		editType.add(EditCommand.editField.START_TIME);
		expected.setNewStartTime("13 10");
		editType.add(EditCommand.editField.END_TIME);
		expected.setNewEndTime("15 20");
		expected.setEditFields(editType);

		assertEquals(expected, output);
		assertEquals(output2, expected);
	}

	@Test
	public void editBySearchKeywordSDED1() {
		String input = "edit storytime to start to 10-10-2015 end to 10/10/2015";
		AbstractCommand output = parser.parseInput(input);

		EditCommand expected = new EditCommand("storytime");
		ArrayList<EditCommand.editField> editType = new ArrayList<EditCommand.editField>();
		editType.add(EditCommand.editField.START_DATE);
		expected.setNewStartDate("10 10 2015");
		editType.add(EditCommand.editField.END_DATE);
		expected.setNewEndDate("10 10 2015");
		expected.setEditFields(editType);

		assertEquals(expected, output);
	}

	@Test
	public void editBySearchKeywordN() {
		String input = "edit /start /to say hello to /end";
		AbstractCommand output = parser.parseInput(input);

		EditCommand expected = new EditCommand("start to say hello");
		ArrayList<EditCommand.editField> editType = new ArrayList<EditCommand.editField>();
		editType.add(EditCommand.editField.NAME);
		expected.setNewName("end");
		expected.setEditFields(editType);

		assertEquals(expected, output);
	}

	@Test
	public void editBySearchKeywordST() {
		String input = "edit hello monkey start to 8pm";
		AbstractCommand output = parser.parseInput(input);

		String input2 = "edit hello monkey TO start to 8pm";
		AbstractCommand output2 = parser.parseInput(input2);

		EditCommand expected = new EditCommand("hello monkey");
		ArrayList<EditCommand.editField> editType = new ArrayList<EditCommand.editField>();
		editType.add(EditCommand.editField.START_TIME);
		expected.setNewStartTime("20 00");
		expected.setEditFields(editType);

		assertEquals(expected, output);
		assertEquals(output2, expected);
	}

	@Test
	public void editBySearchKeywordSD() {
		String input = "edit hello mr. seagull start to 19-9-2015";
		AbstractCommand output = parser.parseInput(input);

		String input2 = "edit hello mr. seagull to START to 19/09/2015";
		AbstractCommand output2 = parser.parseInput(input2);

		EditCommand expected = new EditCommand("hello mr. seagull");
		ArrayList<EditCommand.editField> editType = new ArrayList<EditCommand.editField>();
		editType.add(EditCommand.editField.START_DATE);
		expected.setNewStartDate("19 09 2015");
		expected.setEditFields(editType);

		assertEquals(expected, output);
		assertEquals(output2, expected);
	}

	@Test
	public void eBySearchKeywordET() {
		String input = "e sky diving END to 12pm";
		AbstractCommand output = parser.parseInput(input);

		String input2 = "E sky diving to end to 12:00pm";
		AbstractCommand output2 = parser.parseInput(input2);

		EditCommand expected = new EditCommand("sky diving");
		ArrayList<EditCommand.editField> editType = new ArrayList<EditCommand.editField>();
		editType.add(EditCommand.editField.END_TIME);
		expected.setNewEndTime("12 00");
		expected.setEditFields(editType);

		assertEquals(expected, output);
		assertEquals(output2, expected);
	}

	@Test
	public void editBySearchKeywordED() {
		String input = "EDIT detox and diet end to 7/2/2015";
		AbstractCommand output = parser.parseInput(input);

		String input2 = "edit detox and diet END to 07-02-2015";
		AbstractCommand output2 = parser.parseInput(input2);

		EditCommand expected = new EditCommand("detox and diet");
		ArrayList<EditCommand.editField> editType = new ArrayList<EditCommand.editField>();
		editType.add(EditCommand.editField.END_DATE);
		expected.setNewEndDate("07 02 2015");
		expected.setEditFields(editType);

		assertEquals(expected, output);
		assertEquals(output2, expected);
	}

	@Test
	public void editEmpty() {
		String input = "edit";
		AbstractCommand output = parser.parseInput(input);
		InvalidCommand expected = new InvalidCommand();
		assertEquals(expected, output);
	}

	@Test
	public void editBySearchKeywordSDEDWithYtdAndTmr() {
		String input = "edit holiday at Maldives start to ytd end to tmr";
		AbstractCommand output = parser.parseInput(input);

		EditCommand expected = new EditCommand("holiday at Maldives");
		ArrayList<EditCommand.editField> editType = new ArrayList<EditCommand.editField>();
		editType.add(EditCommand.editField.START_DATE);
		expected.setNewStartDate(stringify(currentDate.minusDays(1)));
		editType.add(EditCommand.editField.END_DATE);
		expected.setNewEndDate(stringify(currentDate.plusDays(1)));
		expected.setEditFields(editType);

		assertEquals(expected, output);
	}

	@Test
	public void editBySearchKeywordSDEDWithYesterdayAndTomorrow() {
		String input = "edit holiday at Maldives start to yesterday end to tomorrow";
		AbstractCommand output = parser.parseInput(input);

		EditCommand expected = new EditCommand("holiday at Maldives");
		ArrayList<EditCommand.editField> editType = new ArrayList<EditCommand.editField>();
		editType.add(EditCommand.editField.START_DATE);
		expected.setNewStartDate(stringify(currentDate.minusDays(1)));
		editType.add(EditCommand.editField.END_DATE);
		expected.setNewEndDate(stringify(currentDate.plusDays(1)));
		expected.setEditFields(editType);

		assertEquals(expected, output);
	}

	@Test
	public void editBySearchKeywordNSDEDWithTodayAndNextSun() {
		String input = "edit church conference tmr TO church camp START to today END to next sun";
		AbstractCommand output = parser.parseInput(input);

		EditCommand expected = new EditCommand("church conference tmr");
		ArrayList<EditCommand.editField> editType = new ArrayList<EditCommand.editField>();
		editType.add(EditCommand.editField.NAME);
		expected.setNewName("church camp");
		editType.add(EditCommand.editField.START_DATE);
		expected.setNewStartDate(stringify(currentDate));
		editType.add(EditCommand.editField.END_DATE);
		expected.setNewEndDate(stringify(currentMon.plusWeeks(1).plusDays(6)));
		expected.setEditFields(editType);

		assertEquals(expected, output);
	}

	@Test
	public void editBySearchKeywordNSDSTEDETFull() {
		String input = "edit watch the day after tomorrow to /start /to /end start to ytd 07:26pm end to 13:43 next Fri";
		AbstractCommand output = parser.parseInput(input);

		EditCommand expected = new EditCommand("watch the day after tomorrow");
		ArrayList<EditCommand.editField> editType = new ArrayList<EditCommand.editField>();
		editType.add(EditCommand.editField.NAME);
		expected.setNewName("start to end");
		editType.add(EditCommand.editField.START_TIME);
		expected.setNewStartTime("19 26");
		editType.add(EditCommand.editField.START_DATE);
		expected.setNewStartDate(stringify(currentDate.minusDays(1)));
		editType.add(EditCommand.editField.END_TIME);
		expected.setNewEndTime("13 43");
		editType.add(EditCommand.editField.END_DATE);
		expected.setNewEndDate(stringify(currentMon.plusWeeks(1).plusDays(4)));
		expected.setEditFields(editType);

		assertEquals(expected, output);
	}

	@Test
	public void editBySearchKeywordSDED2() {
		String input = "edit attend wedding banquet start to 2jan 2015 end to 03 february 2015";
		AbstractCommand output = parser.parseInput(input);

		EditCommand expected = new EditCommand("attend wedding banquet");
		ArrayList<EditCommand.editField> editType = new ArrayList<EditCommand.editField>();
		editType.add(EditCommand.editField.START_DATE);
		expected.setNewStartDate("02 01 2015");
		editType.add(EditCommand.editField.END_DATE);
		expected.setNewEndDate("03 02 2015");
		expected.setEditFields(editType);

		assertEquals(expected, output);
	}

	@Test
	public void editBySearchKeywordSDED3() {
		String input = "edit part time work start to 12March end to 27 Apr";
		AbstractCommand output = parser.parseInput(input);

		EditCommand expected = new EditCommand("part time work");
		ArrayList<EditCommand.editField> editType = new ArrayList<EditCommand.editField>();
		editType.add(EditCommand.editField.START_DATE);
		expected.setNewStartDate("12 03 " + getCorrectYear("12 03"));
		editType.add(EditCommand.editField.END_DATE);
		expected.setNewEndDate("27 04 " + getCorrectYear("27 04"));
		expected.setEditFields(editType);

		assertEquals(expected, output);
	}

	@Test
	public void editIndex0() {
		String input = "edit 0";
		AbstractCommand output = parser.parseInput(input);
		assertEquals(expectedInvalid, output);
	}

	@Test
	public void editIndex0N() {
		String input = "edit 0 to something";
		AbstractCommand output = parser.parseInput(input);

		EditCommand expected = new EditCommand("0");
		ArrayList<EditCommand.editField> editType = new ArrayList<EditCommand.editField>();
		editType.add(EditCommand.editField.NAME);
		expected.setNewName("something");
		expected.setEditFields(editType);

		assertEquals(expected, output);
	}

	@Test
	public void editIndex0SDED() {
		String input = "edit 0 start to ytd end to tmr";
		AbstractCommand output = parser.parseInput(input);

		EditCommand expected = new EditCommand("0");
		ArrayList<EditCommand.editField> editType = new ArrayList<EditCommand.editField>();
		editType.add(EditCommand.editField.START_DATE);
		expected.setNewStartDate(stringify(currentDate.minusDays(1)));
		editType.add(EditCommand.editField.END_DATE);
		expected.setNewEndDate(stringify(currentDate.plusDays(1)));
		expected.setEditFields(editType);

		assertEquals(expected, output);
	}

	@Test
	public void edit() {
		String input = "edit 9nov end to 1313pm";
		AbstractCommand output = parser.parseInput(input);
		assertEquals(expectedInvalid, output);
	}

	// *******************************************************************
	// *******************************************************************
	// FOR DELETE COMMAND
	// *******************************************************************
	// *******************************************************************

	@Test
	public void deleteByIndex() {
		String input = "delete 15";
		AbstractCommand output = parser.parseInput(input);
		DeleteCommand expected = new DeleteCommand(15);
		assertEquals(expected, output);
	}

	@Test
	public void deleteBySearchKeywordNumber() {
		String input = "delete /15";
		AbstractCommand output = parser.parseInput(input);
		DeleteCommand expected = new DeleteCommand("15");
		assertEquals(expected, output);
	}

	@Test
	public void deleteBySearchKeywordOneWord() {
		String input = "DELETE meeting";
		AbstractCommand output = parser.parseInput(input);
		DeleteCommand expected = new DeleteCommand("meeting");
		assertEquals(expected, output);
	}

	@Test
	public void dlBySearchKeywordManyWords() {
		String input = "dl group project meeting";
		AbstractCommand output = parser.parseInput(input);
		DeleteCommand expected = new DeleteCommand("group project meeting");
		assertEquals(expected, output);
	}

	@Test
	public void deleteEmpty() {
		String input = "delete";
		AbstractCommand output = parser.parseInput(input);
		assertEquals(expectedInvalid, output);
	}

	@Test
	public void deleteByScopeAll() {
		String input = "delete all";
		AbstractCommand output = parser.parseInput(input);
		DeleteCommand expected = new DeleteCommand(DeleteCommand.Scope.ALL);
		assertEquals(expected, output);
	}

	// *******************************************************************
	// *******************************************************************
	// FOR DISPLAY COMMAND
	// *******************************************************************
	// *******************************************************************

	@Test
	public void dpBySearchDate() {
		String input = "DP 6/7/2015";
		AbstractCommand output = parser.parseInput(input);
		DisplayCommand expected = new DisplayCommand(
				getDateTime("06 07 2015 " + dummyTime));
		assertEquals(expected, output);
	}

	@Test
	public void displayBySearchDate1() {
		String input = "display 12/1";
		AbstractCommand output = parser.parseInput(input);
		DisplayCommand expected = new DisplayCommand(
				getDateTime("12 01 " + getCorrectYear("12 01") + " " 
						+ dummyTime));
		assertEquals(expected, output);
	}

	@Test
	public void displayBySearchDateTmr() {
		String input = "display TMR";
		AbstractCommand output = parser.parseInput(input);
		DisplayCommand expected = new DisplayCommand(
				getDateTime(stringify(currentDate.plusDays(1)) + " "
						+ dummyTime));
		assertEquals(expected, output);
	}

	@Test
	public void displayBySearchKeywordYesterday() {
		String input = "display /Yesterday";
		AbstractCommand output = parser.parseInput(input);
		ArrayList<String> searchKeyword = new ArrayList<String>();
		searchKeyword.add("Yesterday");
		DisplayCommand expected = new DisplayCommand(searchKeyword);
		assertEquals(expected, output);
	}

	@Test
	public void displayBySearchDateLastMon() {
		String input = "display last Mon";
		AbstractCommand output = parser.parseInput(input);
		DisplayCommand expected = new DisplayCommand(
				getDateTime(stringify(currentMon.minusWeeks(1)) + " "
						+ dummyTime));
		assertEquals(expected, output);
	}

	@Test
	public void displayBySearchDate2() {
		String input = "display 15 sep 2016";
		AbstractCommand output = parser.parseInput(input);
		DisplayCommand expected = new DisplayCommand(
				getDateTime("15 09 2016 " + dummyTime));
		assertEquals(expected, output);
	}

	@Test
	public void displayBySearchDate3() {
		String input = "display 24june";
		AbstractCommand output = parser.parseInput(input);
		DisplayCommand expected = new DisplayCommand(
				getDateTime("24 06 " + getCorrectYear("24 06") + " " 
						+ dummyTime));
		assertEquals(expected, output);
	}

	@Test
	public void displayBySearchKeywordNextFriday() {
		String input = "display /next /friday";
		AbstractCommand output = parser.parseInput(input);
		ArrayList<String> searchKeyword = new ArrayList<String>();
		searchKeyword.add("next");
		searchKeyword.add("friday");
		DisplayCommand expected = new DisplayCommand(searchKeyword);
		assertEquals(expected, output);
	}

	@Test
	public void displayBySearchKeywordThisSun() {
		String input = "display /this sun";
		AbstractCommand output = parser.parseInput(input);
		ArrayList<String> searchKeyword = new ArrayList<String>();
		searchKeyword.add("this");
		searchKeyword.add("sun");
		DisplayCommand expected = new DisplayCommand(searchKeyword);
		assertEquals(expected, output);
	}

	@Test
	public void displayBySearchKeywordLastSat() {
		String input = "display last /Sat";
		AbstractCommand output = parser.parseInput(input);
		ArrayList<String> searchKeyword = new ArrayList<String>();
		searchKeyword.add("last");
		searchKeyword.add("Sat");
		DisplayCommand expected = new DisplayCommand(searchKeyword);
		assertEquals(expected, output);
	}

	@Test
	public void displayBySearchKeywordOneWord() {
		String input = "display meeting";
		AbstractCommand output = parser.parseInput(input);
		ArrayList<String> searchKeyword = new ArrayList<String>();
		searchKeyword.add("meeting");
		DisplayCommand expected = new DisplayCommand(searchKeyword);
		assertEquals(expected, output);
	}

	@Test
	public void dpBySearchKeywordManyWords() {
		String input = "dp group project meeting";
		AbstractCommand output = parser.parseInput(input);
		ArrayList<String> searchKeyword = new ArrayList<String>();
		searchKeyword.add("group");
		searchKeyword.add("project");
		searchKeyword.add("meeting");
		DisplayCommand expected = new DisplayCommand(searchKeyword);
		assertEquals(expected, output);
	}

	@Test
	public void displaypBySearchKeywordManyWords() {
		String input = "display mary had a little lamb";
		AbstractCommand output = parser.parseInput(input);
		ArrayList<String> searchKeyword = new ArrayList<String>();
		searchKeyword.add("mary");
		searchKeyword.add("had");
		searchKeyword.add("a");
		searchKeyword.add("little");
		searchKeyword.add("lamb");
		DisplayCommand expected = new DisplayCommand(searchKeyword);
		assertEquals(expected, output);
	}

	@Test
	public void displayByScopeEmpty() {
		String input = "display";
		AbstractCommand output = parser.parseInput(input);
		DisplayCommand expected = new DisplayCommand(
				DisplayCommand.Scope.DEFAULT);
		assertEquals(expected, output);
	}

	@Test
	public void displayByScopeAll() {
		String input = "DISPLAY all";
		AbstractCommand output = parser.parseInput(input);
		DisplayCommand expected = new DisplayCommand(DisplayCommand.Scope.ALL);
		assertEquals(expected, output);
	}

	@Test
	public void displayByScopeDoneAndMark() {
		String input1 = "display Done";
		AbstractCommand output1 = parser.parseInput(input1);

		String input2 = "display mark";
		AbstractCommand output2 = parser.parseInput(input2);

		DisplayCommand expected = new DisplayCommand(DisplayCommand.Scope.DONE);
		assertEquals(expected, output1);
		assertEquals(expected, output2);
	}

	@Test
	public void dpByScopeUndoneAndUnmark() {
		String input1 = "dp undone";
		AbstractCommand output1 = parser.parseInput(input1);

		String input2 = "dp undone";
		AbstractCommand output2 = parser.parseInput(input2);

		DisplayCommand expected = new DisplayCommand(
				DisplayCommand.Scope.UNDONE);
		assertEquals(expected, output1);
		assertEquals(expected, output2);
	}

	@Test
	public void displayByScopeFloating() {
		String input = "display FloaTing";
		AbstractCommand output = parser.parseInput(input);
		DisplayCommand expected = new DisplayCommand(
				DisplayCommand.Scope.FLOATING);
		assertEquals(expected, output);
	}

	@Test
	public void displayBySearchKeywordUndone() {
		String input = "display /undone";
		AbstractCommand output = parser.parseInput(input);
		ArrayList<String> searchKeyword = new ArrayList<String>();
		searchKeyword.add("undone");
		DisplayCommand expected = new DisplayCommand(searchKeyword);
		assertEquals(expected, output);
	}

	// *******************************************************************
	// *******************************************************************
	// FOR SEARCH COMMAND
	// *******************************************************************
	// *******************************************************************

	@Test
	public void searchBySearchDate() {
		String input = "search 12/12/2015";
		AbstractCommand output = parser.parseInput(input);
		DisplayCommand expected = new DisplayCommand(
				getDateTime("12 12 2015 " + dummyTime));
		assertEquals(expected, output);
	}

	@Test
	public void sBySearchDate() {
		String input = "s 11/2";
		AbstractCommand output = parser.parseInput(input);
		DisplayCommand expected = new DisplayCommand(
				getDateTime("11 02 " + getCorrectYear("11 02") + " " 
						+ dummyTime));
		assertEquals(expected, output);
	}

	@Test
	public void searchBySearchDateToday() {
		String input = "search today";
		AbstractCommand output = parser.parseInput(input);
		DisplayCommand expected = new DisplayCommand(
				getDateTime(stringify(currentDate) + " " + dummyTime));
		assertEquals(expected, output);
	}

	@Test
	public void searchBySearchDateNextMon() {
		String input = "Search next Mon";
		AbstractCommand output = parser.parseInput(input);
		DisplayCommand expected = new DisplayCommand(
				getDateTime(stringify(currentMon.plusWeeks(1)) + " "
						+ dummyTime));
		assertEquals(expected, output);
	}

	@Test
	public void searchBySearchKeywordTomorrow() {
		String input = "search /tomorrow";
		AbstractCommand output = parser.parseInput(input);
		ArrayList<String> searchKeyword = new ArrayList<String>();
		searchKeyword.add("tomorrow");
		DisplayCommand expected = new DisplayCommand(searchKeyword);
		assertEquals(expected, output);
	}

	@Test
	public void sBySearchKeywordThisThurs() {
		String input = "s /this /thurs";
		AbstractCommand output = parser.parseInput(input);
		ArrayList<String> searchKeyword = new ArrayList<String>();
		searchKeyword.add("this");
		searchKeyword.add("thurs");
		DisplayCommand expected = new DisplayCommand(searchKeyword);
		assertEquals(expected, output);
	}

	@Test
	public void searchBySearchKeywordLastWednesday() {
		String input = "search /last Wednesday";
		AbstractCommand output = parser.parseInput(input);
		ArrayList<String> searchKeyword = new ArrayList<String>();
		searchKeyword.add("last");
		searchKeyword.add("Wednesday");
		DisplayCommand expected = new DisplayCommand(searchKeyword);
		assertEquals(expected, output);
	}

	@Test
	public void searchBySearchKeywordNextSaturday() {
		String input = "search next /saturday";
		AbstractCommand output = parser.parseInput(input);
		ArrayList<String> searchKeyword = new ArrayList<String>();
		searchKeyword.add("next");
		searchKeyword.add("saturday");
		DisplayCommand expected = new DisplayCommand(searchKeyword);
		assertEquals(expected, output);
	}

	@Test
	public void searchBySearchKeywordManyWords() {
		String input = "search lord of the rings";
		AbstractCommand output = parser.parseInput(input);
		ArrayList<String> searchKeyword = new ArrayList<String>();
		searchKeyword.add("lord");
		searchKeyword.add("of");
		searchKeyword.add("the");
		searchKeyword.add("rings");
		DisplayCommand expected = new DisplayCommand(searchKeyword);
		assertEquals(expected, output);
	}

	@Test
	public void searchBySearchKeywordAll() {
		String input = "search all";
		AbstractCommand output = parser.parseInput(input);
		ArrayList<String> searchKeyword = new ArrayList<String>();
		searchKeyword.add("all");
		DisplayCommand expected = new DisplayCommand(searchKeyword);
		assertEquals(expected, output);
	}

	@Test
	public void searchBySearchDate2() {
		String input = "search 08 MAY 2015";
		AbstractCommand output = parser.parseInput(input);
		DisplayCommand expected = new DisplayCommand(
				getDateTime("08 05 2015 " + dummyTime));
		assertEquals(expected, output);
	}

	@Test
	public void searchBySearchDate3() {
		String input = "search 17 june";
		AbstractCommand output = parser.parseInput(input);
		DisplayCommand expected = new DisplayCommand(
				getDateTime("17 06 " + getCorrectYear("17 06") + " " + 
						dummyTime));
		assertEquals(expected, output);
	}

	@Test
	public void searchBySearchDate4() {
		String input = "search 14july 2015";
		AbstractCommand output = parser.parseInput(input);
		DisplayCommand expected = new DisplayCommand(
				getDateTime("14 07 2015" + " " + dummyTime));
		assertEquals(expected, output);
	}

	@Test
	public void searchBySearchDate5() {
		String input = "search 3Aug";
		AbstractCommand output = parser.parseInput(input);
		DisplayCommand expected = new DisplayCommand(
				getDateTime("03 08 " + getCorrectYear("03 08") + " " 
						+ dummyTime));
		assertEquals(expected, output);
	}

	@Test
	public void searchBySearchKeywordFromTmr() {
		String input = "search /from /tmr";
		AbstractCommand output = parser.parseInput(input);
		ArrayList<String> searchKeyword = new ArrayList<String>();
		searchKeyword.add("from");
		searchKeyword.add("tmr");
		DisplayCommand expected = new DisplayCommand(searchKeyword);
		assertEquals(expected, output);
	}

	@Test
	public void searchBySearchKeywordFromToday() {
		String input = "search from /today";
		AbstractCommand output = parser.parseInput(input);
		ArrayList<String> searchKeyword = new ArrayList<String>();
		searchKeyword.add("from");
		searchKeyword.add("today");
		DisplayCommand expected = new DisplayCommand(searchKeyword);
		assertEquals(expected, output);
	}

	@Test
	public void searchBySearchKeywordFromYesterday() {
		String input = "search /from yesterday";
		AbstractCommand output = parser.parseInput(input);
		ArrayList<String> searchKeyword = new ArrayList<String>();
		searchKeyword.add("from");
		searchKeyword.add("yesterday");
		DisplayCommand expected = new DisplayCommand(searchKeyword);
		assertEquals(expected, output);
	}

	@Test
	public void searchBySearchKeywordFromLastFriday() {
		String input = "search /from /last /friday";
		AbstractCommand output = parser.parseInput(input);
		ArrayList<String> searchKeyword = new ArrayList<String>();
		searchKeyword.add("from");
		searchKeyword.add("last");
		searchKeyword.add("friday");
		DisplayCommand expected = new DisplayCommand(searchKeyword);
		assertEquals(expected, output);
	}

	@Test
	public void searchBySearchKeywordFromThisThurs() {
		String input = "search /from this thurs";
		AbstractCommand output = parser.parseInput(input);
		ArrayList<String> searchKeyword = new ArrayList<String>();
		searchKeyword.add("from");
		searchKeyword.add("this");
		searchKeyword.add("thurs");
		DisplayCommand expected = new DisplayCommand(searchKeyword);
		assertEquals(expected, output);
	}

	@Test
	public void searchBySearchKeywordFromNextWed() {
		String input = "search from /next Wed";
		AbstractCommand output = parser.parseInput(input);
		ArrayList<String> searchKeyword = new ArrayList<String>();
		searchKeyword.add("from");
		searchKeyword.add("next");
		searchKeyword.add("Wed");
		DisplayCommand expected = new DisplayCommand(searchKeyword);
		assertEquals(expected, output);
	}

	@Test
	public void searchBySearchKeywordFromThisTuesday() {
		String input = "search from this /tuesday";
		AbstractCommand output = parser.parseInput(input);
		ArrayList<String> searchKeyword = new ArrayList<String>();
		searchKeyword.add("from");
		searchKeyword.add("this");
		searchKeyword.add("tuesday");
		DisplayCommand expected = new DisplayCommand(searchKeyword);
		assertEquals(expected, output);
	}

	// *******************************************************************
	// *******************************************************************
	// FOR MARK AND UNMARK COMMAND
	// *******************************************************************
	// *******************************************************************

	@Test
	public void markByIndex() {
		String input = "mark 54";
		AbstractCommand output = parser.parseInput(input);
		MarkCommand expected = new MarkCommand(54);
		expected.setMarkField(MarkCommand.markField.MARK);
		assertEquals(expected, output);
	}

	@Test
	public void markBySearchKeywordNumber() {
		String input = "mark /54";
		AbstractCommand output = parser.parseInput(input);
		MarkCommand expected = new MarkCommand("54");
		expected.setMarkField(MarkCommand.markField.MARK);
		assertEquals(expected, output);
	}

	@Test
	public void mBySearchKeywordOneWord() {
		String input = "m meeting";
		AbstractCommand output = parser.parseInput(input);
		MarkCommand expected = new MarkCommand("meeting");
		expected.setMarkField(MarkCommand.markField.MARK);
		assertEquals(expected, output);
	}

	@Test
	public void markBySearchKeywordManyWords() {
		String input = "MARK harry potter and the chamber of secrets";
		AbstractCommand output = parser.parseInput(input);
		MarkCommand expected = new MarkCommand(
				"harry potter and the chamber of secrets");
		expected.setMarkField(MarkCommand.markField.MARK);
		assertEquals(expected, output);
	}

	@Test
	public void unmarkByIndex() {
		String input = "UNMARK 03";
		AbstractCommand output = parser.parseInput(input);
		MarkCommand expected = new MarkCommand(3);
		expected.setMarkField(MarkCommand.markField.UNMARK);
		assertEquals(expected, output);
	}

	@Test
	public void unmarkBySearchKeywordNumber() {
		String input = "UNMARK /03";
		AbstractCommand output = parser.parseInput(input);
		MarkCommand expected = new MarkCommand("03");
		expected.setMarkField(MarkCommand.markField.UNMARK);
		assertEquals(expected, output);
	}

	@Test
	public void unmarkBySearchKeywordOneWord() {
		String input = "unmark lecture";
		AbstractCommand output = parser.parseInput(input);
		MarkCommand expected = new MarkCommand("lecture");
		expected.setMarkField(MarkCommand.markField.UNMARK);
		assertEquals(expected, output);
	}

	@Test
	public void umBySearchKeywordManyWords() {
		String input = "um this is a long sentence";
		AbstractCommand output = parser.parseInput(input);
		MarkCommand expected = new MarkCommand("this is a long sentence");
		expected.setMarkField(MarkCommand.markField.UNMARK);
		assertEquals(expected, output);
	}

	@Test
	public void markEmpty() {
		String input = "mark";
		AbstractCommand output = parser.parseInput(input);
		assertEquals(expectedInvalid, output);
	}

	@Test
	public void umEmpty() {
		String input = "um";
		AbstractCommand output = parser.parseInput(input);
		assertEquals(expectedInvalid, output);
	}

	// *******************************************************************
	// *******************************************************************
	// FOR UNDO COMMAND
	// *******************************************************************
	// *******************************************************************

	@Test
	public void undo() {
		String input = "undo";
		AbstractCommand output = parser.parseInput(input);
		UndoCommand expected = new UndoCommand();
		assertEquals(expected, output);
	}

	@Test
	public void u() {
		String input = "u";
		AbstractCommand output = parser.parseInput(input);
		UndoCommand expected = new UndoCommand();
		assertEquals(expected, output);
	}

	@Test
	public void undoExtra() {
		String input = "undo test";
		AbstractCommand output = parser.parseInput(input);
		assertEquals(expectedInvalid, output);
	}

	// *******************************************************************
	// *******************************************************************
	// FOR SAVE COMMAND
	// *******************************************************************
	// *******************************************************************

	@Test
	public void save() {
		String input = "save ~/Desktop";
		AbstractCommand output = parser.parseInput(input);
		SaveCommand expected = new SaveCommand("~/Desktop");
		assertEquals(expected, output);
	}

	@Test
	public void saveEmpty() {
		String input = "save";
		AbstractCommand output = parser.parseInput(input);
		assertEquals(expectedInvalid, output);
	}

	// *******************************************************************
	// *******************************************************************
	// FOR EXIT COMMAND
	// *******************************************************************
	// *******************************************************************

	@Test
	public void exit() {
		String input = "exit";
		AbstractCommand output = parser.parseInput(input);
		ExitCommand expected = new ExitCommand();
		assertEquals(expected, output);
	}

	@Test
	public void exitExtra() {
		String input = "exit something";
		AbstractCommand output = parser.parseInput(input);
		InvalidCommand expected = new InvalidCommand();
		assertEquals(expected, output);
	}

	// *******************************************************************
	// *******************************************************************
	// FOR UICOMMAND
	// *******************************************************************
	// *******************************************************************

	@Test
	public void day() {
		String input = "day";
		AbstractCommand output = parser.parseInput(input);
		UICommand expected = new UICommand();
		assertEquals(expected, output);
	}

	@Test
	public void night() {
		String input = "night";
		AbstractCommand output = parser.parseInput(input);
		UICommand expected = new UICommand();
		assertEquals(expected, output);
	}

	@Test
	public void hideYear() {
		String input = "hide year";
		AbstractCommand output = parser.parseInput(input);
		UICommand expected = new UICommand();
		assertEquals(expected, output);
	}

	@Test
	public void showYear() {
		String input = "show year";
		AbstractCommand output = parser.parseInput(input);
		UICommand expected = new UICommand();
		assertEquals(expected, output);
	}

	@Test
	public void help() {
		String input = "help";
		AbstractCommand output = parser.parseInput(input);
		UICommand expected = new UICommand();
		assertEquals(expected, output);
	}

	@Test
	public void quitHelp() {
		String input = "quit help";
		AbstractCommand output = parser.parseInput(input);
		UICommand expected = new UICommand();
		assertEquals(expected, output);
	}

	@Test
	public void dayExtra() {
		String input = "day extra";
		AbstractCommand output = parser.parseInput(input);
		InvalidCommand expected = new InvalidCommand();
		assertEquals(expected, output);
	}

	@Test
	public void showYearExtra() {
		String input = "show year test something test";
		AbstractCommand output = parser.parseInput(input);
		InvalidCommand expected = new InvalidCommand();
		assertEquals(expected, output);
	}

	@Test
	public void quitHelpExtra() {
		String input = "quit help please";
		AbstractCommand output = parser.parseInput(input);
		assertEquals(expectedInvalid, output);
	}

	@Test
	public void nightWhiteSpace() {
		String input = "night   ";
		AbstractCommand output = parser.parseInput(input);
		UICommand expected = new UICommand();
		assertEquals(expected, output);
	}

	@Test
	public void hideYearWhiteSpaces() {
		String input = "hide year     ";
		AbstractCommand output = parser.parseInput(input);
		UICommand expected = new UICommand();
		assertEquals(expected, output);
	}

	@Test
	public void helpWhiteSpace() {
		String input = "help       ";
		AbstractCommand output = parser.parseInput(input);
		UICommand expected = new UICommand();
		assertEquals(expected, output);
	}

}
```
###### test\SystemTest.java
``` java
public class SystemTest {

	private OverviewController controller;
	private Output expected;
	private ArrayList<ArrayList<String>> expectedArrArrList;
	private ArrayList<ArrayList<String>> expectedSearchList;

	private void resetIndex() {
		for (int i = 0; i < expectedArrArrList.size(); i++) {
			expectedArrArrList.get(i).set(0, i + 1 + Constants.EMPTY);
		}
	}

	private ArrayList<ArrayList<String>> clean() {
		return new ArrayList<ArrayList<String>>();
	}

	private ArrayList<String> getDateInfo(LocalDateTime dt) {
		ArrayList<String> answer = new ArrayList<String>();
		answer.add(getDayOfWeek(dt));
		answer.add(getDay(dt));
		answer.add(getMonth(dt));
		answer.add(getYear(dt));
		return answer;
	}

	private ArrayList<String> getEmptyDTInfo() {
		ArrayList<String> answer = new ArrayList<String>();
		answer.add(Constants.EMPTY);
		answer.add(Constants.EMPTY);
		answer.add(Constants.EMPTY);
		answer.add(Constants.EMPTY);
		answer.add(Constants.EMPTY);
		return answer;
	}

	private ArrayList<String> getTodayInfo() {
		LocalDateTime now = LocalDateTime.now();
		ArrayList<String> answer = new ArrayList<String>();
		answer.add(getDayOfWeek(now));
		answer.add(Constants.TODAY.toUpperCase());
		answer.add(Constants.EMPTY);
		answer.add(Constants.EMPTY);
		return answer;
	}

	private String getDayOfWeek(LocalDateTime dt) {
		return dt.getDayOfWeek().toString().substring(0, 3);
	}

	private String getDay(LocalDateTime dt) {
		return dt.getDayOfMonth() + Constants.EMPTY;
	}

	private String getMonth(LocalDateTime dt) {
		return dt.getMonth().toString().substring(0, 3);
	}

	private String getYear(LocalDateTime dt) {
		return dt.getYear() + Constants.EMPTY;
	}

	@Before
	public void setUp() {
		controller = new OverviewController();
		expected = new Output();
		expectedArrArrList = new ArrayList<ArrayList<String>>();
		expectedSearchList = new ArrayList<ArrayList<String>>();
	}

	@Test
	public void systemTest1() {
		controller.processInput("delete all");
		// ==================================================================================
		ArrayList<String> task1 = new ArrayList<String>();
		LocalDateTime dt1 = LocalDateTime.now().with(DayOfWeek.THURSDAY);
		task1.add("1");
		task1.add("attend yoga class");
		task1.add("7pm");
		task1.addAll(getDateInfo(dt1));
		task1.add("8:30pm");
		task1.addAll(getDateInfo(dt1));
		task1.add("UNDONE");
		task1.add("");

		ArrayList<String> task2 = new ArrayList<String>();
		LocalDateTime dt2 = LocalDateTime.now().with(DayOfWeek.FRIDAY);
		task2.add("2");
		task2.add("annual general meeting");
		task2.add("10am");
		task2.addAll(getDateInfo(dt2));
		task2.add("11am");
		task2.addAll(getDateInfo(dt2));
		task2.add("UNDONE");
		task2.add("");

		ArrayList<String> task3 = new ArrayList<String>();
		LocalDateTime dt3 = LocalDateTime.now().with(DayOfWeek.MONDAY).plusWeeks(1);
		task3.add("3");
		task3.add("send meeting minutes");
		task3.addAll(getEmptyDTInfo());
		task3.add("8am");
		task3.addAll(getDateInfo(dt3));
		task3.add("UNDONE");
		task3.add("false");

		ArrayList<String> task4 = new ArrayList<String>();
		LocalDateTime dt4 = LocalDateTime.now().with(DayOfWeek.MONDAY).plusWeeks(1).plusDays(2);
		task4.add("4");
		task4.add("submit progress report");
		task4.addAll(getEmptyDTInfo());
		task4.add("6pm");
		task4.addAll(getDateInfo(dt4));
		task4.add("UNDONE");
		task4.add("false");

		ArrayList<String> task4b = new ArrayList<String>();
		task4b.add("4");
		task4b.add("submit ninja report");
		task4b.addAll(getEmptyDTInfo());
		task4b.add("3pm");
		task4b.addAll(getDateInfo(dt4));
		task4b.add("UNDONE");
		task4b.add("false");

		ArrayList<String> task5 = new ArrayList<String>();
		task5.add("5");
		task5.add("buy bread");
		task5.addAll(getEmptyDTInfo());
		task5.addAll(getEmptyDTInfo());
		task5.add("UNDONE");
		task5.add("");
		// ==================================================================================
		String input1 = "create attend yoga class from 7pm to 8:30pm this thurs";
		Output output1 = controller.processInput(input1);
		expectedArrArrList.add(task1);
		expected.setOutput(clean());
		expected.setReturnMessage("\"attend yoga class\" has been created!");
		assertEquals(expected, output1);
		// ==================================================================================
		String input2 = "create annual general meeting from 10:00 to 11:00 this friday";
		Output output2 = controller.processInput(input2);
		expectedArrArrList.add(task2);
		expected.setOutput(clean());
		expected.setReturnMessage("\"annual general meeting\" has been created!");
		assertEquals(expected, output2);
		// ==================================================================================
		String input3 = "create send meeting minutes by 8AM next Mon";
		Output output3 = controller.processInput(input3);
		expectedArrArrList.add(task3);
		expected.setOutput(clean());
		expected.setReturnMessage("\"send meeting minutes\" has been created!");
		assertEquals(expected, output3);
		// ==================================================================================
		String input4 = "create submit progress report by 6PM next Wednesday";
		Output output4 = controller.processInput(input4);
		expectedArrArrList.add(task4);
		expected.setOutput(clean());
		expected.setReturnMessage("\"submit progress report\" has been created!");
		assertEquals(expected, output4);
		// ==================================================================================
		String input5 = "create buy bread";
		Output output5 = controller.processInput(input5);
		expectedArrArrList.add(task5);
		expected.setOutput(clean());
		expected.setReturnMessage("\"buy bread\" has been created!");
		assertEquals(expected, output5);
		// ==================================================================================
		String input6 = "display all";
		Output output6 = controller.processInput(input6);
		expected.setOutput(expectedArrArrList);
		expected.setReturnMessage("All tasks are now displayed!");
		assertEquals(expected, output6);
		// ==================================================================================
		String input7 = "edit 4 to submit ninja report end to 3pm";
		Output output7 = controller.processInput(input7);
		expectedArrArrList.set(3, task4b);
		expected.setOutput(clean());
		expected.setReturnMessage("\"submit progress report\" has been edited!");
		assertEquals(expected, output7);
		// ==================================================================================
		String input8 = "display all";
		Output output8 = controller.processInput(input8);
		expected.setOutput(expectedArrArrList);
		expected.setReturnMessage("All tasks are now displayed!");
		assertEquals(expected, output8);
		// ==================================================================================
		String input9 = "delete annual general meeting";
		Output output9 = controller.processInput(input9);
		expectedArrArrList.remove(1);
		resetIndex();
		expected.setOutput(clean());
		expected.setReturnMessage("\"annual general meeting\" has been deleted!");
		expected.setPriority(Output.Priority.HIGH);
		assertEquals(expected, output9);
		expected.setPriority(Output.Priority.LOW);
		// ==================================================================================
		String input10 = "display all";
		Output output10 = controller.processInput(input10);
		expected.setOutput(expectedArrArrList);
		expected.setReturnMessage("All tasks are now displayed!");
		assertEquals(expected, output10);
		// ==================================================================================
		String input11 = "mark 2";
		Output output11 = controller.processInput(input11);
		expectedArrArrList.get(1).set(12, "DONE");
		expected.setOutput(clean());
		expected.setReturnMessage("\"send meeting minutes\" has been marked done.");
		assertEquals(expected, output11);
		// ==================================================================================
		String input12 = "display all";
		Output output12 = controller.processInput(input12);
		expected.setOutput(expectedArrArrList);
		expected.setReturnMessage("All tasks are now displayed!");
		assertEquals(expected, output12);
		// ==================================================================================
		String input13 = "unmark send meeting minutes";
		Output output13 = controller.processInput(input13);
		expectedArrArrList.get(1).set(12, "UNDONE");
		expected.setOutput(new ArrayList<ArrayList<String>>());
		expected.setReturnMessage("\"send meeting minutes\" has been marked undone.");
		assertEquals(expected, output13);
		// ==================================================================================
		String input14 = "display all";
		Output output14 = controller.processInput(input14);
		expected.setOutput(expectedArrArrList);
		expected.setReturnMessage("All tasks are now displayed!");
		assertEquals(expected, output14);
	}

	@Test
	public void systemTest2() {
		controller.processInput("delete all");
		// ==================================================================================
		ArrayList<String> task1 = new ArrayList<String>();
		task1.add("1");
		task1.add("make-up class");
		task1.add("8am");
		task1.addAll(getTodayInfo());
		task1.add("9:30am");
		task1.addAll(getTodayInfo());
		task1.add("UNDONE");
		task1.add("");

		ArrayList<String> task2 = new ArrayList<String>();
		LocalDateTime dt2 = LocalDateTime.now().with(DayOfWeek.MONDAY).plusWeeks(1).plusDays(4);
		task2.add("2");
		task2.add("alumni gathering");
		task2.add("7:15pm");
		task2.addAll(getDateInfo(dt2));
		task2.add("11:59pm");
		task2.addAll(getDateInfo(dt2));
		task2.add("UNDONE");
		task2.add("");

		ArrayList<String> task3 = new ArrayList<String>();
		LocalDateTime dt3 = LocalDateTime.now().with(DayOfWeek.MONDAY).minusWeeks(1).plusDays(6);
		task3.add("3");
		task3.add("birthday");
		task3.add("12am");
		task3.addAll(getDateInfo(dt3));
		task3.add("11:59pm");
		task3.addAll(getDateInfo(dt3));
		task3.add("UNDONE");
		task3.add("");

		ArrayList<String> task4 = new ArrayList<String>();
		LocalDateTime dt4 = LocalDateTime.now().plusDays(1);
		task4.add("4");
		task4.add("submit alumni report");
		task4.addAll(getEmptyDTInfo());
		task4.add("5am");
		task4.addAll(getDateInfo(dt4));
		task4.add("UNDONE");
		task4.add("false");

		ArrayList<String> task4b = new ArrayList<String>();
		task4b.add("4");
		task4b.add("submit alumni report");
		task4b.addAll(getEmptyDTInfo());
		task4b.add("5am");
		task4b.addAll(getDateInfo(dt4));
		task4b.add("UNDONE");
		task4b.add("false");

		ArrayList<String> task5 = new ArrayList<String>();
		task5.add("5");
		task5.add("buy bread");
		task5.addAll(getEmptyDTInfo());
		task5.addAll(getEmptyDTInfo());
		task5.add("UNDONE");
		task5.add("");

		ArrayList<String> task5b = new ArrayList<String>();
		task5b.add("5");
		task5b.add("agar agar");
		task5b.addAll(getEmptyDTInfo());
		task5b.addAll(getEmptyDTInfo());
		task5b.add("UNDONE");
		task5b.add("");
		// ==================================================================================
		String input1 = "create make-up class from today 8:00 to 09:30am";
		Output output1 = controller.processInput(input1);
		expectedArrArrList.add(task1);
		expected.setOutput(clean());
		expected.setReturnMessage("\"make-up class\" has been created!");
		assertEquals(expected, output1);
		// ==================================================================================
		String input2 = "create alumni gathering from 7:15PM to 23:59 next fri";
		Output output2 = controller.processInput(input2);
		expectedArrArrList.add(task2);
		expected.setOutput(clean());
		expected.setReturnMessage("\"alumni gathering\" has been created!");
		assertEquals(expected, output2);
		// ==================================================================================
		String input3 = "create birthday on last sun";
		Output output3 = controller.processInput(input3);
		expectedArrArrList.add(0, task3);
		expected.setOutput(clean());
		expected.setReturnMessage("\"birthday\" has been created!");
		assertEquals(expected, output3);
		// ==================================================================================
		String input4 = "create submit alumni report by 5am tmr";
		Output output4 = controller.processInput(input4);
		expectedArrArrList.add(2, task4);
		resetIndex();
		expected.setOutput(clean());
		expected.setReturnMessage("\"submit alumni report\" has been created!");
		assertEquals(expected, output4);
		// ==================================================================================
		String input5 = "create buy bread";
		Output output5 = controller.processInput(input5);
		expectedArrArrList.add(task5);
		expected.setOutput(clean());
		expected.setReturnMessage("\"buy bread\" has been created!");
		assertEquals(expected, output5);
		// ==================================================================================
		String input6 = "display all";
		Output output6 = controller.processInput(input6);
		expected.setOutput(expectedArrArrList);
		expected.setReturnMessage("All tasks are now displayed!");
		assertEquals(expected, output6);
		// ==================================================================================
		String input7 = "edit alumni to hello jello start to 5pm";
		Output output7 = controller.processInput(input7);
		expectedSearchList.add(new ArrayList<String>(task4));
		expectedSearchList.get(0).set(0, "1");
		expectedSearchList.add(new ArrayList<String>(task2));
		expectedSearchList.get(1).set(0, "2");
		expected.setOutput(expectedSearchList);
		expected.setReturnMessage("All tasks with keyword \"alumni\" are now displayed!");
		assertEquals(expected, output7);
		// ==================================================================================
		String input8 = "edit 1";
		Output output8 = controller.processInput(input8);
		expectedArrArrList.get(2).set(1, "hello jello");
		expected.setOutput(clean());
		expected.setReturnMessage("Invalid: Task specified does not have this operation.");
		expected.setPriority(Output.Priority.HIGH);
		assertEquals(expected, output8);
		expected.setPriority(Output.Priority.LOW);
		// ==================================================================================
		String input9 = "edit bread to agar agar";
		Output output9 = controller.processInput(input9);
		expectedSearchList = clean();
		expectedSearchList.add(new ArrayList<String>(task5));
		expectedSearchList.get(0).set(0, "1");
		expected.setOutput(expectedSearchList);
		expected.setReturnMessage("All tasks with keyword \"bread\" are now displayed!");
		assertEquals(expected, output9);
		// ==================================================================================
		String input10 = "edit 1";
		Output output10 = controller.processInput(input10);
		expectedArrArrList.set(4, task5b);
		expected.setOutput(clean());
		expected.setReturnMessage("\"buy bread\" has been edited!");
		assertEquals(expected, output10);
		// ==================================================================================
		String input11 = "display all";
		Output output11 = controller.processInput(input11);
		expected.setOutput(expectedArrArrList);
		expected.setReturnMessage("All tasks are now displayed!");
		assertEquals(expected, output11);
		// ==================================================================================
		String input12 = "undo";
		Output output12 = controller.processInput(input12);
		expectedArrArrList.set(4, task5);
		expected.setOutput(clean());
		expected.setReturnMessage("\"edit\" action has been undone!");
		assertEquals(expected, output12);
		// ==================================================================================
		String input13 = "mark birthday";
		Output output13 = controller.processInput(input13);
		expectedArrArrList.get(4).set(12, "DONE");
		expected.setOutput(clean());
		expected.setReturnMessage("\"birthday\" has been marked done.");
		assertEquals(expected, output13);
		// ==================================================================================
		String input14 = "unmark 1";
		Output output14 = controller.processInput(input14);
		expectedArrArrList.get(4).set(12, "UNDONE");
		expected.setOutput(clean());
		expected.setReturnMessage("\"birthday\" has been marked undone.");
		assertEquals(expected, output14);
		// ==================================================================================
		String input15 = "help";
		Output output15 = controller.processInput(input15);
		expected.setReturnMessage(" ");
		assertEquals(expected, output15);
		// ==================================================================================
		String input16 = "quit help";
		Output output16 = controller.processInput(input16);
		expected.setReturnMessage(" ");
		assertEquals(expected, output16);
		// ==================================================================================
		String input17 = "day";
		Output output17 = controller.processInput(input17);
		expected.setReturnMessage(" ");
		assertEquals(expected, output17);
		// ==================================================================================
		String input18 = "night";
		Output output18 = controller.processInput(input18);
		expected.setReturnMessage(" ");
		assertEquals(expected, output18);
		// ==================================================================================
		String input19 = "show year";
		Output output19 = controller.processInput(input19);
		expected.setReturnMessage(" ");
		assertEquals(expected, output19);
		// ==================================================================================
		String input20 = "hide year";
		Output output20 = controller.processInput(input20);
		expected.setReturnMessage(" ");
		assertEquals(expected, output20);
	}

	@Test
	public void systemTest3() {
		controller.processInput("delete all");
		// ==================================================================================
		ArrayList<String> task1 = new ArrayList<String>();
		LocalDateTime dt1 = LocalDateTime.parse("05 11 2015 " + Constants.DUMMY_TIME_S, Constants.DTFormatter);
		task1.add("1");
		task1.add("lab revision");
		task1.addAll(getEmptyDTInfo());
		task1.add("10:30pm");
		task1.addAll(getDateInfo(dt1));
		task1.add("UNDONE");
		task1.add("true");

		ArrayList<String> task2 = new ArrayList<String>();
		LocalDateTime dt2 = LocalDateTime.parse("29 02 2016 " + Constants.DUMMY_TIME_S, Constants.DTFormatter);
		task2.add("2");
		task2.add("prom");
		task2.add("6pm");
		task2.addAll(getDateInfo(dt2));
		task2.add("11pm");
		task2.addAll(getDateInfo(dt2));
		task2.add("UNDONE");
		task2.add("");

		ArrayList<String> task3 = new ArrayList<String>();
		LocalDateTime dt3 = LocalDateTime.parse("06 01 2016 " + Constants.DUMMY_TIME_S, Constants.DTFormatter);
		task3.add("3");
		task3.add("birthday");
		task3.add("12am");
		task3.addAll(getDateInfo(dt3));
		task3.add("11:59pm");
		task3.addAll(getDateInfo(dt3));
		task3.add("UNDONE");
		task3.add("");

		ArrayList<String> task4 = new ArrayList<String>();
		LocalDateTime dt4 = LocalDateTime.parse("22 01 2016 " + Constants.DUMMY_TIME_S, Constants.DTFormatter);
		task4.add("4");
		task4.add("submit alumni report");
		task4.addAll(getEmptyDTInfo());
		task4.add("5am");
		task4.addAll(getDateInfo(dt4));
		task4.add("UNDONE");
		task4.add("false");

		ArrayList<String> task5 = new ArrayList<String>();
		LocalDateTime dt5a = LocalDateTime.parse("10 03 2016 " + Constants.DUMMY_TIME_S, Constants.DTFormatter);
		LocalDateTime dt5b = LocalDateTime.parse("02 04 2016 " + Constants.DUMMY_TIME_S, Constants.DTFormatter);
		task5.add("5");
		task5.add("staycation");
		task5.add("9am");
		task5.addAll(getDateInfo(dt5a));
		task5.add("9pm");
		task5.addAll(getDateInfo(dt5b));
		task5.add("UNDONE");
		task5.add("");

		ArrayList<String> task5b = new ArrayList<String>();
		LocalDateTime dt5c = LocalDateTime.parse("05 05 2016 " + Constants.DUMMY_TIME_S, Constants.DTFormatter);
		task5b.add("5");
		task5b.add("staycation");
		task5b.add("9am");
		task5b.addAll(getDateInfo(dt5c));
		task5b.add("9pm");
		task5b.addAll(getDateInfo(dt5c));
		task5b.add("UNDONE");
		task5b.add("");

		ArrayList<String> task6 = new ArrayList<String>();
		task6.add("5");
		task6.add("dance in the rain");
		task6.addAll(getEmptyDTInfo());
		task6.addAll(getEmptyDTInfo());
		task6.add("UNDONE");
		task6.add("");
		// ==================================================================================
		String input1 = "create lab revision by 10.30pm 5nov 2015";
		Output output1 = controller.processInput(input1);
		expectedArrArrList.add(task1);
		expected.setOutput(clean());
		expected.setReturnMessage("\"lab revision\" has been created!");
		assertEquals(expected, output1);
		// ==================================================================================
		String input2 = "create prom from 6pm to 11pm 29 february 2016";
		Output output2 = controller.processInput(input2);
		expectedArrArrList.add(task2);
		resetIndex();
		expected.setOutput(clean());
		expected.setReturnMessage("\"prom\" has been created!");
		assertEquals(expected, output2);
		// ==================================================================================
		String input3 = "create birthday on 6/1/2016";
		Output output3 = controller.processInput(input3);
		expectedArrArrList.add(1, task3);
		resetIndex();
		expected.setOutput(clean());
		expected.setReturnMessage("\"birthday\" has been created!");
		assertEquals(expected, output3);
		// ==================================================================================
		String input4 = "create submit alumni report by 5am 22-1-2016";
		Output output4 = controller.processInput(input4);
		expectedArrArrList.add(2, task4);
		resetIndex();
		expected.setOutput(clean());
		expected.setReturnMessage("\"submit alumni report\" has been created!");
		assertEquals(expected, output4);
		// ==================================================================================
		String input5 = "create staycation from 9am 10march 2016 to 9pm 2 apr 2016";
		Output output5 = controller.processInput(input5);
		expectedArrArrList.add(task5);
		resetIndex();
		expected.setOutput(clean());
		expected.setReturnMessage("\"staycation\" has been created!");
		assertEquals(expected, output5);
		// ==================================================================================
		String input6 = "create dance in the rain";
		Output output6 = controller.processInput(input6);
		expectedArrArrList.add(task6);
		resetIndex();
		expected.setOutput(clean());
		expected.setReturnMessage("\"dance in the rain\" has been created!");
		assertEquals(expected, output6);
		// ==================================================================================
		String input7 = "display all";
		Output output7 = controller.processInput(input7);
		expected.setOutput(expectedArrArrList);
		expected.setReturnMessage("All tasks are now displayed!");
		assertEquals(expected, output7);
		// ==================================================================================
		String input8 = "create ";
		Output output8 = controller.processInput(input8);
		expected.setOutput(clean());
		expected.setReturnMessage("Invalid Command!");
		expected.setPriority(Output.Priority.HIGH);
		assertEquals(expected, output8);
		expected.setPriority(Output.Priority.LOW);
		// ==================================================================================
		String input9 = "edit staycation start to 5/5/2016 end to 5/5/2016";
		Output output9 = controller.processInput(input9);
		expectedArrArrList.set(4, task5b);
		resetIndex();
		expected.setOutput(clean());
		expected.setReturnMessage("\"staycation\" has been edited!");
		assertEquals(expected, output9);
		// ==================================================================================
		String input10 = "display all";
		Output output10 = controller.processInput(input10);
		expected.setOutput(expectedArrArrList);
		expected.setReturnMessage("All tasks are now displayed!");
		assertEquals(expected, output10);
		// ==================================================================================
		String input11 = "search 29/02/2016";
		Output output11 = controller.processInput(input11);
		expectedSearchList = clean();
		task2.set(0, "1");
		expectedSearchList.add(task2);
		expected.setOutput(expectedSearchList);
		expected.setReturnMessage("All tasks with date \"29 02 2016\" are now displayed!");
		assertEquals(expected, output11);
		// ==================================================================================
		String input12 = "search staycation";
		Output output12 = controller.processInput(input12);
		expectedSearchList = clean();
		task5b.set(0, "1");
		expectedSearchList.add(task5b);
		expected.setOutput(expectedSearchList);
		expected.setReturnMessage("All tasks with keyword \"staycation\" are now displayed!");
		assertEquals(expected, output12);
		// ==================================================================================
		String input13 = "delete 1";
		Output output13 = controller.processInput(input13);
		expectedArrArrList.remove(4);
		resetIndex();
		expected.setOutput(clean());
		expected.setReturnMessage("\"staycation\" has been deleted!");
		expected.setPriority(Output.Priority.HIGH);
		assertEquals(expected, output13);
		expected.setPriority(Output.Priority.LOW);
		// ==================================================================================
		String input14 = "display all";
		Output output14 = controller.processInput(input14);
		expected.setOutput(expectedArrArrList);
		expected.setReturnMessage("All tasks are now displayed!");
		assertEquals(expected, output14);
		// ==================================================================================
		String input15 = "mark 1";
		Output output15 = controller.processInput(input15);
		expectedArrArrList.get(0).set(12, "DONE");
		expectedArrArrList.get(0).set(13, "false");
		expected.setOutput(clean());
		expected.setReturnMessage("\"lab revision\" has been marked done.");
		assertEquals(expected, output15);
		// ==================================================================================
		String input16 = "rubbish";
		Output output16 = controller.processInput(input16);
		expected.setOutput(clean());
		expected.setReturnMessage("Invalid Command!");
		expected.setPriority(Output.Priority.HIGH);
		assertEquals(expected, output16);
		expected.setPriority(Output.Priority.LOW);
		// ==================================================================================
		String input17 = "display floating";
		Output output17 = controller.processInput(input17);
		expectedSearchList = clean();
		task6.set(0, "1");
		expectedSearchList.add(task6);
		expected.setOutput(expectedSearchList);
		expected.setReturnMessage("All floating tasks are now displayed!");
		assertEquals(expected, output17);
		// ==================================================================================
		String input18 = "display done";
		Output output18 = controller.processInput(input18);
		expectedSearchList = clean();
		task1.set(0, "1");
		expectedSearchList.add(task1);
		expected.setOutput(expectedSearchList);
		expected.setReturnMessage("All DONE tasks are now displayed!");
		assertEquals(expected, output18);
		// ==================================================================================
		String input19 = "display unmark";
		Output output19 = controller.processInput(input19);
		expectedArrArrList.remove(0);
		resetIndex();
		expected.setOutput(expectedArrArrList);
		expected.setReturnMessage("All UNDONE tasks are now displayed!");
		assertEquals(expected, output19);
	}

}
```
