# A0133888N
###### shared\Constants.java
``` java
	// UI constants
	public static final String COLOR_DAY = "#c9daf8";
	public static final String COLOR_NIGHT = "#191970";
	public static final String COLOR_INPUT_DAY = "#337ab7";

	public static final String COMMAND_HIDE_YEAR = "hide year";
	public static final String COMMAND_SHOW_YEAR = "show year";
	public static final String COMMAND_DAY = "day";
	public static final String COMMAND_NIGHT = "night";
	public static final String COMMAND_HELP = "help";
	public static final String COMMAND_QUIT_HELP = "quit help";
	
	public static final String HELP_MESSAGE_CREATE = "e.g. create [task name] from [time] [date] to [time] [date]";
	public static final String HELP_MESSAGE_EDIT = "e.g. edit [index] to [new task name] start to [time] [date] end to [time] [date]";
	public static final String HELP_MESSAGE_DELETE = "e.g. delete [index]";
	public static final String HELP_MESSAGE_MARK = "e.g. mark [index]";
	public static final String HELP_MESSAGE_UNMARK = "e.g. unmark [index]";
	public static final String HELP_MESSAGE_DISPLAY = "e.g. display done";
	public static final String HELP_MESSAGE_SEARCH = "e.g. search [date]";
	public static final String HELP_MESSAGE_UNDO = "e.g. undo";
	public static final String HELP_MESSAGE_SAVE = "e.g. save [path]";
	public static final String HELP_MESSAGE_HELP = "Enter help to see all the help messages.";
	
	public static final String TIME_EARLIEST = "12am";
	public static final String TIME_LATEST = "11:59pm";
	public static final boolean isWin = System.getProperty("os.name").toLowerCase().contains("win");
	public static final int numberOfEquals = isWin ? 69 : 68;
	public static final String line = new String(new char[numberOfEquals]).replace("\0", "=");
	public static final String padding = "%-12s";
	
	//The text version of full help message is originally written by A0131188H
	public static final String[] HELP_MESSAGE_FULL = {
			 String.format("\nEnter \"%1$s\" to return to the normal view.", COMMAND_QUIT_HELP),
			 line,
			 "COMMANDS",
			 "To create floating tasks",
			 "create [task name]",
			 "",
			 "To create deadline-based tasks",
			 "create [task name] by [time] [date]",
			 "",
			 "To create event-based tasks",
			 "create [task name] from [time] to [time] [date]",
			 "OR",
			 "create [task name] from [time] [date] to [time] [date]",
			 "OR",
			 "create [task name] on [date]",
			 "",
			 "To show different views",
			 "display",
			 "display all", 
			 "display mark / display done", 
			 "display unmark / display undone",
			 "display floating",
			 "",
			 "To search tasks on a specific date",
			 "search [date] / display [date]",
			 "",
			 "To search by task name",
			 "search [task name] / display [task name]",
			 "",
			 "To edit tasks",
			 "edit [index] to [new task name]", 
			 "start to [time] [date]",
			 "end to [time] [date]",
			 "OR",
			 "edit [old task name] to [new task name]",
			 "start to [time] [date]", 
			 "end to [time] [date]",
			 "",
			 "To delete tasks",
			 "delete [index]",
			 "delete [task name]",
			 "delete all",
			 "",
			 "To mark or unmark tasks",
			 "mark [index]",
			 "mark [task name]",
			 "unmark [index]",
			 "unmark [task name]",
			 "",
			 "To undo command",
			 "undo",
			 "",
			 "To save path",
			 "save [path]",
			 "",
			 "To toggle between day and night view",
			 "day",
			 "night",
			 "",
			 "To toggle between view with year displayed", 
			 "and without year displayed",
			 "show year",
			 "hide year",
			 "",
			 "To open and close this help menu",
			 "help",
			 "quit help",
			 "",
			 "[TIME] ACCEPTED",
			 "hh am/pm",
			 "hh:mm am/pm OR hh.mm am/pm", 
			 "hh:mm OR hh.mm",
			 "",
			 "[DATE] ACCEPTED",
			 "dd/mm OR dd-mm OR dd [month]",
			 "dd/mm/yyyy OR dd-mm-yyyy OR dd [month] yyyy",
			 "yesterday/ytd OR today OR tomorrow/tmr",
			 "last/this/next [day]",
			 "",
			 "[DAY] ACCEPTED",
			 "Monday / Tuesday / Wednesday / Thursday / Friday / Saturday / Sunday",
			 "Mon / Tues / Wed / Thurs / Fri / Sat / Sun",
			 "",
			 "[MONTH] ACCEPTED",
			 "January / February / March / April / May / June / July / ",
			 "August / September / October / November / December",
			 "Jan / Feb / Mar / Apr / Jun / Jul / Aug / Sep / Oct / Nov / Dec",
			 "",
			 "SHORTCUTS ACCEPTED",
			 "Command    Alias",
			 String.format(padding, "create") + "c, add, a",
			 String.format(padding, "display") + "dp",
			 String.format(padding, "search") + "s",
			 String.format(padding, "edit") + "e",
			 String.format(padding, "delete") + "dl",
			 String.format(padding, "mark") + "m",
			 String.format(padding, "unmark") + "um",
			 String.format(padding, "undo") + "u"
		};

	// UI constants ends
	
```
###### shared\Output.java
``` java
/**
 * This class is used to enclose data transfered from logic to UI.
 */
public class Output {
	private String returnMessage;
	private ArrayList<ArrayList<String>> outputArrayList = new ArrayList<ArrayList<String>>();
	private Priority priority;
	private int indexUpdated;

	public static enum Priority {
		LOW, HIGH;
	}

	// Priority of message should be low by default since most messages are of
	// lower priority
	public Output() {
		this.priority = Priority.LOW;
	}
	
	public Output(String returnMessage) {
		this.priority = Priority.LOW;
		this.returnMessage = returnMessage;
	}
	
	public Output(String template, String variableContent) {
		this.priority = Priority.LOW;
		this.returnMessage = trimReturnMessage(template, variableContent);
	}
	
	public Output(TaskList taskList) {
		this.priority = Priority.LOW;
		ArrayList<ArrayList<String>> outputList = numberTaskList(taskList);
		this.setOutput(outputList);
	}
	
	public Output(Exception e) {
		this.setPriority(Priority.HIGH);
		this.setReturnMessage(e.getMessage());
	}
	
	public void setPriority(Priority priority) {
		this.priority = priority;
	}

	public Priority getPriority() {
		return this.priority;
	}

	public void setReturnMessage(String message) {
		returnMessage = message;
	}

	public String getReturnMessage() {
		return returnMessage;
	}

	public ArrayList<ArrayList<String>> getTasks() {
		return outputArrayList;
	}

	public void setOutput(ArrayList<ArrayList<String>> tasksArrayList) {
		outputArrayList = tasksArrayList;
	}

	public int getIndexUpdated() {
		return indexUpdated;
	}

	public void setIndexUpdated(int indexUpdated) {
		this.indexUpdated = indexUpdated;
	}
	
	private ArrayList<ArrayList<String>> numberTaskList(TaskList taskList) {
		ArrayList<ArrayList<String>> outputList = new ArrayList<ArrayList<String>>();

		for (int i = 0; i < taskList.size(); i++) {
			AbstractTask currentTask = taskList.getTask(i);
			ArrayList<String> taskArray = (currentTask.toArray());
			taskArray.add(0, String.valueOf(i + 1));
			outputList.add(taskArray);
		}
		
		return outputList;
	}
	
	private static String trimReturnMessage(String template, String content) {
		int ellipsisLength = 3;
		String ellipsis = "...";

		int templateLength = String.format(template, "").length();
		int contentLength = content.length();

		if (templateLength + contentLength < Constants.MESSAGE_LENGTH) {
			return String.format(template, content);
		} else {
			int newContentLength = Constants.MESSAGE_LENGTH - templateLength
					- ellipsisLength;
			String newContent = content.substring(0, newContentLength)
					+ ellipsis;
			return String.format(template, newContent);
		}
	}
	
	@Override
	public boolean equals(Object obj) {
		if (!(obj instanceof Output)) {
			return false;
		} else {
			Output that = (Output) obj;
			return Objects.equals(this.getReturnMessage(), that.getReturnMessage())
					&& Objects.equals(this.getTasks(), that.getTasks())
					&& Objects.equals(this.getPriority(), that.getPriority())
					&& Objects.equals(this.getIndexUpdated(), that.getIndexUpdated());
		}
	}
}
```
###### test\UITest.java
``` java
package test;

import static org.loadui.testfx.Assertions.verifyThat;
import static org.loadui.testfx.controls.Commons.hasText;

import org.junit.BeforeClass;
import org.junit.Test;
import org.loadui.testfx.GuiTest;
import org.loadui.testfx.utils.FXTestUtils;

import javafx.scene.Parent;
import javafx.scene.input.KeyCode;
import shared.Constants;
import ui.Main;

//[IMPORTANT] Please do not move your mouse or type during the tests!

public class UITest {
	private static GuiTest uiController;
	private static Main mainApp;

	@BeforeClass
	public static void setUpClass() {
		FXTestUtils.launchApp(Main.class);
		
		uiController = new GuiTest() {
			@Override
			protected Parent getRootNode() {
				return mainApp.getPrimaryStage().getScene().getRoot();
			}
		};
	}
	
	/**
	 * The app needs a short time to start, while the testing starts right away.
	 * Therefore, there need to be a bit buffer time, or the test input is not entered in
	 * the app, but somewhere else (e.g. This file), leading to test failure.
	 */
	public static void pause() {
		try {
			Thread.sleep(350);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
	
	@Test
	public void uiTest() {
		testInputClear();
		testInvalid();
		testCreate();
		testImmediateHelpMessage();
		testMark();
		testGetLastInput();
		testDeleteAll();
		testDeleteOne();
		testEditByIndex();
		testDisplayAll();
		testDisplayNothing();
		testUndo();
	}

	public void testInputClear() {
		pause();
		uiController.type("tests start");
		uiController.push(KeyCode.ENTER);
		uiController.type("create assignment 1");
		uiController.push(KeyCode.ENTER);
		verifyThat("#input", hasText(""));
	}

	public void testInvalid() {
		pause();
		uiController.type("delete all");
		uiController.push(KeyCode.ENTER);
		uiController.type("an invalid input");
		uiController.push(KeyCode.ENTER);
		verifyThat("#returnMessageLabel", hasText("Invalid Command!"));
	}

	public void testCreate() {
		pause();
		uiController.type("delete all");
		uiController.push(KeyCode.ENTER);
		uiController.type("create event1 from 10am today to 12pm tmr");
		uiController.push(KeyCode.ENTER);
		verifyThat("#returnMessageLabel",
				hasText("\"event1\" has been created!"));
		uiController.type("create event2 from 10am today to 12pm today");
		uiController.push(KeyCode.ENTER);
		verifyThat("#returnMessageLabel",
				hasText("\"event2\" has been created!"));
		uiController.type("create event3 by 11pm today");
		uiController.push(KeyCode.ENTER);
		verifyThat("#returnMessageLabel",
				hasText("\"event3\" has been created!"));
	}

	public void testImmediateHelpMessage() {
		pause();
		uiController.push(KeyCode.ENTER);
		uiController.type("create");
		verifyThat("#helpMessageLabel", hasText(Constants.HELP_MESSAGE_CREATE));
		uiController.push(KeyCode.ENTER);
		uiController.type("edit");
		verifyThat("#helpMessageLabel", hasText(Constants.HELP_MESSAGE_EDIT));
		uiController.push(KeyCode.ENTER);
		uiController.type("display");
		verifyThat("#helpMessageLabel", hasText(Constants.HELP_MESSAGE_DISPLAY));
		uiController.push(KeyCode.ENTER);
		uiController.type("delete");
		verifyThat("#helpMessageLabel", hasText(Constants.HELP_MESSAGE_DELETE));
		uiController.push(KeyCode.ENTER);
		uiController.type("undo");
		verifyThat("#helpMessageLabel", hasText(Constants.HELP_MESSAGE_UNDO));
		uiController.push(KeyCode.ENTER);
		uiController.type("mark");
		verifyThat("#helpMessageLabel", hasText(Constants.HELP_MESSAGE_MARK));
		uiController.push(KeyCode.ENTER);
		uiController.type("search");
		verifyThat("#helpMessageLabel", hasText(Constants.HELP_MESSAGE_SEARCH));
		uiController.push(KeyCode.ENTER);
		uiController.type("save");
		verifyThat("#helpMessageLabel", hasText(Constants.HELP_MESSAGE_SAVE));
		uiController.push(KeyCode.ENTER);
		uiController.type("help");
		verifyThat("#helpMessageLabel", hasText(Constants.HELP_MESSAGE_HELP));
		uiController.push(KeyCode.ENTER);
		uiController.type("quit help");
		uiController.push(KeyCode.ENTER);
	}

	private void testMark() {
		pause();
		uiController.type("delete all");
		uiController.push(KeyCode.ENTER);
		uiController.type("create a task");
		uiController.push(KeyCode.ENTER);
		uiController.type("mark 1");
		uiController.push(KeyCode.ENTER);
		verifyThat("#returnMessageLabel",
				hasText("\"a task\" has been marked done."));
	}

	private void testGetLastInput() {
		pause();
		uiController.type("delete all");
		uiController.push(KeyCode.ENTER);
		uiController.type("create meeting");
		uiController.push(KeyCode.ENTER);
		uiController.push(KeyCode.UP);
		verifyThat("#input", hasText("create meeting"));
		uiController.push(KeyCode.DOWN);
		verifyThat("#input", hasText(""));
	}
	
	public void testDeleteAll() {
		pause();
		uiController.type("delete all");
		uiController.push(KeyCode.ENTER);	
		verifyThat("#returnMessageLabel", hasText("All tasks have been deleted!"));
	}
	
	public void testDeleteOne() {
		pause();
		uiController.type("delete all");
		uiController.push(KeyCode.ENTER);	
		uiController.type("create 1");
		uiController.push(KeyCode.ENTER);	
		uiController.type("delete 1");
		uiController.push(KeyCode.ENTER);	
		verifyThat("#returnMessageLabel", hasText("\"1\" has been deleted!"));
	}
	
	public void testEditByIndex() {
		pause();
		uiController.type("delete all");
		uiController.push(KeyCode.ENTER);	
		uiController.type("create 1");
		uiController.push(KeyCode.ENTER);	
		uiController.type("edit 1 to 2");
		uiController.push(KeyCode.ENTER);	
		verifyThat("#returnMessageLabel", hasText("\"1\" has been edited!"));
	}

	public void testDisplayAll() {
		pause();
		uiController.type("create 1");
		uiController.push(KeyCode.ENTER);	
		uiController.type("display all");
		uiController.push(KeyCode.ENTER);	
		verifyThat("#returnMessageLabel", hasText("All tasks are now displayed!"));
	}
	
	public void testDisplayNothing() {
		pause();
		uiController.type("delete all");
		uiController.push(KeyCode.ENTER);	
		uiController.type("display all");
		uiController.push(KeyCode.ENTER);	
		verifyThat("#returnMessageLabel", hasText("There are no tasks to display :'("));
	}

	public void testUndo() {
		pause();
		uiController.type("create 1");
		uiController.push(KeyCode.ENTER);	
		uiController.type("undo");
		uiController.push(KeyCode.ENTER);	
		verifyThat("#returnMessageLabel", hasText("\"create\" action has been undone!"));
	}
	


}
```
###### ui\Main.java
``` java
public class Main extends Application {
	
    private Stage primaryStage;
    private BorderPane rootLayout;// empty
    private AnchorPane overview;

	@Override
	public void start(Stage primaryStage) {
		assert primaryStage != null;
        this.primaryStage = primaryStage;
        this.primaryStage.setTitle("Flexi-List");

        initRootLayout();
        showOverview();
	}
	
    /**
     * Initializes the root layout.
     */
    public void initRootLayout() {
        try {
            // Load root layout from fxml file.
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(Main.class.getResource("view/RootLayout.fxml"));
            rootLayout = (BorderPane) loader.load();
            assert rootLayout != null;

            // Show the scene containing the root layout.
            Scene scene = new Scene(rootLayout);
            primaryStage.setScene(scene);
            primaryStage.setHeight(700);
            primaryStage.setWidth(600);
            primaryStage.setResizable(false);
            primaryStage.show();
        } catch (IOException e) {
           System.err.println("Unable to load primaryStage " + e.getMessage());
        }
    }
    
    /**
     * Shows the overview inside the root layout.
     */
    public void showOverview() {
        try {
            // Load person overview.
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(Main.class.getResource("view/Overview.fxml"));// change to ui.class
            overview = (AnchorPane) loader.load();
            // Give the controller access to the main app
            OverviewController controller = loader.getController();
            controller.setMainApp(this);
            controller.initialize();
            
            rootLayout.setCenter(overview);

        } catch (IOException e) {
            System.err.println("Unable to load OverView.fxml " + e.getMessage());
        }
    }

    /**
     * Returns the main stage.
     * @return
     */
    public Stage getPrimaryStage() {
        return primaryStage;
    }

	public static void main(String[] args) {
		launch(args);
	}
}
```
###### ui\view\CalendarBox.java
``` java
package ui.view;

import java.util.List;

import javafx.scene.Group;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;

/**
 * This class is used to implement details of a calendar box.
 */
public class CalendarBox extends Group {

	private static final int SPLITTER_TRANSLATE_X = -19;
	private static final int SPLITTER_TRANSLATE_X_WIDE = -59;
	private static final int WEEKDAY_BACKGROUND_WIDTH = 12;
	private static final int WEEKDAY_TRANSLATE_X = -28;
	private static final int WEEKDAY_TRANSLATE_X_WIDE_ADJUST = -40;
	private static final int WEEKDAY_TRANSLATE_Y_MID = -1;
	private static final int WEEKDAY_TRANSLATE_Y_SPACING = 12;
	private static final int WEEKDAY_BACKGROUND_X_TRANSLATE = -9;
	private static final int TIME_DATEMONTH_TRANSLATE_X = 9;
	private static final int TIME_TRANSLATE_Y = -10;
	private static final int DATEMONTH_TRANSLATE_Y = 11;
	private static final int LIST_SIZE = 5;
	private static final Color COLOR_WEEKDAY = Color.BLACK;
	private static final Color COLOR_WEEKDAY_BACKGROUND = Color.YELLOW;
	private static final Color COLOR_DONE = Color.rgb(166, 166, 166); // moderately dark grey

	private boolean isWide;
	private boolean isDone;
	private boolean hasYear;
	private boolean isAllDay;
	private StackPane stackPane;
	private Rectangle calendarBox;
	private Color backgroundColor;
	private List<String> start;
	private List<String> end;

	public CalendarBox(Rectangle calendarBox, List<String> start, List<String> end, boolean isDone, boolean hasYear,
			boolean isWide, Color backgroundColor, boolean isAllDay) {

		initialize(calendarBox, start, end, isDone, hasYear, isWide, backgroundColor, isAllDay);
		addSplitter(isDone, isWide);
		addWeekDayBox();
		addWeekDay(end);
		addTime();
		addDateMonth(end);

	}

	private void initialize(Rectangle calendarBox, List<String> start, List<String> end, boolean isDone,
			boolean hasYear, boolean isWide, Color backgroundColor, boolean isAllDay) {
		assert start.size() == LIST_SIZE;
		assert end.size() == LIST_SIZE;
		this.start = start;
		this.end = end;
		this.isDone = isDone;
		this.hasYear = hasYear;
		this.isWide = isWide;
		this.isAllDay = isAllDay;
		this.stackPane = new StackPane();
		this.calendarBox = calendarBox;
		this.backgroundColor = backgroundColor;
		stackPane.getChildren().add(this.calendarBox);
		this.getChildren().add(stackPane);
	}

	/**
	 * Add a line splitting the weekday and the time. The color of the line
	 * synchronizes with the background of the enclosing task view.
	 * 
	 * @param isDone
	 * @param isWide
	 */
	private void addSplitter(boolean isDone, boolean isWide) {
		Rectangle splitter = new Rectangle();
		splitter.setHeight(calendarBox.getHeight());
		splitter.setWidth(2);
		if (!isDone) {
			splitter.setFill(backgroundColor);
		} else {
			splitter.setFill(Color.WHITE);
		}
		stackPane.getChildren().add(splitter);

		if (!isWide) {
			splitter.setTranslateX(SPLITTER_TRANSLATE_X);
		} else {
			splitter.setTranslateX(SPLITTER_TRANSLATE_X_WIDE);
		}

	}

	/**
	 * The three letters of a weekday are displayed vertically.
	 * 
	 * @param list
	 */
	private void addWeekDay(List<String> list) {

		String weekDay = list.get(1);
		if (weekDay.isEmpty()) {
			return;
		}
		processWeekDay(weekDay, 0, WEEKDAY_TRANSLATE_X, WEEKDAY_TRANSLATE_Y_MID - WEEKDAY_TRANSLATE_Y_SPACING);
		processWeekDay(weekDay, 1, WEEKDAY_TRANSLATE_X, WEEKDAY_TRANSLATE_Y_MID);
		processWeekDay(weekDay, 2, WEEKDAY_TRANSLATE_X, WEEKDAY_TRANSLATE_Y_MID + WEEKDAY_TRANSLATE_Y_SPACING);
	}

	private void processWeekDay(String weekDay, int charIndex, int CoordinateX, int CoordinateY) {
		Text weekDayChar = new Text();
		String weekDayString = weekDay.substring(charIndex, charIndex + 1);
		weekDayChar.setText(weekDayString);
		weekDayChar.setFill(COLOR_WEEKDAY);
		weekDayChar.setStyle("-fx-line-spacing: 0px;");
		stackPane.getChildren().add(weekDayChar);
		if (!isWide) {
			weekDayChar.setTranslateX(CoordinateX);
		} else {
			weekDayChar.setTranslateX(CoordinateX + WEEKDAY_TRANSLATE_X_WIDE_ADJUST);
		}

		weekDayChar.setTranslateY(CoordinateY);
		weekDayChar.setFont(Font.font("Monaco", FontWeight.BOLD, 12));
	}

	private void addWeekDayBox() {
		Rectangle weekDaybackGround = new Rectangle();
		weekDaybackGround.setWidth(WEEKDAY_BACKGROUND_WIDTH);
		weekDaybackGround.setHeight(calendarBox.getHeight() * 0.95);
		if (!isDone) {
			weekDaybackGround.setFill(COLOR_WEEKDAY_BACKGROUND);
		} else {
			weekDaybackGround.setFill(COLOR_DONE);
		}

		stackPane.getChildren().add(weekDaybackGround);

		if (!isWide) {
			weekDaybackGround.setTranslateX(SPLITTER_TRANSLATE_X + WEEKDAY_BACKGROUND_X_TRANSLATE);
		} else {
			weekDaybackGround.setTranslateX(SPLITTER_TRANSLATE_X_WIDE + WEEKDAY_BACKGROUND_X_TRANSLATE);
		}

	}

	private void addTime() {
		if (isAllDay) {
			Text allDay = new Text();
			allDay.setText("ALL DAY");
			stackPane.getChildren().add(allDay);
			allDay.setTranslateX(TIME_DATEMONTH_TRANSLATE_X);
			allDay.setTranslateY(TIME_TRANSLATE_Y);
		} else {
			Text time = new Text();
			if (!isWide) {
				time.setText(end.get(0));
			} else {
				time.setText(start.get(0) + " - " + end.get(0));
			}

			stackPane.getChildren().add(time);

			time.setTranslateX(TIME_DATEMONTH_TRANSLATE_X);
			time.setTranslateY(TIME_TRANSLATE_Y);
		}
	}

	private void addDateMonth(List<String> list) {
		assert list.get(2) + list.get(3) + list.get(4) != null;
		Text dateMonth = new Text();
		if (isToday(list) || list.get(0).equals("")) {
			hasYear = false;
		}
		if (!hasYear) {
			dateMonth.setText(list.get(2) + " " + list.get(3));
		} else if (!isWide) {
			// In a normal calendar box, only the last two digits of a year is
			// displayed.
			// E.g. '15 for 2015, where the " '" indicates abbreviation.
			dateMonth.setText(list.get(2) + " " + list.get(3) + " '" + list.get(4).substring(2, 4));
			dateMonth.setFont(Font.font(dateMonth.getFont().getSize() - 3));
			dateMonth.setTranslateX(-1);// minor adjustment
		} else {
			// In a wide calendar box, the year is displayed completely.
			// E.g. 2015 for 2015.
			dateMonth.setText(start.get(2) + " " + start.get(3) + " " + start.get(4));
		}

		stackPane.getChildren().add(dateMonth);

		dateMonth.setTranslateY(DATEMONTH_TRANSLATE_Y);
		dateMonth.setTranslateX(TIME_DATEMONTH_TRANSLATE_X);
	}

	private boolean isToday(List<String> list) {
		if (list.get(2).equals("TODAY")) {
			return true;
		} else {
			return false;
		}
	}

}
```
###### ui\view\CalendarView.java
``` java
package ui.view;

import java.util.List;

import javafx.geometry.Pos;
import javafx.scene.Group;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import shared.Constants;

/**
 * This class is used to display time and date of a task in a calendar view,
 * which includes time, date, weekday and year if applicable. If the task is a
 * deadline task, there is also a "by" word. If the task is a bounded task, with
 * different start and end date, there will be a dash connecting the two
 * calendar boxes.
 */
public class CalendarView extends Group {

	private static final int BOUNEDED_CONTAINER_HEIGHT = 44;
	private static final int CALENDARBOX_HEIGHT = BOUNEDED_CONTAINER_HEIGHT - 4;
	private static final int CALENDAR_NORMAL_WIDTH = 70;
	private static final int CALENDAR_WIDE_WIDTH = 150;
	private static final int BY_TRANSLATE_X = -15;
	private static final int BOX_RIGHT_TRANSLATE_X = 10;
	private static final int BY_FONTSIZE = 14;
	private static final int LIST_SIZE = 5;
	private static final Color CALENDAR_BACKGROUND = Color.WHITE;

	private boolean isDone;
	private boolean hasStart;
	private boolean isSameDay;
	private boolean hasYear;
	private boolean isAllDay;
	private boolean isWide;
	private List<String> start;
	private List<String> end;
	private StackPane stackPane;
	private CalendarBox viewLeft;
	private CalendarBox viewRight;
	private Rectangle boxLeft;
	private Rectangle boxRight;
	private Color backgroundColor;

	public CalendarView(List<String> start, List<String> end, boolean isDone, boolean hasYear, Color backgroundColor)
			throws Exception {
		initialize(start, end, isDone, hasYear, backgroundColor);
		addContent();
		finalizeView();

	}

	private void initialize(List<String> start, List<String> end, boolean isDone, boolean hasYear,
			Color backgroundColor) throws Exception {
		if (start == null || start.size() != LIST_SIZE) {
			throw new Exception("Invalid start list from taskView");
		}
		if (end == null || end.size() != LIST_SIZE) {
			throw new Exception("Invalid end list from taskView");
		}

		this.start = start;
		this.end = end;
		this.isDone = isDone;
		this.hasYear = hasYear;
		this.backgroundColor = backgroundColor;

		stackPane = new StackPane();
		stackPane.setAlignment(Pos.CENTER_LEFT);
		boxLeft = createEmptyCalendarBox();
		boxRight = createEmptyCalendarBox();
		hasStart = hasStart(start);
		setIsSameDay();
		setIsAllday();
	}

	private void finalizeView() {
		this.getChildren().add(stackPane);
	}

	private void addContent() {
		if (!hasStart) {
			addBoxOnRight();
		} else if (isSameDay) {
			if (isAllDay) {
				addBoxOnRightAllDay();
			} else {
				addWideBox();
			}
		} else {
			addTwoBoxes();
		}

	}

	/**
	 * Add a calendar box to the right, if it is a deadline task. And add the
	 * word "by".
	 */
	private void addBoxOnRight() {
		isWide = false;
		boxLeft.setWidth(CALENDAR_NORMAL_WIDTH);
		viewLeft = new CalendarBox(boxLeft, start, end, isDone, hasYear, isWide, backgroundColor, isAllDay);
		stackPane.getChildren().add(viewLeft);
		viewLeft.setTranslateX(CALENDAR_NORMAL_WIDTH + BOX_RIGHT_TRANSLATE_X);
		Text by = new Text();
		by.setText("by ");
		by.setFont(Font.font("Monaco", FontWeight.BOLD, BY_FONTSIZE));
		by.setFill(CALENDAR_BACKGROUND);
		stackPane.getChildren().add(by);
		by.setTranslateX(CALENDAR_NORMAL_WIDTH + BY_TRANSLATE_X);
	}

	private void addBoxOnRightAllDay() {
		isWide = true;
		boxLeft.setWidth(CALENDAR_WIDE_WIDTH);
		viewLeft = new CalendarBox(boxLeft, start, end, isDone, hasYear, isWide, backgroundColor, isAllDay);
		stackPane.getChildren().add(viewLeft);
	}

	/**
	 * Add a wide calendar box, if the task starts and ends on the same day.
	 */
	private void addWideBox() {
		isWide = true;
		boxLeft.setWidth(CALENDAR_WIDE_WIDTH);
		viewLeft = new CalendarBox(boxLeft, start, end, isDone, hasYear, isWide, backgroundColor, isAllDay);
		stackPane.getChildren().add(viewLeft);
	}

	/**
	 * Add two calendar boxes, if the task starts and ends on different dates.
	 * And add a dash in between.
	 */
	private void addTwoBoxes() {
		isWide = false;
		boxLeft.setWidth(CALENDAR_NORMAL_WIDTH);
		viewLeft = new CalendarBox(boxLeft, start, start, isDone, hasYear, isWide, backgroundColor, isAllDay);
		stackPane.getChildren().add(viewLeft);
		boxRight.setWidth(CALENDAR_NORMAL_WIDTH);
		viewRight = new CalendarBox(boxRight, end, end, isDone, hasYear, isWide, backgroundColor, isAllDay);
		stackPane.getChildren().add(viewRight);
		viewRight.setTranslateX(CALENDAR_NORMAL_WIDTH + BOX_RIGHT_TRANSLATE_X);

		Rectangle dash = new Rectangle();
		dash.setHeight(2);
		dash.setWidth(8);
		dash.setFill(CALENDAR_BACKGROUND);
		stackPane.getChildren().add(dash);
		dash.setTranslateX(CALENDAR_NORMAL_WIDTH + 1);// minor adjustment
	}

	private Rectangle createEmptyCalendarBox() {
		Rectangle calendarBox = new Rectangle();
		calendarBox.setHeight(CALENDARBOX_HEIGHT);
		calendarBox.setFill(CALENDAR_BACKGROUND);
		return calendarBox;
	}

	private boolean hasStart(List<String> start) {
		if (start == null) {
			return false;
		}
		if (start.get(0).length() == 0) {
			return false;
		} else {
			return true;
		}
	}

	private void setIsSameDay() {
		if (start == null) {
			isSameDay = false;
		}
		if (start.get(2).equals(end.get(2))) {
			isSameDay = true;
		} else {
			isSameDay = false;
		}
	}

	private void setIsAllday() {
		if (!isSameDay) {
			isAllDay = false;
		} else if (start.get(0).equals(Constants.TIME_EARLIEST) && end.get(0).equals(Constants.TIME_LATEST)) {
			isAllDay = true;
		} else {
			isAllDay = false;
		}
	}

}
```
###### ui\view\FullHelpView.java
``` java
package ui.view;

import java.util.ArrayList;
import java.util.Arrays;

import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.scene.text.TextFlow;
import shared.Constants;

/**
 * This class is used to display all of the help messages in the VBox.
 */
public class FullHelpView extends VBox {

	private static final boolean isWin = System.getProperty("os.name").toLowerCase().contains("win");
	private static final String COLOR_BACKGROUND = "#ffffff";// white
	private static final String HELP_FONT = isWin ? "Courier New" : "Monaco";
	private static final int HELP_FONTSIZE = 14;
	private static final int HELP_FONTSIZE_LARGE = 21;
	private static final int TEXT_INDENT = 10;
	private static final int HELP_SPACING = 5;
	private static final int HELPBOX_WIDTH = 600;
	private static final int HELPBOX_HEIGHT = 700;
	private static final int LINE_LENGTH = 70;

	private static final Color COLOR_TASKNAME = Color.rgb(0, 179, 0);// light green
	private static final Color COLOR_TIME = Color.rgb(0, 115, 230); // blue
	private static final Color COLOR_DATE = Color.rgb(230, 0, 0); // red
	private static final Color COLOR_INDEX = Color.rgb(255, 128, 0);// orange
	private static final Color COLOR_DAY_MONTH = Color.rgb(113, 87, 145);// violet
	private static final Color COLOR_PATH = Color.rgb(128, 0, 128);// purple

	private ArrayList<String> helpList;

	public FullHelpView() {

		initialize();
		loadHelp();
		addHelpMessage();
	}

	private void initialize() {
		this.setSpacing(HELP_SPACING);
		this.setPrefWidth(HELPBOX_WIDTH);
		this.setPrefHeight(HELPBOX_HEIGHT);
		this.setStyle(String.format("-fx-background-color: %1$s;", COLOR_BACKGROUND));

		helpList = new ArrayList<String>();
	}

	/**
	 * Stores the text from the Constants to helpList.
	 */
	private void loadHelp() {
		helpList.addAll(Arrays.asList(Constants.HELP_MESSAGE_FULL));
	}

	/**
	 * Display the content of helpList line by line.
	 */
	private void addHelpMessage() {
		for (String helpMessage : helpList) {
			TextFlow helpTextFlow = new TextFlow();
			addText(helpTextFlow, helpMessage);
			formatTextFlow(helpTextFlow, helpMessage);
		}
	}

	private void addText(TextFlow helpTextFlow, String helpMessage) {
		for (String message : helpMessage.split(" ")) {
			Text helpEntry = new Text();
			helpEntry.setText(message + " ");
			formatText(helpEntry, message);
			helpTextFlow.getChildren().add(helpEntry);
		}
	}

	private void formatText(Text helpEntry, String message) {
		switch (message) {
		case "[task":
		case "name]":
		case "[old":
		case "task":
		case "[new":
			helpEntry.setFill(COLOR_TASKNAME);
			break;
		case "[time]":
		case "[TIME]":
			helpEntry.setFill(COLOR_TIME);
			break;
		case "[date]":
		case "[DATE]":
			helpEntry.setFill(COLOR_DATE);
			break;
		case "[index]":
			helpEntry.setFill(COLOR_INDEX);
			break;
		case "[DAY]":
		case "[MONTH]":
		case "[month]":
			helpEntry.setFill(COLOR_DAY_MONTH);
			break;
		case "[path]":
			helpEntry.setFill(COLOR_PATH);
			break;
		default:
			break;
		}
	}

	private void formatTextFlow(TextFlow helpTextFlow, String helpMessage) {
		String firstWord = helpMessage.split(" ")[0];
		if (firstWord == null) {
			return;
		}
		// A message that is too long cannot be displayed correctly.
		assert helpMessage.length() <= LINE_LENGTH;
		switch (firstWord) {
		case "COMMANDS":
		case "[TIME]":
		case "[DATE]":
		case "[DAY]":
		case "[MONTH]":
		case "SHORTCUTS":
			helpTextFlow.getChildren().forEach(helpEntry -> {
				((Text) helpEntry).setFont(Font.font(HELP_FONT, FontWeight.BOLD, HELP_FONTSIZE_LARGE));
				((Text) helpEntry).setUnderline(true);
			});
			break;
		case "To":
		case "Command":
		case "and":
			helpTextFlow.getChildren().forEach(helpEntry -> {
				((Text) helpEntry).setUnderline(true);
				((Text) helpEntry).setFont(Font.font(HELP_FONT, FontWeight.BOLD, HELP_FONTSIZE));
			});
			break;
		default:
			helpTextFlow.getChildren().forEach(helpEntry -> {
				((Text) helpEntry).setFont(Font.font(HELP_FONT, FontWeight.BOLD, HELP_FONTSIZE));
			});
			break;
		}
		this.getChildren().add(helpTextFlow);
		helpTextFlow.setTranslateX(TEXT_INDENT);
	}

}
```
###### ui\view\HelpMessage.java
``` java
package ui.view;

import javafx.scene.control.Label;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.Text;
import shared.Constants;

/**
 * This class is used to generate and display immediate help messages upon
 * typing.
 */
public class HelpMessage {

	private static final int MESSAGE_FONT = 15;

	private Label helpMessageLabel;
	private Text helpMessageText;
	private String input;

	public HelpMessage(Label helpMessageLabel, Text helpMessageText) {
		initialize(helpMessageLabel, helpMessageText);
	}

	private void initialize(Label helpMessageLabel, Text helpMessageText) {
		this.helpMessageLabel = helpMessageLabel;
		this.helpMessageText = helpMessageText;
		this.helpMessageText.setFont(Font.font(MESSAGE_FONT));
		this.helpMessageLabel.setFont(Font.font(MESSAGE_FONT));
	}

	/**
	 * Generate help messages with regard to the input. Only specific inputs
	 * that match certain keywords will work.
	 * 
	 * @param input
	 */
	protected void genereateHelpMessage(String input) {
		this.input = input;
		String[] inputWords = this.input.split(" ");
		String command;

		if (inputWords.length > 0) {
			command = inputWords[0];
		} else {
			command = "";
		}

		switch (command) {
		case "create":
			helpMessageLabel.setText(Constants.HELP_MESSAGE_CREATE);
			break;
		case "edit":
			helpMessageLabel.setText(Constants.HELP_MESSAGE_EDIT);
			break;
		case "delete":
			helpMessageLabel.setText(Constants.HELP_MESSAGE_DELETE);
			break;
		case "display":
			helpMessageLabel.setText(Constants.HELP_MESSAGE_DISPLAY);
			break;
		case "mark":
			helpMessageLabel.setText(Constants.HELP_MESSAGE_MARK);
			break;
		case "ummark":
			helpMessageLabel.setText(Constants.HELP_MESSAGE_UNMARK);
			break;
		case "undo":
			helpMessageLabel.setText(Constants.HELP_MESSAGE_UNDO);
			break;
		case "search":
			helpMessageLabel.setText(Constants.HELP_MESSAGE_SEARCH);
			break;
		case "save":
			helpMessageLabel.setText(Constants.HELP_MESSAGE_SAVE);
			break;
		case "help":
			helpMessageLabel.setText(Constants.HELP_MESSAGE_HELP);
			break;
		default:
			helpMessageLabel.setText("");
			break;
		}
	}

	protected void cleanHelpMessage() {
		assert helpMessageLabel != null;
		assert helpMessageText != null;
		helpMessageLabel.setText("");
		helpMessageText.setText("");
	}

	protected boolean hasHelpMessage() {
		return helpMessageLabel.getText().length() > 0;
	}

	protected void changeTheme(String command) {
		if (command.equals(Constants.COMMAND_DAY)) {
			helpMessageLabel.setTextFill(Color.BLACK);
			helpMessageText.setFill(Color.BLACK);
		} else if (command.equals(Constants.COMMAND_NIGHT)) {
			helpMessageLabel.setTextFill(Color.WHITE);
			helpMessageText.setFill(Color.WHITE);
		}
	}
}
```
###### ui\view\InputRecord.java
``` java
package ui.view;

import java.util.ArrayList;

/**
 * This class is used to record keyboard inputs. It works together with up and
 * down key to go to the previous and next input (if there exist).
 */
public class InputRecord {

	private String command;
	private ArrayList<String> commandRecord;
	private int commandPointer;

	public InputRecord() {
		initialize();
	}

	private void initialize() {
		command = "";
		commandRecord = new ArrayList<String>();
		commandPointer = 0;
	}

	protected void setCommand(String command) {
		this.command = command;
	}

	private void setCommand() {
		assert commandPointer >= 0 && commandPointer <= commandRecord.size();
		this.command = commandRecord.get(commandPointer);
	}

	protected String getCommand() {
		return this.command;
	}

	protected void addInputRecord(String command) {
		commandRecord.add(command);
	}

	protected void setNextPointer() {
		commandPointer = commandRecord.size();
	}

	protected void decreaseCommandPointer() {
		if (commandPointer > 0) {
			commandPointer--;
		} else {
			commandPointer = 0;
		}
		setCommand();
	}

	protected boolean increaseCommandPointer() {
		if (commandPointer >= commandRecord.size() - 1) {
			commandPointer = commandRecord.size();
			return false;
		} else {
			commandPointer++;
			setCommand();
			return true;
		}
	}

	/**
	 * It is used to show the previous input.
	 * 
	 * @return the previous input. If there is no previous input, show the first
	 *         input recorded.
	 * 
	 */
	protected String showLastInput() {
		decreaseCommandPointer();
		return getCommand();
	}

	/**
	 * It is used to show the next input.
	 * 
	 * @return the next input. If there is no next input, show nothing.
	 */
	protected String showNextInput() {
		boolean hasNext = increaseCommandPointer();
		if (hasNext) {
			return getCommand();
		} else {
			return "";
		}
	}
}
```
###### ui\view\Overview.fxml
``` fxml

<?import javafx.scene.control.*?>
<?import javafx.scene.text.*?>
<?import java.lang.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.layout.AnchorPane?>

<AnchorPane fx:id="back" maxHeight="700.0" maxWidth="600.0" minHeight="600.0" minWidth="600.0" prefHeight="700.0" prefWidth="600.0" style="-fx-background-color: #c9daf8; -fx-border-color: transparent; -fx-border-width: 0px;" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" fx:controller="ui.view.OverviewController">
   <children>
      <TextField fx:id="input" layoutY="567.0" onAction="#onEnter" promptText="Enter command here" style="-fx-border-width: 2px; -fx-border-color: #337ab7; -fx-font-size: 14;" AnchorPane.bottomAnchor="3.0" AnchorPane.leftAnchor="5.0" AnchorPane.rightAnchor="5.0" />
      <Text fx:id="helpMessageText" strokeType="OUTSIDE" strokeWidth="0.0" AnchorPane.bottomAnchor="36.0" AnchorPane.leftAnchor="15.0" AnchorPane.rightAnchor="15.0" />
      <Text fx:id="returnMessageText" strokeType="OUTSIDE" strokeWidth="0.0" AnchorPane.bottomAnchor="36.0" AnchorPane.leftAnchor="15.0" AnchorPane.rightAnchor="15.0" />
      <Label fx:id="helpMessageLabel" AnchorPane.bottomAnchor="36.0" AnchorPane.leftAnchor="15.0" AnchorPane.rightAnchor="0.0" />
      <Label fx:id="returnMessageLabel" text="Return Message here" AnchorPane.bottomAnchor="36.0" AnchorPane.leftAnchor="15.0" AnchorPane.rightAnchor="15.0" />
      <AnchorPane prefHeight="200.0" prefWidth="200.0" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="550.0" />
      <AnchorPane fx:id="taskPane" layoutX="14.0" layoutY="50.0" prefHeight="200.0" prefWidth="200.0" style="-fx-border-color: transparent; -fx-border-width: 0px;" styleClass="background" stylesheets="@style.css" AnchorPane.bottomAnchor="62.0" AnchorPane.leftAnchor="-1.0" AnchorPane.rightAnchor="-1.0" AnchorPane.topAnchor="-1.0">
         <children>
            <ScrollPane fx:id="taskScrollPane" hbarPolicy="NEVER" layoutX="26.0" layoutY="8.0" onMouseClicked="#onClickScrollPane" prefHeight="654.0" prefWidth="600.0" style="-fx-border-color: transparent; -fx-background-color: transparent; -fx-border-width: 0px;" AnchorPane.bottomAnchor="-5.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" />
         </children></AnchorPane>
   </children>
</AnchorPane>
```
###### ui\view\OverviewController.java
``` java
package ui.view;

import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import javafx.animation.FadeTransition;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.ScrollPane.ScrollBarPolicy;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;
import javafx.scene.text.Text;
import javafx.util.Duration;
import logic.Logic;
import shared.Constants;
import shared.Output;
import shared.Output.Priority;
import shared.SharedLogger;
import storage.Storage;
import ui.Main;

public class OverviewController {

	@FXML
	private AnchorPane back;

	@FXML
	private TextField input;

	@FXML
	private Label returnMessageLabel;

	@FXML
	private Text returnMessageText;

	@FXML
	private Label helpMessageLabel;

	@FXML
	private Text helpMessageText;

	@FXML
	private AnchorPane taskPane;

	@FXML
	private ScrollPane taskScrollPane;

	private Logger logger = SharedLogger.getInstance().getLogger();

	VBox vbox;

	Main mainApp;

	// By default, the year of a date is hidden.
	private boolean isYearShown = false;
	private String inputTrimmed;

	private ReturnMessage returnMessage;
	private HelpMessage helpMessage;
	private InputRecord inputRecord;

	private Storage storage = new Storage();
	private Logic logic = new Logic(storage);

	/**
	 * Initialize components in the UI.
	 */
	@FXML
	public void initialize() {
		initializeVBox();
		initializeTaskScrollPane();
		initializeMessages();
		initializeDisplay();
		initializeInputListener();
		initializeInputTrace();
		setFocus(vbox);
	}

	/**
	 * Initialize the Vbox, which contains all the taskViews.
	 */
	private void initializeVBox() {
		vbox = new VBox(3);
		vbox.setPrefWidth(600);
		vbox.setPrefHeight(705);
		vbox.setStyle(String.format("-fx-background-color: %1$s;", Constants.COLOR_DAY));
	}

	private void initializeTaskScrollPane() {
		assert taskScrollPane != null;

		taskScrollPane.setContent(vbox);
		taskScrollPane.setVbarPolicy(ScrollBarPolicy.NEVER);
	}

	private void initializeMessages() {
		helpMessage = new HelpMessage(helpMessageLabel, helpMessageText);
		returnMessage = new ReturnMessage(returnMessageLabel, returnMessageText);
	}

	/**
	 * Display the default view.
	 */
	private void initializeDisplay() {
		logger.log(Level.INFO, "going to initialize the overview");

		try {
			Output output = processInput("display");
			Output lastDisplay = processInput("display");

			assert output != null;
			assert lastDisplay != null;
			display(output, lastDisplay);
		} catch (Exception ex) {
			System.err.println("Initialize default display failed " + ex.getMessage());
			logger.log(Level.WARNING, "display command processing error", ex);
		}

		logger.log(Level.INFO, "end of processing initial display command");
	}

	/**
	 * Initialize an input listener, which caters for immediate help messages.
	 */
	private void initializeInputListener() {
		input.textProperty().addListener((observable, oldValue, newValue) -> {
			clearReturnMessage();
			helpMessage.genereateHelpMessage(newValue);
		});
		logger.log(Level.INFO, "Input listener initialized.");
	}

	private void initializeInputTrace() {

		inputRecord = new InputRecord();
		input.setOnKeyPressed(new EventHandler<KeyEvent>() {

			@Override
			public void handle(KeyEvent event) {
				if (event.getCode().equals(KeyCode.UP)) {
					input.setText(inputRecord.showLastInput());

				} else if (event.getCode().equals(KeyCode.DOWN)) {
					input.setText(inputRecord.showNextInput());
				}
			}
		});
		logger.log(Level.INFO, "Input trace initialized.");
	}

	/**
	 * Set the focus always to the input textField, when clicking inside
	 * Flexi-List. Scrolling the tasks still works.
	 */
	private void setFocus(VBox vbox) {
		vbox.addEventHandler(MouseEvent.MOUSE_CLICKED, new EventHandler<MouseEvent>() {

			@Override
			public void handle(MouseEvent event) {
				input.requestFocus();
				event.consume();
			}
		});
	}

	private void clearReturnMessage() {
		if (returnMessageLabel.getText().equals(null) || helpMessageLabel.getText().equals(null)) {
			return;
		}
		if (returnMessage.hasReturnMessage() && helpMessage.hasHelpMessage()) {
			returnMessage.cleanReturnMessage();
		}
	}

	/**
	 * Specify actions when the user types Enter.
	 */
	public void onEnter() {
		returnMessage.cleanReturnMessage();

		try {
			trimInput();
			if (isEmptyInput()) {
				return;
			} else if (isQuitHelpInput()) {
				quitHelpView();
			} else if (isHelpInput()) {
				displayFullHelpMessage();
			} else if (isChangeViewInput() && !isInHelpView()) {
				changeView();
			} else if (isYearCommand() && !isInHelpView()) {
				displayYear();
			} else {
				getOutput();
			}
			input.clear();
		} catch (Exception e) {
			logger.log(Level.INFO, "Error in handling user input " + e.getMessage());
			System.err.print("Error in handling user input " + e.getMessage());
		}
	}

	private void trimInput() {
		inputTrimmed = input.getText().trim();
	}

	private boolean isInHelpView() {
		return !taskScrollPane.getContent().equals(vbox);
	}

	private void quitHelpView() {
		taskScrollPane.setContent(vbox);
		back.setStyle("-fx-background-color: " + Constants.COLOR_DAY + ";");
	}

	private void displayFullHelpMessage() {
		back.setStyle("-fx-background-color: #ffffff;");
		FullHelpView fullHelpView = new FullHelpView();
		taskScrollPane.setContent(fullHelpView);
		setFocus(fullHelpView);
		logger.log(Level.INFO, "Changing to full help view");
	}

	/**
	 * Change background color of Flexi-List.
	 * 
	 * @param viewCommand
	 *            Day command or Night command.
	 */
	private void changeView() {
		assert inputTrimmed != null;

		if (inputTrimmed.equals(Constants.COMMAND_NIGHT)) {
			vbox.setStyle(String.format("-fx-background-color: %1$s;", Constants.COLOR_NIGHT));
			back.setStyle("-fx-background-color: " + Constants.COLOR_NIGHT + ";");
			helpMessage.changeTheme(inputTrimmed);
			returnMessage.changeTheme(inputTrimmed);
			logger.log(Level.INFO, "Changing to night theme");
		}

		if (inputTrimmed.equals(Constants.COMMAND_DAY)) {
			vbox.setStyle(String.format("-fx-background-color: %1$s;", Constants.COLOR_DAY));
			back.setStyle("-fx-background-color: " + Constants.COLOR_DAY + ";");
			helpMessage.changeTheme(inputTrimmed);
			returnMessage.changeTheme(inputTrimmed);
			logger.log(Level.INFO, "Changing to day theme");

		}
	}

	/**
	 * Refresh the tasks being displayed currently, with the years shown.
	 * Floating tasks will not be affected.
	 */
	private void displayYear() {
		assert input.getText() != null;
		if (input.getText().equals(Constants.COMMAND_SHOW_YEAR)) {
			isYearShown = true;
		} else {
			isYearShown = false;
		}
		Output output = logic.getLastDisplayed();
		display(output, output);
		logger.log(Level.INFO, "Display year setting toggled");
	}

	private void getOutput() {
		recordInput();
		Output output = processInput(inputRecord.getCommand());
		Output lastDisplay = logic.getLastDisplayed();
		display(output, lastDisplay);
	}

	private void recordInput() {
		String inputString = input.getText();
		assert inputString != null;
		inputRecord.setCommand(inputString);
		inputRecord.addInputRecord(inputRecord.getCommand());
		inputRecord.setNextPointer();
	}

	public Output processInput(String input) {
		try {
			return logic.processInput(input);
		} catch (Exception e) {
			logger.log(Level.INFO, "Fail to obtain output from logic " + e.getMessage());
			System.err.println("Fail to obtain output from logic " + e.getMessage());
		}
		return null;

	}

	private void display(Output output, Output lastDisplay) {

		returnMessage.cleanReturnMessage();
		helpMessage.cleanHelpMessage();

		String message = output.getReturnMessage();
		returnMessage.setReturnMessage(message);

		Priority priority = output.getPriority();
		returnMessage.flashReturnMessage(priority);

		ArrayList<ArrayList<String>> outputArrayList = lastDisplay.getTasks();
		displayTasks(outputArrayList);
	}

	/**
	 * Display tasks vertically. All the fade-in animation works simultaneously.
	 * 
	 * @param outputArrayList
	 */
	private void displayTasks(ArrayList<ArrayList<String>> outputArrayList) {
		vbox.getChildren().clear();

		if (outputArrayList.size() == 0) {
			return;
		}
		for (ArrayList<String> list : outputArrayList) {
			TaskView taskView;
			try {
				taskView = new TaskView(list, isYearShown);
				vbox.getChildren().add(taskView);
				fadeInTaskView(taskView);
			} catch (Exception e) {
				logger.log(Level.INFO, "Error in creating a taskView " + e.getMessage());
				System.err.println("Error in creating a taskView " + e.getMessage());
			}
		}
	}

	/**
	 * Perform a fade-in animation when tasks are displayed.
	 * 
	 * @param taskView
	 */
	private void fadeInTaskView(TaskView taskView) {
		FadeTransition ft = new FadeTransition(Duration.millis(600), taskView);
		ft.setFromValue(0.0);
		ft.setToValue(1.0);
		ft.play();

	}

	private boolean isYearCommand() {
		return inputTrimmed.equals(Constants.COMMAND_SHOW_YEAR) || inputTrimmed.equals(Constants.COMMAND_HIDE_YEAR);
	}

	private boolean isEmptyInput() {
		return inputTrimmed.equals("");
	}

	private boolean isQuitHelpInput() {
		return inputTrimmed.equals(Constants.COMMAND_QUIT_HELP);
	}

	private boolean isHelpInput() {
		return inputTrimmed.equals(Constants.COMMAND_HELP);
	}

	private boolean isChangeViewInput() {
		return inputTrimmed.equals(Constants.COMMAND_DAY) || inputTrimmed.equals(Constants.COMMAND_NIGHT);
	}

	/**
	 * The method is required for changing focus to the text field.
	 */
	public void onClickScrollPane() {
	}

	/**
	 * Is called by the main application to give a reference back to itself.
	 * 
	 * @param mainApp
	 */
	public void setMainApp(Main mainApp) {
		this.mainApp = mainApp;

	}

	public Storage getStorage() {
		return this.storage;
	}

	public Logic getLogic() {
		return this.logic;
	}
}
```
###### ui\view\ReturnMessage.java
``` java
package ui.view;

import javafx.animation.FillTransition;
import javafx.animation.SequentialTransition;
import javafx.scene.control.Label;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.Text;
import javafx.util.Duration;
import shared.Constants;
import shared.Output.Priority;

/**
 * This class is used to display return messages.
 */
public class ReturnMessage {

	private static final int MESSAGE_FONT = 15;

	private Label returnMessageLabel;
	private Text returnMessageText;
	private String returnMessage;
	// The default font color is black.
	private Color currentColor = Color.BLACK;

	public ReturnMessage(Label returnMessageLabel, Text returnMessageText) {
		initialize(returnMessageLabel, returnMessageText);
	}

	private void initialize(Label returnMessageLabel, Text returnMessageText) {
		this.returnMessageLabel = returnMessageLabel;
		this.returnMessageText = returnMessageText;
		this.returnMessageLabel.setFont(Font.font(MESSAGE_FONT));
		this.returnMessageText.setFont(Font.font(MESSAGE_FONT));
		returnMessageLabel.setTextFill(Color.TRANSPARENT);
	}

	protected void setReturnMessage(String returnMessage) {
		if (returnMessage == null) {
			this.returnMessage = "";
		} else {
			this.returnMessage = returnMessage;
		}

		returnMessageLabel.setText(this.returnMessage);
		returnMessageText.setText(this.returnMessage);

	}

	/**
	 * If the priority of a return message is high, flash it in red. 
	 * If the priority of a return message is low, flash it in green.
	 * 
	 * @param priority
	 */
	protected void flashReturnMessage(Priority priority) {
		Color color;

		switch (priority) {
		case LOW:
			color = Color.rgb(25, 193, 133);// Color.GREEN;
			break;
		case HIGH:
			color = Color.RED;
			break;
		default:
			color = Color.BLACK;
			break;
		}

		FillTransition textWait = new FillTransition(Duration.millis(800), returnMessageText, currentColor,
				currentColor);
		textWait.setCycleCount(1);

		FillTransition textHighlight = new FillTransition(Duration.millis(1400), returnMessageText, currentColor,
				color);
		textHighlight.setCycleCount(1);

		FillTransition textBlack = new FillTransition(Duration.millis(1400), returnMessageText, color, currentColor);
		textBlack.setCycleCount(1);

		SequentialTransition sT = new SequentialTransition(textWait, textHighlight, textBlack);
		sT.play();
	}

	protected void cleanReturnMessage() {
		assert returnMessageLabel != null;
		assert returnMessageText != null;
		returnMessageLabel.setText("");
		returnMessageText.setText("");
		returnMessage = "";
	}

	protected boolean hasReturnMessage() {
		return returnMessageLabel.getText().length() > 0;
	}

	protected void changeTheme(String command) {
		if (command.equals(Constants.COMMAND_DAY)) {
			currentColor = Color.BLACK;
			returnMessageText.setFill(currentColor);
		} else if (command.equals(Constants.COMMAND_NIGHT)) {
			currentColor = Color.WHITE;
			returnMessageText.setFill(currentColor);
		}
	}
}
```
###### ui\view\style.css
``` css
.anchor-pane {
	-fx-border-color: transparent;
}

.background {
    -fx-background-color: #afeeee;
}

.scroll-pane > .viewport  { 
	-fx-background-color: #ffffff;
	-fx-border-color: transparent;
}


.vbox {
    -fx-background-color: #afeeee;
    -fx-border-color: transparent;
    -fx-padding: 15;
    -fx-spacing: 10;
}
```
###### ui\view\TaskView.java
``` java
package ui.view;

import java.util.ArrayList;
import java.util.List;

import javafx.geometry.Pos;
import javafx.scene.Group;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.scene.text.Font;
import javafx.scene.text.Text;
import javafx.scene.text.TextAlignment;

/**
 * This class is used to display tasks in Flexi-List. A task displayed includes
 * its index, task name, time and date (if applicable). It also includes a
 * background, where its color depends the type of the task.
 */
public class TaskView extends Group {

	private static final boolean isWin = System.getProperty("os.name").toLowerCase().contains("win");

	// Unused indexes are commented out to avoid warning, but they are remained
	// for future reference.

	// private static final int INDEX = 0;
	// private static final int TASKNAME = 1;
	private static final int START_TIME = 2;
	// private static final int START_WEEKDAY = 3;
	private static final int START_DATE = 4;
	// private static final int START_MONTH = 5;
	private static final int START_YEAR = 6;
	private static final int END_TIME = 7;
	// private static final int END_WEEKDAY = 8;
	private static final int END_DATE = 9;
	// private static final int END_MONTH = 10;
	private static final int END_YEAR = 11;
	private static final int MARK = 12;
	private static final int OVERDUE = 13;
	private static final int LISTSIZE = 14;

	private static final int MAXIMUM_LENGTH = isWin ? 40 : 50;
	private static final int BOUNEDED_CONTAINER_HEIGHT = 44;
	private static final int UNBOUNEDED_CONTAINER_HEIGHT = 25;
	private static final int INDEX_FONT = 14;
	private static final int TASKNAME_FONT = 16;
	private static final int TASKNAME_INDENTATION = 40;
	private static final int CONTAINER_WIDTH = 600;
	private static final int CALENDARVIEW_TRANSLATE_X = 440;
	private static final Color COLOR_TASK_CONTAINER = Color.rgb(51, 122, 183); // moderately dark blue
	private static final Color COLOR_EMERGENT = Color.rgb(255, 126, 85); // slightly dark orange
	private static final Color COLOR_DONE = Color.rgb(166, 166, 166); // moderately dark grey
	private static final Color COLOR_OVERDUE = Color.rgb(222, 103, 100); // sightly light red

	private boolean hasYear;
	private boolean isFloating;
	private boolean isDone;
	private boolean isToday;
	private boolean isOverDue;
	private boolean isEmergent;
	private ArrayList<String> list;
	private List<String> start;
	private List<String> end;
	private Text taskNameText;
	private Text indexText;
	private String index;
	private String taskName;

	private StackPane stackPane;
	private Rectangle container;
	private Color backgroundColor;
	private CalendarView calendarView;

	public TaskView(ArrayList<String> list, boolean hasYear) throws Exception {
		initialize(list, hasYear);
		setIsFloating();
		setIsDone();
		setIsToday();
		setIsEmergent();
		setIsOverDue();
		createTaskContainer();
		markEmergent();
		markOverdue();
		setStart();
		setEnd();
		setBackgroundColor();
		setIndex();
		setTaskName();
		setCalendarView();
	}

	private void initialize(ArrayList<String> list, boolean hasYear) throws Exception {
		if (list.size() != LISTSIZE) {
			throw new Exception("List size from output does not match");
		}
		this.hasYear = hasYear;
		this.list = list;
		stackPane = new StackPane();
		stackPane.setAlignment(Pos.CENTER_LEFT);
		this.getChildren().add(stackPane);

	}

	private void setIsFloating() {
		if (list.get(START_TIME).length() == 0 && list.get(END_TIME).length() == 0) {
			isFloating = true;
		} else {
			isFloating = false;
		}
	}

	private void setIsDone() throws Exception {
		String done = list.get(MARK);
		if (done == null) {
			throw new Exception("The mark done field of the task is missing");
		}

		if (done.equals("DONE")) {
			isDone = true;
		} else if (done.equals("UNDONE")) {
			isDone = false;
		} else {
			throw new Exception("An invalid value is assigned to the mark done field");
		}
	}

	private void setIsToday() {
		if (list.get(END_DATE).equals("TODAY")) {
			isToday = true;
		} else {
			isToday = false;
		}
	}

	private void setIsEmergent() {
		isEmergent = list.get(START_DATE).equals("") && isToday && !isDone && !isOverDue;

	}

	private void markEmergent() {
		if (isEmergent) {
			container.setFill(COLOR_EMERGENT);
		} else {
		}
	}

	private void setIsOverDue() throws Exception {
		if (list.get(OVERDUE).equals("true")) {
			isOverDue = true;
			// This field is an empty string for bounded tasks and floating
			// tasks.
		} else if (list.get(OVERDUE).equals("false") || list.get(OVERDUE).isEmpty()) {
			isOverDue = false;
		} else {
			throw new Exception("An invalid value is assigned to the over due field");
		}
	}

	private void markOverdue() {
		if (isOverDue && !isDone) {
			container.setFill(COLOR_OVERDUE);
		}
	}

	private void createTaskContainer() {
		container = new Rectangle();
		container.setWidth(CONTAINER_WIDTH);
		if (isFloating) {
			container.setHeight(UNBOUNEDED_CONTAINER_HEIGHT);
		} else {
			container.setHeight(BOUNEDED_CONTAINER_HEIGHT);
		}

		if (isDone) {
			container.setFill(COLOR_DONE);
		} else {
			container.setFill(COLOR_TASK_CONTAINER);
		}
		stackPane.getChildren().add(container);

	}

	private void setStart() {
		assert START_TIME >= 0;
		assert START_YEAR + 1 < LISTSIZE;
		start = list.subList(START_TIME, START_YEAR + 1);
	}

	private void setEnd() {
		assert END_TIME >= 0;
		assert END_YEAR + 1 < LISTSIZE;
		end = list.subList(END_TIME, END_YEAR + 1);
	}

	private void setBackgroundColor() {
		backgroundColor = (Color) container.getFill();
	}

	private void setCalendarView() {
		try {
			calendarView = new CalendarView(start, end, isDone, hasYear, backgroundColor);
		} catch (Exception e) {
			System.err.println("Error in creating calendar view " + e.getMessage());
		}

		if (isFloating) {
		} else {
			stackPane.getChildren().add(calendarView);
			calendarView.setTranslateX(CALENDARVIEW_TRANSLATE_X);
		}
	}

	private void setIndex() {
		index = list.get(0) + ".";
		indexText = new Text();
		indexText.setText(index);
		stackPane.getChildren().add(indexText);
		indexText.setTranslateX(10);
		indexText.setFont(Font.font("Monaco", INDEX_FONT));
		indexText.setFill(Color.WHITE);
	}

	private void setTaskName() {
		taskName = list.get(1);
		if (isEmergent && !isOverDue) {
			taskName = "[DUE TODAY] " + taskName;
		} else if (isOverDue) {
			taskName = "[OVERDUE] " + taskName;
		}

		if (taskName.length() > MAXIMUM_LENGTH) {
			taskName = taskName.substring(0, MAXIMUM_LENGTH) + " ...";
		}
		taskNameText = new Text();
		taskNameText.setText(taskName);
		stackPane.getChildren().add(taskNameText);
		taskNameText.setFont(Font.font(TASKNAME_FONT));
		taskNameText.setTextAlignment(TextAlignment.LEFT);
		taskNameText.setTranslateX(TASKNAME_INDENTATION);
		taskNameText.setFill(Color.WHITE);
	}

}
```
